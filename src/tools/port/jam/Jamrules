#
#  Copyright (c) 2004, 2008  Ingres Corporation
#
#
#  Name: Jamrules -- Main rules file for compiling Ingres with JAM
#
#  Description:
# 	Ingres JAM rules
# 	This file should only contain Jam rules and actions. All other generic
# 	definitions should be placed in Jamdefs. 
#
# 	Platform specific definitions should be placed in 
#	Jamdefs.$(PLATFORM_JAMDEFS) for that platform.  $(PLATFORM_JAMDEFS)
#	is defined in the VERS file.
#
#	Build client specific options and definitions can be placed in
#	the ../conf/VERS file.  The platform Jamdefs.$(PLATFORM_JAMDEFS) file
#	is included after VERS, so it can see any jam variables defined
#	in the VERS, and adjust things accordingly.  (For instance, a64_lnx
#	uses VERS to control various Datallegro site-specific options.)
#	Hybrid-capable platforms define separate 32-bit and 64-bit command
#	and option strings in VERS and/or the platform jamdefs, and then
#	in Jamdefs the proper primary and optional hybrid is selected.
#	By the time Jamrules proper is reached, we work with primary
#	xxx and hybrid xxxHB variables.  No assumption should be made
#	about which architecture is primary vs add-on.
#
#	Jamrules is read when jam first encounters a SubDir rule in
#	a Jamfile.  The first rule in every Jamfile is:
#	SubDir ING_SRC blah blah blah
#	The first token, ING_SRC, is used as a variable to head up the
#	directory path involved;  but it's also used for finding the rules
#	file.  jam concatenates "RULES" (giving ING_SRCRULES) and uses that
#	to locate this jamrules file.  bldenv (run externally) defines
#	ING_SRCRULES to be the path to this rules file.  (VMS uses
#	-s on the jam command line to pass ING_SRCRULES in lieu of
#	using a logical.)
#
#  NOTE:
#	When adding new rules, a brief summary of the new rule should also be
#	added to the RULES DESCRIPTIONS section in the comments
#
# History:
#	13-Jul-2004 (hanje04)
#		Created from very old JAMMING file.
#	14-Jul-2004 (hanje04)
#		Don't run SEDSH from IITOOLSSH
#	16-Jul-2004 (hanje04)
#		Remove Rules to create and run ciutil.
#		Add msghdrs pseudo target to ensure message headers in
#		front!hdr!hdr built before eqc and esqlc
#		Add GRIST to HDRCCPP to stop jam getting confused with
#		like named headers.
#		Remove CCLEX rules in favor builtin JAM Lex rule.
#	20-Jul-2004 (hanje04)
#		Update IIXERCLIB for xerces version 2.5
#	21-Jul-2004 (hanje04)
#		Set GRIST on TARGET not SOURCE in IINOOPTIM
#	21-Jul-2004 (drivi01)
#		Partially modified Jamrules for the build on windows.
#	23-Jul-2004 (hanje04)
#		Add IISIGFILE rule.
#		Use Chmod rule in IICPEXE instead of explicity calling 
#		the system chmod.
#	28-Jul-2004 (hanje04)
#		Add IIVERSREL rule to generate version.rel
#	29-Jul-2004 (hanje04)
#		Add Clean to various rules to improve cleanup on Jam clean.
#	29-Jul-2004 (kodse01)
#		Added rule IIBULKBAT for windows. Integrated other rules with
#		IIBULKBAT. Made boot dependent on MKIDIRDONE for windows.
#	01-Aug-2004 (hanje04)
#		Remove OPTIM and CCPICFLAG from IITOOLSEXE
#		Define include directories for Kerberos.
#		Add Kerberos shared library
#		Define dependencies for other shared libraries.
#		Use HDRGRIST not SOURCE_GRIST when pre-processing headers.
#		Create soft links not hard with _LINK
#	01-Aug-2004 (hanje04)
#		Revert back to SOURCE_GRIST with headers.
#		Set LOCATE on targets in IIFILE.
#	01-Aug-2004 (hanje04)
#		Remove LOCATE on targets in IIFILE, breaks IIAIFHDR
#	2-aug-2004 (stephenb)
#		CLSECRET depends on boot. fix OSLHDR for new HDRCL
#	03-Aug-2004 (kodse01)
#		Removed boot dependency in the IISIGFILES for Windows.
#	03-Aug-2004 (hanje04)
#		Merge IIABFLINK in IIABFOBJS and fix depenencies.
#		Add cleanup to header processing rules
#	04-aug-2004 (somsa01)
#		Utilize CD variable when appropriate. Also, fixed up usage of
#		CCEQMRGW for Windows.
#	04-aug-2004 (drivi01)
#		Modified IINEEDLIBS to associate static libraries if shared
#		if they exist and replace a static library name with shared
#		library and a data library.
#	05-aug-2004 (somsa01)
#		Removed extra eqmerge statement from CCIYACC1W action. Also,
#		uncommented IILIBRARY rules to make eqc work again.
#	05-aug-2004 (lakvi01)
#		Added action _UDTIIADDW for windows.
#	09-aug-2004 (drivi01)
#		Created CCSHW rule, as well as modify compile
#		flags for object files in IILIBRARY rule.
#	09-Aug-2004 (kodse01)
#		Added Clean for many generated targets. Added rule IIUDTFILE.
#		Changed _HDRSQSC rule to use basefile name for EQSQLDA and
#               EQSQLCA for windows.
#	10-aug-2004 (drivi01)
#		Modified dependencies in IISHLIBRARY and modified 
#		IMPORT_DLL_DATA/REFERENCE_IN_DLL flags for some files
#		and directories.
#	11-aug-2004 (drivi01)
#		Modified dependencies in IINEEDLIBS.
#	12-aug-2004 (drivi01)
#		Fixed a bad submission that lost previous changes.
#		Modified order of case statements in IINEEDLIBS.
#	12-aug-2004 (kodse01)
#		Added _MSGTXTW for windows. Changed _CALLBZARCHBAT so that
#		bzarch.h is built only when required. Added cases for 
#		APILIB and ICEAPILIB in IINEEDLIBS rule. Changed IICCPPFILE 
#		rule and _CRSW actions for windows.
#	12-aug-2004 (drivi01)
#		Fixed some dependencies in IIQSHHDR and IIQSC rules and
#		in IISHLIBRARY to prevent the same files rebuilding
#		for no reason.
#	13-aug-2004 (drivi01)
#		Fixed IITOOLSEXE to work on windows, as well
#		as some dependencies and libraries in IINEEDLIBS
#		and added action for creation of shared libs with 
#		no def files (needed for play_NewOrder.dll).
#	13-aug-2004 (drivi01)
#		Fixed compile flags for some directories in IIBINEXE
#		and IILIBRARY.
#	16-aug-2004 (drivi01)
#		Added a new rule IISLN to deal with solutions in visual
#		tools.  
#	18-Aug-2004 (kodse01)
#		Changed awk to $(AWK). Changed few actions to run with gawk too.
#	18-aug-2004 (drivi01)
#		Fixed jamrules to be able to find precompilers in the 
#		3rd level directories.  Added rules for building ice
#		and odbc shared libraries and executables, as well
#		as generate help files.
#	18-aug-2004 (drivi01)
#		Lost NOUPDATE in IISHLIBRARY rule for data shared libraries.
#	19-aug-2004 (drivi01)
#		Fixed compilation of .mc files to .h.
#	19-aug-2004 (drivi01)
#		Replaced all references to .o with new suffix $.(OBJSFX)
#		to work on windows.
#	19-Aug-2004 (drivi01)
#		Forcing IIFILES to copy all its files over at boot time.
#	25-Aug-2004 (drivi01)
#		Modified IIICEFILE rule to copy from $(SEARCH_SOURCE)/$(>)
#	        b/c it was confusing makefile.wnt with other directories.
#		Fixed IIMCTOH and also replaced directory pathes with variables.
#	26-Aug-2004 (kodse01)
#		Added action SEDSHW for windows.
#	26-Aug-2004 (drivi01)
#	        Partially cleaned up Jamrules, and added rule for copy dlls
#		to destinations other than II_SYSTEM/ingres/bin or lib.
#		Also fixed Xerces rule, and added action for compilation of
#		shared libraries without import library.
#	26-Aug-2004 (lakvi01)
#		Added IITOOLSWNTEXE, IITFILES and IITBIN rules to create/copy 
#		required files in $INGTOOLS.
#	27-Aug-2004 (kodse01)
#		Changed IIXERCLIB rule for windows. Fixed SEDSHW.
#	30-Aug-2004 (kodse01)
#		Used IIBULKBAT instead of BULK in many rules for windows.
#		Changed IIICEFILE to have original FILE statement.
#	31-Aug-2004 (kodse01)
#		Fixed IIMCTOH rule. Made fasti clean as default option.
#	02-Aug-2004 (kodse01)
#		Changed the IISLN rule to have dependencies.
#	07-Aug-2004 (kodse01)
#		Corrected the dependencies in IISLN rule.
#	07-Aug-2004 (drivi01)
#	        Added a rule for using cazipxp.exe on directories.
#	        Added some dependencies in IINEEDLIBS and modified
#	        some header directories specific to windows 
#	        s.a. common/odbc/winspecials_win.
#		Added special cases in IISHLIBRARY with individual
#		rules of compilation. Wrote rule LIBOBJECT for compiling
#		and copying object files, as well as rule for compiling 
#	        help files in odbc and copying dlls.
#	08-Aug-2004 (kodse01)
#		Added dependencies on esqlcc and esqlc in IISLN.
#	01-Sep-2004 (hanje04)
#		Include defines from default.h when running ccpp
#	4-sep-2004 (stephenb)
#	        Various fixups for 64-bit hybrid build. Also change the link
#		paradigm to use relative library linking (Solaris has problems
#	 	with absolute link paths)
#	08-sep-2004 (somsa01)
#		Corrected _CHARSET action for Windows.
#	10-Sep-2004  (drivi01)
#		Fixed a bug in IIBINEXE with CMPORTS flag,
#		added more cases with flag swapping, and removed
#		some Flags in IILIBRARY to generalize by directories,
#		added rebase and IINEEDOBJ rule that works the same
#		way as IINEEDLIBS except it links object files.
#	13-Sep-2004 (drivi01)
#	        Modified all test tools to be placed in ing_tools/bin on
#		windows.  Added IINEEDRES rule to include res files in
#		exe and dll compilations on windows, as a result cleaned
#		up IISHLIBRARY rule.  Fixed up rc rule. Fixed headers for
#		winspecials_win in odbc.
#	14-Sep-2004 (drivi01)
#		Added _ICEHTML action to replace tokens s.a. #cgi# and #ext# 
#		in ice html files.
#	14-Sep-2004 (drivi01)
#		Fixed ingodb.dll compilation and added common/hdr/hdr to
#		a list of headers for common/odbc/winsepcaials_win.
#	14-Sep-2004 (drivi01)
#		Compilation of g4util.c in abfrt was falling through the
#		wrong case statement, added a case statement for g4util.c.
#	14-sep-2004 (stephenb)
#		Fix shared library dependencies and add 64-bit version. Also
#		make lp64 directory for ucharmaps and remove HDRABF64, it's
#		now taken care of in mkidir
#	16-sep-2004 (stephenb)
#	 	Another hybrid fix. certain timing can cause jam to
#		not find an input file for Objects64, specifically when
#		running CCROFIX. re-grist the file in CCROFIX to the 32-bit
#		source file.
#	16-Sep-2004 (bonro01)
#		Add cleanup rules for most files.
#	17-Sep-2004 (drivi01)
#		Added a case statement for main files in cobol directories
#		to compile with IMPORT_DLL_DATA.
#	17-Aug-2004 (bonro01)
#		Add rules for 64-bit Hybrid files.
#		Replace .so with $(SLSFX)
#	20-Sep-2004 (drivi01)
#		Fixed creation of messages.txt by removing space where 
#		sed scripts are being redirected to a file.
#	20-sep-2004 (abbjo03)
#	    Add ExeShell rules for dealing portably with executable scripts.
#	21-Sep-2004 (drivi01)
#		Added depends on library for
#		iilibutil.dll and removed extra IIMCTORC statement.
#		Added Clean pseudo target to a lot of the rules.
#		Modified rebase to be in a separate rule, and now rebase
#		all dlls in bin every time. Fixed cazip and added more rules
#		and actions for ice such as _INSTALLICE, and cleaned up
#		this file. Slightly modified IIUDTOBJECT rule and IIUDTFILE
#		rule to get rid of "don't know how to make" warning on udt.h
#	24-Aug-2004 (hanje04)
#		Add IIMKVERS to create VERS file in tools!port!conf
#	24-Sep-2004 (hanje04)
#	    BUG 113127
#	    Replace UDT objects (.o's) with shared library
#	    Add IIUdtShLib to create shared library.
#	26-Aug-2004 (hanje04)
#		ccpp requires readvers.
#	29-Sep-2004 (shaha03)
#	    Bug 113057
#           Improper Genration of Makefile for UDT sample codes.
#	    Added GRIST to rule IIUDTPPFILE.
#	29-Sep-2004 (shaha03)
#	    Added GRISTs to rules IICCPPFILE and IISIGFILES.
#	29-Sep-2004 (drivi01)
#		Added new rule IINEEDLIBSW which will only be executed
#		on windows.  IINEEDLIBSW will do the same thing as
#		IINEEDLIBS except it will have a compliment libraries
#	 	of IINEEDLIBS which will only be linked on windows.
#		Added special cases for compiling import libraries on
#		unix, files being compiled into import libraries will
#		be separated by grist and compiled into a different
#		static library on unix, see case statements of IILIBRARY.
#	29-Sep-2004 (drivi01)
#		Added "if $(NT)" loop around IITOOLSBAT rule, to get to
#		to execute only on windows.
#	30-Sep-2004 (drivi01)
#		Modified ice to copy source files to II_SYSTEM/ingres/
#		ice/plays/tutorialGuide in INSTALLICE action, modified
#		IIBULKBAT rule to strip off grists if the directory
#		path is appended to the name of the file.
#	05-Oct-2004 (hanch04)
#	    Changed the order of link libraries.
#	    First should be objects, then archives, then shared, then system.
#       06-Oct-2004 (hanch04)
#           Use a special rule for DBMSEXE and action for IILINK
#	06-Oct-2004 (hanje04)
#	    Fix up IIICEFILE and _ICEHTML to be generic
#	07-Oct-2004 (hanje04)
#	    Make sure -D$(VERS) is defined to UDT shared library
#	    Fix up NOOPTIM (drivi01)
#	07-Oct-2004 (drivi01)
#	    During integration some Unix specific rules needed "if ! $(NT)"
#	    loop around them b/c there were unnecessary flags appended
#	    to the link line. Rule used to execute dbutil/duf/hdr .sh files
#	    needed to be changed to work on windows. Wrote windows specific
#	    action for ccpp files.  Modified link line for devenv projects
#	    to include /rebuild flag or /build flag depending if the environ
#	    variable VSREBUILD is set to ON.	
#	08-Oct-2004 (somsa01)
#	    Corrected last change for _SLNDOTNET.
#	08-Oct-2004 (somsa01)
#	    Corrected _INSTALLICE to make it even more generic. Also, on
#	    behalf of drivi01, updated NT septool rule from MakeLocate to
#	    LOCATE.
#	08-Oct-2004 (drivi01)
#	    Modified \\ to $(SLASH) variables for compatability with cygwin,
#	    as well as fixed packaging of ColdFusion.
#	11-oct-2004 (somsa01)
#	    Due to oddity with Cygwin, when using "cp", the last slash used
#	    before the filename source needs to be "/" on Windows. This
#	    "technique" continues to work with MKS.
#	13-Oct-2004 (fanra01)
#           Removed erroneous curly brace causing syntax error.
#	    Modified condition in IITOOLSSH to make NT behaviour same as UNIX
#           on behalf of drivi01.
#	11-oct-2004 (somsa01)
#	    Due to oddity with Cygwin, when using "cp", the last slash used
#	    before the filename source needs to be "/" on Windows. This
#	    "technique" continues to work with MKS.
#	14-Oct-2004 (drivi01)
#	    Fixed xerces to copy dll and lib from correct xerces location.
#	    Added dependency in IIHLPODBC.
#	15-Oct-2004 (bonro01)
#	    Fix CCROFIX rule dependancy by adding Grist to the target file.
#	15-Oct-2004 (drivi01)
#	    Modified Dependency in IIICEFILE to copy files at boot time.
#	    Modified IIHLPODBC rule to avoid warnings at build time.
#	15-Oct-2004 (drivi01)
#	    Added rules and actions for building enterprise dlls that
#	    are local to enterprise_dll directory on windows.
#	19-Oct-2004 (bonro01)
#	    Fix Unix build problems introduced by the Windows jam
#	    rule changes.
#	19-Oct-2004 (drivi01)
#	    Added if loop for accessdb and catalogdb shells in IIBINSH
#	    to ignore them in IIBINSH on windows. Fixed dependencies for
#	    .qsh files to avoid unnecessary rebuilds of header files.
#	    Modified IISLN rule to do LOCATE on targets in the correct
#	    directories, as well as fixed dotnet dependecies by making 
#	    dataprovider a pseudotarget.  Modified IISHICEMS rule to 
#	    copy iiicems.dll to II_SYSTEM/ingres/ice/bin.
#	20-Oct-2004 (drivi01)
#	    Added ice pseudotarget that depends on files, to avoid conflict
#	    of cazipxp trying to zip up files that weren't copied yet.
#	    Fixed IIMCTOH rule by adding _IIMCTOH2 action for special cases
#	    such as perfmon and tngapi directories.
#	20-Oct-2004 (bonro01)
#	    Fix more Unix build problems introduced by the Windows jam
#	    rule changes.
#	27-Oct-2004 (hanje04)
#	   Fix up IIUdtShLib for 64bit
#	   Replace all .$(OBJSFX) with builtin $(SUFOBJ). Former should no
#	   longer be used.
#	   Fix up rules creating UDT stubs
#	   Use BYACCPATTERN as HDRSCAN on .yi files to stop cyclic dependency
#	   on pslsgram.yi and pslgram.yi.
#	   Add IIEsqlHdr Rule (and action) to copy eqsqlca.h and eqsqlda.h 
#	   into place at correct time to stop unnecessary rebuilds on second
#	   itterations of jam
#	28-oct-2004 (somsa01)
#	   Corrected REBASE offset.
#	29-Oct-2004 (drivi01)
#	   Added dependcy of .c files on .qsc, added more fixes for visual 
#	   projects, such as logic for figuring out destination directories 
#	   correctly.
#	28-Oct-2004 (hanje04)
#	   Correct HDR directory name in IISUBSYS to reflect new locations
#	   Remove PATH to VERS in _USETOOL
#	29-Oct-2004 (drivi01)
#	   Modified dependencies in IIRCTORES rule there was a timeing issue with
#	   IIMCTOH rule which creates .res file.
#	27-Oct-2004 (hanje04)
#	   Fix up IIUdtShLib for 64bit
#	   Replace all .$(OBJSFX) with builtin $(SUFOBJ). Former should no
#	   longer be used.
#	   Fix up rules creating UDT stubs
#	29-Oct-2004 (drivi01)
#	   Modified IICLSADT and IIUSERADT to not depend on iimerge on windows.
#	30-Oct-2004 (drivi01)
#	   Modified IIICEFILE rule to stript of grist when doing SEARCH on source.
#	01-Nov-2004 (hanje04)
#	   Use LOCATE not MakeLocate in IIUdtShLib
#	30-oct-2004 (stephenb)
#	   Fix sed for Solaris in _ICEHTML
#	02-nov-2004 (abbjo03)
#	    Initial set of changes to build on Alpha VMS.
#	04-nov-2004 (abbjo03)
#	    Changes to build bzarch.h on VMS.
#	05-nov-2004 (abbjo03)
#	    Changes to build the CL on VMS.
#       08-Nov-2004 (sheco02)
#	    Remove duplicated IIVERSREL rule and add if block for rule IIVERSREL 
#	    and modify _IIVERSREL action accordingly.
#       09-Nov-2004 (sheco02)
#	    Modify the rule INSTALLHLP by adding preprocessing with IISedShell 
#	    before copying over to INGMANIFEST directory.
#	12-Nov-2004 (bonro01)
#	    Fix IIINSTALLHLP rule to run SED on .hlp files
#	12-Nov-2004 (drivi01)
#	    Modified build process by adding two more target directories: 
#	    preinstall and thinclient.  Also added pseudotarget for those two 
#	    directories called postbuild.  Created new rules IIMkPreInstall
#	    and IIMkThinClient which are invoked in windows specific code 
#	    in frontcl/files and copy needed exe, dlls and other files
#	    to correct locations in preinstall and thinclient.
#	    Also fixed vdba shared libraries to be copied to INGBIN.
#	    IIMkPreInstall, IIMkThinClient are windows specific rules.
#	15-Nov-2004 (drivi01)
#	    Removed windows specific MKIDIRDONE call outside of rules in Jamrules.
#	    Added a rule IIBULKCOPY to copy files just like IIBULKBAT except copy
#	    them with the rest of the files on "files" pseudotarget, redefined some
#	    windows specific portions of the rules to move files to ING_BUILD with
#           other files on  "files" rather than at boot time. Fixed up rules
#	    for compilation of solution files to place dlls in INGBIN.
#	16-nov-2004 (abbjo03)
#	    Add Link and IINeedObj rules for VMS and related actions.
#	17-Nov-2004 (drivi01)
#	    Switched flag REFERENCE_IN_DLL to IMPORT_DLL_DATA for gcn
#	    and gcc directories b/c they are no longer compiled into
#	    SHGCFLIB and iigcn and iigcc should be compiled locally.
#       18-Nov-2004 (Ralph.Loen@ca.com)
#           Extended drivi01's IMPORT_DLL_DATA change above to gcd for
#           the IILIBRARY rule and for gcc and gcd in the IIBINEXE rule.
#	20-Nov-2004 (hanje04)
#	   Tokenize version info in RPM packages
#	24-nov-2004 (abbjo03)
#	    Remove Link and IINeedObj rules/actions for VMS. Add Link actions
#	    for VMS based on inglink script. Other changes needed to build
#	    eqc on VMS.
#	01-dec-2004 (abbjo03)
#	    Changes needed to build esqlc and the hdrs target on VMS.
#       01-dec-2004 (hweho01)
#           Added support for AIX hybrid build.
#	03-dec-2004 (abbjo03)
#	    Replace bulk of non-portable constructs that prevent Jam build on
#	    VMS.
#	03-dec-2004 (drivi01)
#	    Added LINKLIBS statement to iilibutil.dll to link in msi.lib due
#	    to recent code changes.
#	09-dec-2004 (drivi01)
#	    Fixed head revision of Jamrules to work on windows, added LOCATE
#	    statement back in a windows specific block in IILIBRARY, fixed
#	    some file separators to be consistent with Jamdefs, moved creation
#	    of version.rel file to IIVERSREL rule on windows.
#	9-Dec-2004 (schka24)
#	    64-bit iimerge needs to depend on 64-bit iimerge.o, not 32-bit
#	    one.  It would get rebuilt, but not changed, quite confusing.
#	09-Dec-2004 (bonro01)
#	    Modified UDT build to specify the correct header directories.
#	20-Dec-2004 (drivi01)
#	    Modified IIICEFILE rule to search/replace #cgi# and #ext# tokens in
#	    .css files.
#	20-Dec-2004 (drivi01)
#	    Take out postbuild out of main jam build, make it a separate step.
#	    Fix pbcopy to copy individual file instead of a group.
#	22-Dec-2004 (sheco02)
#	    Modify the IILIBRARY and IINOOPTIM rule in order to honor NOOPTIM.
#	22-Dec-2004 (sheco02)
#	    Fixed the problem of missing version.rel by changing ING_BUILDROOT
#	    back to ING_BUILD.
#	27-Dec-2004 (sheco02)
#	    Back out the above change because ING_BUILDROOT is defined in Jamdefs
#	    rev 49.
#	30-Dec-2004 (hweho01)
#	    Modified 64-bit character map build for AIX.
#	17-dec-2004 (abbjo03)
#	    Additional changes to build on VMS: Xerces, byacc, old message
#	    files, etc.
#	06-jan-2005 (abbjo03)
#	    Changes to build shared libraries on VMS.
#	07-jan-2005 (abbjo03)
#	    Add $(PIPE) in actions _FORM so VMS can use the commands.
#	10-jan-2005 (abbjo03)
#	    Add ALLVERS to remove files portably.
#	11-Jan-2005 (drivi01)
#	    Modified psf data dll to export Psf_srvblk and Psf_init symbols
#	    which were previously exported in psf dll, as a result psf is
#	    compiled using REFERENCE_IN_DLL flag except psf/yacc which still
#	    is compiled with IMPORT_DLL_DATA.
#	13-Jan-2005 (drivi01)
#	    SharedLibLink action on windows is missing together keyword,
#	    as a result it's possible for jam to break link line into
#	    several link lines which is impossible when def file is used.
#	13-Jan-2005 (hweho01)
#	    Modified the setting of OPTIM in IILIBRARY, IIOPTIM should 
#           be appended into OPTIM, otherwise NOOPTIM will not be honored 
#	    for the Unix/Linux platforms. 
#	20-Jan-2005  (shaha03)
#	    Corrected the syntax in rule "IIUdtShLib" in specifying the 
#	    targets for lp64 objects.
#	    Assigned required cc flags "CCVERSFLAGHB" for lp64 objects 
#	    in rule "IIUdtShLib".
#	19-Jan-2005 (hanje04)
#	   Make version.rel dependent on VERS file so it is recreated when
#	   the build number is changed
#	19-Jan-2005 (hanje04)
#	   Specify include path for #include "file.h" style includes in files 
#	   passed to ccpp.
#	19-Jan-2005 (hweho01)
#	   For AIX build, need to add special linker options for ice server.  
#	25-jan-2005 (abbjo03)
#	   Remove Vision tutorial. Fix Lex actions for VMS. Fix IISIGEXE.
#	21-Jan-2005 (srisu02)
#	   Add IILibSh rule for VMS
#	28-Jan-2005 (hanje04)
#	   BUG 113805
#	   Add IILangFile to allow copying of languages files to alternate
#	   names.
#     	30-Jan-2005 (hanje04)
#          Replace IIABFOBJ with IIAbfObj as ABFTRSLIB has been removed and
#          objects are recreated directly from source
#      	30-Jan-2005 (hanje04)
#	   Remove directory from temp files in IICCPPFILE to stop CRS files
#	   ending up as 0 length files.
#     	01-Feb-2005 (drivi01)
#	   Due to change #474734, yyreswd was being exported only as 
#	   _declspec(dllexport), had to switch some flags from IMPORT_DLL_DATA
#	   to REFERENCE_IN_DLL.
#	02-feb-2005 (abbjo03)
#	   Remove unused URS library.
#     	03-Feb-2005 (sheco02 for hanje04)
#	   Modify rule IIAbfObj as Sun WS C compiler refuses to compile an object 
#	   with .obj as its suffix.
#	07-feb-2005 (abbjo03)
#	   Add explicit Cc actions for VMS in order to properly handle OPTIM.
#          Change .stamp file in IITIMEZONE to tz.stamp so that Jam won't
#          have problems finding the file on VMS. Fix _MNXO actions to find
#          oldmsg files in oldmsg_unix_vms.
#	07-Feb-2005 (fanra01)
#	    Sir 113881
#	    Update includes directories for tngapi. 
#	08-feb-2005 (abbjo03)
#	    IIUDTSHELL needs to use IIExeShell to create the targets with the
#	    correct extension.
#	07-Feb-2005 (fanra01)
#	    Sir 113881
#	    Update includes directories for tngapi. 
#	Feb-10-2005 (drivi01)
#	   Modified IIMCTOH rule to place tngmsg.h in front/st/hdr directory.
#	   Removed IIMKVERS action on windows.
#	10-feb-2005 (abbjo03)
#	    Fix IINEEDLIBS rule so that shared libraries needed by an
#	    executable are built before trying to link it. Fix _MNXO rule.
#	10-Feb-2005 (bonro01)
#	    Add rules for building tst directory.
#	14-Feb-2005 (hweho01)
#	    Modify the OPTIM handling for rules of IIBINEXE, IIUTILEXE,
#           IIICEBINEXE and IISIGEXE, so the optimization flag can  
#           be set properly and the NOOPTIM can be honored. 
#	14-Feb-2005 (hweho01)
#	    Modify the OPTIM handling for rules of IIBINEXE, IIUTILEXE,
#	18-Feb-2005 (sheco02)
#	    Modify action to _COLDATAHB to make sure 64 bit collation files like
#	    multi, spanish and udefault are built properly for 64 bit platforms.
#	18-Feb-2005 (drivi01)
#	    Added grists to some files that are being copied and have the 
#	    same names, for example help files with the same name for
#	    each language.  Enhanced IIFSMNX rule to figure out where
#	    international files should be copied to, and also added grist
#	    on source files.  Updated IIBINEXE rule to compile ercomp.c 
#	    with IMPORT_DLL_DATA flag on windows.
#	23-feb-2005 (abbjo03)
#	    Miscellaneous fixes to build on VMS.
#	02-mar-2005 (abbjo03)
#	    Fix IIMSGTXT actions for VMS to deal with command-line restrictions.
#	07-Mar-2005 (hanje04)
#	    Need the version of ingres being built in some of the shell 
#	    scripts. Get it using ccpp.
#	07-Mar-2005 (drivi01)
#	    Modified further build process to include international pdf, hlp,
#	    as well as msg, and form files.  Modified IIFSMNX processing
#	    to avoid command-line restritions on VMS.
#       09-Mar-2005 (hanje04)
#           SIR 114034
#           Add support for reverse hyrid builds. All variables that
#           previously ended in 64 (e.g. VERS64) now end in HB (e.g. VERSHB).
#           In the case of the regular hybrid builds, the old variables are
#           now used to set the new variables.
#           For reverse hybrid builds, variables ending in 32 (e.g VERS32)
#           are set in the platform specific Jamdefs file and are used to
#           set the HB varirables. Main64, Objects64 and Library64 and all
#	    other rules and actions ending in 64 have been renamed in the 
#	    same way. 
#           If VERS64 is set, it is assumed to be a regular hybrid, if VERS32
#           is set then it is assumed to be a reverse hybrid. Both cannot be
#           set at the same time.
#           The string "lp64" has been replaced with a $(SUFHB)
#           which is set based whether VERS64 of VERS32 is set.
#	    Remove generation of $(SUFHB)/rtiforms.fnx as they are never
#	    used and just bloat the saveset.
#	10-Mar-2005 (toumi01)
#	    New CcScToInc rule and action for dataldr sqlcopy.sc program
#	    which pre-processes to sqlcopy.inc. (Thanks, Viktoriya!)
#	10-Mar-2005 (drivi01)
#	    Added a search statement for fe.cat.msg in IIFSMNX rule,
#	    the rule couldn't find fe.cat.msg.
#       09-Mar-2005 (hanje04)
#           SIR 114034
#           Add support for reverse hyrid builds. All variables that
#           previously ended in 64 (e.g. VERS64) now end in HB (e.g. VERSHB).
#           In the case of the regular hybrid builds, the old variables are
#           now used to set the new variables.
#           For reverse hybrid builds, variables ending in 32 (e.g VERS32)
#           are set in the platform specific Jamdefs file and are used to
#           set the HB varirables. Main64, Objects64 and Library64 and all
#	    other rules and actions ending in 64 have been renamed in the 
#	    same way. 
#           If VERS64 is set, it is assumed to be a regular hybrid, if VERS32
#           is set then it is assumed to be a reverse hybrid. Both cannot be
#           set at the same time.
#           The string "lp64" has been replaced with a $(SUFHB)
#           which is set based whether VERS64 of VERS32 is set.
#	    Remove generation of $(SUFHB)/rtiforms.fnx as they are never
#	    used and just bloat the saveset.
#	14-Mar-2005 (drivi01)
#	    Modified IIFSMNX rule to refer to FECATMSG without a grist
#	    for consistency reasons throughout Jamrules.
# 	14-Mar-2005 (hanje04)
#	    Override MkDir1 action for UNIX to use mkdir -p so rule doesn't 
#	    fail if directory already exists.
#	15-Mar-2005 (hanje04)
#	    Minor tweeks for hybrid builds.
#	17-Mar-2005 (lazro01)
#	   Added new rule IICppNeedLibs which will only be executed
#	   on UnixWare. IICppNeedLibs will do the same thing as
#	   IINEEDLIBS does except it will set LINKLIBS differently for
#	   C++ executables. Also modified IIBINEXE & IIUTILEXE
#	   to set LINKFLAGS differently for C++ files in case of UnixWare.
#	   These changes are required for UnixWare as C compiler and C++
#	   compiler are different.
#	16-Feb-2005 (bonro01)
#	    Fix dependency for IIPWD
#	    Add dependency to mkgv for readvers, genrelid, ccpp
#	    Add dependency to ccpp for CONFIG
#	16-Mar-2005 (hanje04)
#	    Add missing ;
#	21-Mar-2005 (drivi01)
#	    Added if $(NT) block in IILIBRARY rule to fix the fact that it got
#	    lost somewhere during propagation.  Fixed IISLN rule to set LOCATE 
#	    on shared libraries in a correct location.  Made wincluster depend  
#	    on shared libraries instead of import libraries to avoid rebuilding.
#	21-Mar-2005 (drivi01)
#	    Modified slightly IIICEFILE rule to deal properly with grists for
#           images.
#	23-Mar-2005 (hanje04)
#	   Don't build lp32/iimerge or lp32/iimerge.o for reverse hybrid.
#	   Need to use a "as" from cross-compiler for IA64 Linux so
#	   do so.
#	28-Mar-2005 (drivi01)
#	    Modified IINEEDRES rule to search for target in target's directory
#	    if the directory is hardcoded in the target name, this will get rid 
#	    of tngmsg.res errors.  Modified IIVERSREL to reference readvers.bat
#           on windows instead of readvers.  Added MkDir1 actions for windows
#	    as well as modified IISLN rule to avoid rebuilding.  Added full path
#	    to udt.h in IIUDTOBJECT rule.
#	31-Mar-2005 (srisu02)
#           Made a couple of changes for AIX porting:-
#           - Changed library names` suffix from 64 to HB due to reverse 
#             hybrid changes
#           - Added '-b64' for linking of UDT Shared libraries
#	31-Mar-2005 (drivi01)
#	     Jam was giving two "don't know how to make" messages.  Fixed
#	     dependencies to avoid those messages.
#	1-Apr-2005 (drivi01)
#	    Added grist for linux in IIDFILES rule.
#	1-apr-2005 (abbjo03)
#	   Provide VMS versions of _IntCatStart and _IntCat. Fix VMS actions
#	   for _MNX, _MNXO and IICCPP.
#	01-Apr-2005 (drivi01)
#	    Modified all windows specific link actions to include /PDB flag and
#	    pdb filename when DEBUG is not set to ON as part of efforts to
#	    make pdb files available in non-debug environment.
#     	04-Apr-2005 (lakvi01)
#      	   Ported for Windows AMD64 architecture (a64_win).
#	07-Apr-2005 (drivi01)
#	   Fixed IIFORM rule on windows to search on the correct target for
#	   formindex executable.  Before it couldn't find it in the 3rd level
#	   directories.
#	11-Apr-2005 (drivi01)
#	   My change on on 01-Apr-2005 accidently removed Link action from
#	   Jamrules when DEBUG is set to on.  Put the action back.
#	11-Apr-2005 (hanje04)
#	   General Jam fix up on Linux/UNIX.
#		- setting NOUPDATEHDRS will now greatly reduce the ammount
#		  that gets rebuild.
#		- Eliminate 'independent target' warnings see on ROC files
#		- Everything "should" now jam to completion on the first
#	  	  jam from scratch and nothing should rebuild on the second
#		  iteration.		
#	12-Apr-2005 (sheco02)
#	   Fixed IIVERSREL rule for 64 bit platforms.
#	13-Apr-2005 (lakvi01)
#	   On windows, made dll's have same permissions of exes. So that other
#	   users (e.g. testenv) can execute the binaries that require them. This
#	   problem is seen when cygwin is used.
#	14-Apr-2005 (drivi01)
#	   Modified IISLN rule to keep grist on source files throughout the 
#	   whole rule.
#	17-Apr-2005 (drivi01)
#	   (WINDOWS ONLY)
#	   Modified Archive action to remove object file before adding updated
#	   instead of just replacing it, to avoid problems with bad replacements.
#	19-Apr-2005 (lakvi01)
#	   Corrected permission of dll's in bin on windows, by adding Chmod in
#	   the actions. (SharedLibLink etc) 
#	19-Apr-2005 (bonro01)
#	   Fix _OSLHDR problem caused by change 476407 which prevented _OSLHDR
#	   from determining the ALIGN_RESTRICT value.
#	21-Apr-2005 (kodse01)
#	   Fixed IIVERSREL rule for reverse hybrid platforms.
#	21-apr-2005 (abbjo03)
#	   Fix MKVERS actions for VMS.
#     17-Apr-2005 (drivi01)
#        (WINDOWS ONLY)
#        Modified Archive action to remove object file before adding updated
#        instead of just replacing it, to avoid problems with bad replacements
#     19-Apr-2005 (lakvi01)
#        Corrected permission of dll's in bin on windows, by adding Chmod in
#        the actions. (SharedLibLink etc)
#     19-Apr-2005 (bonro01)
#        Fix _OSLHDR problem caused by change 476407 which prevented _OSLHDR
#        from determining the ALIGN_RESTRICT value.
#     21-Apr-2005 (kodse01)
#        Fixed IIVERSREL rule for reverse hybrid platforms.
#     21-Apr-2004 (loera01) SIR 114358
#          Added IIKRB5OBJECTS rule for compiling Kerberos driver code.
#          Added link information for iilibgcskrb.dll in the IISHLIBRARY
#          rule.
#	25-Apr-2005 (drivi01)
#	    SIR: 114339
#	    Windows crsfiles are merged with generic. IICRSW and SEDCCPP were
#	    modified to acomodate new changes.
#	06-May-2005 (drivi01)
#	    Removed all odbc case statements except *odbc* from IISHLIBRARY
#	    windows specific code, they were added there by accident instead
#	    of VMS specific code.  Added no grist to new Depends statement in 
#	    IIICEFILE.
#	18-May-2005 (lakvi01)
#	    In IISHLIBRARY rule (for NT) iilibutil.dll was not linked with 
#	    bufferoverflowu.lib. Corrected it. This is required on WIN64 only
#	    and nothing happens on int_w32 and other platforms.
#	19-May-2005 (drivi01)
#	   Overwrote actions Cc for Unix and Windows only, and only if 
#	   CUSTOMFLAG variable is set.  This change is to enhance jam
#	   to build .i and .s files on Unix, and .i, .asm, and .cod
#	   files on Windows.
#	17-Jun-2005 (drivi01)
#	   Added IIRFILES rule that will copy all readmes in 
#	   tools/techpub/readme to II_SYSTEM so that windows installer can 
#	   pick it up there.
#	23-Jun-2005 (fanra01)
#	   Bug 114726
#	   Update the default case of the switch in the IIICEFILE rule to 
#	   remove source blank grist replacements.
#	14-Jul-2005 (hanje04)
#	   Remove dependency on yapp and yypp from IICRS files as they are
#	   not use and can cause the creation of zero length .crs files. 
#	29-Jul-2005 (gupsh01)
#	    Added new rule IIGcfXlt to compile common!gcf!file *.xlt files
#	    This file does not compile the doublebyte character sets.
#	01-Aug-2005 (drivi01)
#	   Remove -p flag from mkdir action.
#	08-Aug-2005 (drivi01)
#	   Moved dataldr.exe distination on windows to II_SYSTEM/ingres/bin
#	   instead of II_SYSTEM/ingres/vdba.  Modified copying of play_NewOrder.h
#	   to avoid "don't know how to make" message during build on windows.
#       10-Aug-2005 (hweho01)
#          1) Added rule IIL1OPTIM to handle the level one optimization. 
#          2 )Added rule IIUdtArLib to create UDT archive file. It is needed 
#             for axp_osf platform, and it can be used by other platform 
#             on which UDT shared library can't be loaded correctly at runtime. 
#	17-Aug-2005 (gupsh01, abbjo03)
#	   Corrected IIGcfXlt to build on VMS. Added _YAPPGCFFILE action.
#	07-Sep-2005 (bonro01)
#	    Add IMP application to Ingres installation.
#	16-Sep-2005 (hanje04)
#	    In CCLFM make sure we create the lp${HB} directory before compiling
#	    the for otherwise it has nowhere to go.
#	20-Sep-2005 (drivi01)
#	    Modified dpendency in IIGcfXlt rule on yapp to depend on yapp.exe
#	    on windows, Jamrules on windows is suffix sensitive.
#	    Changed dependency for _USETOOL to be on source instead of target
#	    b/c dependency on the target in this particular scenario doesn't
#	    make sence.
#	20-Sep-2005 (hanje04)
#	   SIR 115239
#	   Add substitution of BUILD_NO to IIRELDAT so that it can be used 
#	   to process rpmconfig.ccpp. This is required to be able to toggle
#	   packaging of Spatial Objects easily
#	21-sep-2005 (abbjo03)
#	   Change the actions _CHARSET on VMS to create the charset directories.
#	21-Sep-2005 (drivi01)
#	   Added new rule for IIReadMeHtml which is designed to parse generic 
#	   readme.html.template and replace the link and the name of the link 
#	   to the platform specific readme with correct strings. Basically 
#	   PLATFORM_STRING will be replaced with $(platform_string) - newly
#	   defined value in platform specific Jamdefs and #extension_string
#	   will be replaced wtih readme_$(config_string).html to form 
#	   for example readme_int_w32.html.
#	27-Sep-2005 (bonro01)
#	   Add grist for IIUTILSH rule to fix build for
#	   front/st/shell_unix/install.sh
#	03-Oct-2005 (bonro01)
#	   Support for Sun High Availability Clusters.
#       17-Oct-2004 (loera01) Bug 115408
#          Added KRB5HDR definition for VMS.
#	20-Oct-2005 (hanje04)
#	   Fix up IIXERCLIB to work on Mac.
#	20-Oct-2005 (drivi01)
#	   Minor adjustments to 2 rules, to get them to build
#	   in main.
#	26-Oct-2005 (hanje04)
#	   Modify IIUdtShLib to work for spatial objects too.
#       22-Nov-2005 (karye01)
#          Modified IICCPP to unset sun (-Usun). 
#	06-Feb-2006 (drivi01)
#	   Added UDTDEMO directory to the include path for spacial objects.
#       08-Feb-2006 (hweho01)
#          Modified IINEEDLIBS, IIUdtShLibs and _COLDATAHB for  
#          AIX platform.      
#	13-Feb-2006 (hanje04)
#	   To allow a build to be cleanly rebuild after it has been setup as
#	   an installation, with blowing away the installation a new set of
#	   rules and actions have been created for pre-compiling the .sh,
#	   .qh & .qsh header files. Eqh and Esqh and their corresponding
#	   actions ensure that the symbol table is renamed before eqc or
#	   esqlc are run. It is then renamed back again afterwards.
#	   So that this is only necissary for the headers, the dependacies
#	   have also been changed so that the charater set files are built
#	   during the hdrs section of the build.
#	03-Mar-2006 (hanje04)
#	   BUG 115796
#	   Add IIPtoolsBinSh for processing patchtools.
#       22-Mar-2006 (hanje04)
#          BUG 115796
#          Remove build.timestamp file from $ING_BUILD (created buildrel)
#          during 'jam clean'.
#	31-Mar-2006 (drivi01)
#	   Adopted IIMKVERS rule on windows. Added clean instructions
#	   for VERS file and gv.rc and gv.res. Modified _USETOOL
#	   dependencies to have ccpp depend on VERS file.
#	   Fixed dependencies in IISLN rule. Defined environment variable
#	   VERS_ALARM, when set the variable will not allow for automatic 
#	   copying of platform specific VERS to VERS (on windows only).
#	   Force IICRSW rule to clean up .sed files in crs directory.
#	   Fix dependecies for visual tools.
#	03-apr-2006 (abbjo03)
#	    Add $(PIPE) to actions _ReadMeHtml to allow it to be used on VMS.
#	20-Apr-2006 (kschendel)
#	   Fix missing $ in $(NT) test in above, broke non-winders build.
#	20-apr-2006 (abbjo03)
#	    Add actions Eqh and Esqh for VMS.
#	25-apr-2006 (drivi01)
#	    Fix "if (NT)" block to be "if $(NT)".  Add a missed '$'.
#	27-Apr-2006 (hanje04)
#	   BUG 115796
#	   Add IIPatchHtml for creating patch notes templates for an arbitrary
#	   build from the generic templates under $PTOOLSROOT
#	 
#	28-Apr-2006 (drivi01)
#	   Replaced Jay's NOUPDATEHDR environment variable introduced for 
#	   Unix platforms with NOREBUILD environment variable and extended
#	   its functionality to windows.  Modified dependencies so that 
#	   executables that depend on shared libraries include shared libraries
#	   instead of depend on them and hence don't rebuild.  The same 
#	   functionality was extended to shared libraries that include
#	   other shared libraries.  Modified copying of shared libraries
#	   from lib to bin via a separate rule now isntead of making
#	   action do all the work, this is a better way of representing this
#	   dependency.  Updated Chmod1 action and CPEXE actions to be
#	   updated to avoid copying of binaries that didn't get rebuilt due
#	   to shared library rebuilding. Overwrote chmod action on windows.
#	   Modified IIBULKCOPY rule on Windows to fix dependecy issues in 
#	   sig.  Take out -use_inc flag from action that builds version.rel. 
#	02-May-2006 (drivi01)
#	   Vdba tools are installed into II_SYSTEM/ingres/bin, modified 
#	   the rule to build vdba tools into II_SYSTEM/ingres/bin consistent
#	   with that behavior.
#	11-May-2006 (drivi01)
#	   Removed RmTemps call from IICRSW it was causing undesired results
#	   on windows.
#	12-May-2006 (drivi01)
#	   Remove "updated" clause off IICPEXE action if NOREBUILD flag 
#	   is not set.
#	08-Jun-2006 (hanje04)
#	   Bug 115796
#	   Remove INCLUDES changes from UNIX and VMS as they cause a lot of
#	   unnecessary rebuilds.
#       19-June-2006 (Ralph Loen) SIR 115708
#          For the ODBC CLI, override the CMPORTS definition to $(PORTIMP)
#          (IMPORT_DLL_DATA).
#       03-Jul-2006 (kibro01)
#          Bug 116105
#          Ensure that two Makefile.ccpp files in different directories
#          do not overwrite each other (meaning that the release ended up
#          with ice Makefile in the api demo directory).
#	27-Jul-2006 (kschendel)
#	   Pass the DBMS_UDT thingie to iilink, for auto-UDT inclusion.
#	   Also allow IISedShell processing to see it, for iisudbms.
#	   (Datallegro.)
#       31-Jul-2006 (bolke01) 115176
#          Add New rules for patchtools so that patch exec builds with Jam.
#          These rules are used by changes made to Patchtools to add the new
#          exec path for executables.
#	9-Aug-2006 (bonro01)
#	    Remove SEARCH on $(CRSFILES) because the individual crsfiles
#	    have already had a SEARCH statement that locates them in the
#	    front!frontcl!files directory. This SEARCH would overlay the
#	    previous search and prevent the files from being located.
#	9-Sep-2006 (bonro01)
#	    Simplify genrelid so that is does not require -lpHB parm.
#     	25-Sep-2006 (drivi01) SIR 116656
#	   Modified IISLN rule to build .Net data provider 2.0 via
#	   VS2005 while the rest of the code is built using Visual Studio
#	   .NET 2003. .NET Data provider 2.0 will be built via batch file
#	   which will set environment to VS2005, build data provider and
#	   reset it back to VS2003.
#       16-Oct-2006 (hanal04) Bug 116866
#          Modified NOOPTIM to ensure debug compiler flag is not turned off
#          when explicitly set.
#	19-Oct-2006 (hanje04)
#	    SIR 116907
#	    Add HDR info for front!st!rfapi
#	20-Oct-2006 (hanje04)
#	    SIR 116977
#	    Add new rules for building the Linux GUI installer and the Ingres
#	    package manager WITHOUT invoking the hybrid portion of the build.
#        2-Jan-2007 (hanal04) Bug 117413
#          Added C++ override to allow .cpp files to be built debug when
#          IIOPTIM is set.
#      4-Apr-2007 (hanal04) Bug 118027
#         Buld what we install.
#
#		IINoHbBinExe
#		IINoHbUtilExe
#		IINoHbLibrary
#		IINoHbNeedLibs
#
#	    Also add HDR info for the new directories for the same projects:
#
#		 front!st!gtkinstall_unix
#		 front!st!gtkinstall_unix_win
#		 front!st!packman_unix_win
#	30-Oct-2006 (drivi01)
#	    Modified "if" condition in IISLN for dotnet provider.
#	08-Nov-2006 (drivi01)
#	    SIR #116833
#	    Added additional routines to get csharp demo to build with
#	    Visual Studio 2005 compiler.
#	20-Nov-2006 (drivi01)
#	    Added routine to help locate .csproj file for c# demo.
#	01-Dec-2006 (hanje04)
#	    SIR 116977
#	    Update IIDFILE to create target directory if it does exist.
#	03-Jan-2007 (clach04)
#		Cloned change from "19-June-2006 (Ralph Loen) SIR 115708"
#		for gateway usage, essentially define IMPORT_DLL_DATA 
#		to ensure GLOBALREFS are externs and not DLL declarations
#		under Windows.
#		
#		Added gateway specific header locations to IISUBSYS rule
#		to ensure correct headers picked up. I.e. added gwf/hdr
#		and host specific locations such as Oracle ProC/OCI includes.
#		
#		Modified message (msg/mnx) file generation actions (under 
#		Windows only):
#		  * EA slow message files start with letter "s" not word
#		    "slow", modified check accordingly
#		  * Added explicit output filename when calling ercompile
#	04-Jan-2007 (bonro01)
#	    Fix IIDFILES rule dependency on target dir
#     	08-Jan-2007 (hweho01)
#           Define BYTE_SWAP in iiadd.h header file if it exists in   
#           bzarch.h for the platform.
#	11-jan-2007 (dougi)
#	    Added "-l" flag to BYACCFLAGS to avoid plethora of errors from
#	    #line statements.
#	01-Feb-2007 (drivi01)
#	    Added routine for merging manifest files with executables.
#	    Routine will only merge files if manifest exists and MT variable
#	    is set.
#	8-Feb-2007 (bonro01)
#	    Updated Kerberos5 headers to r1.6
#	    Eliminated need for -DKRB5_SYSTYPES__
#     	13-Feb-2007 (hanal04) Bug 117665
#           Add DECIMAL scale and precision MARCOs to iiadd.h from iicommon.h
#           Without these the user is reduced to looking through the source
#           code to find out how to set db_prec in UDFs.
#	19-Mar-2007 (drivi01)
#	    Added rule IIWiFiles to copy icons/bmps from 
#	    from/st/enterprise_pixmap_unix_win to front/st
#	    windows installer directories.
#        2-Apr-2007 (hanal04) Bug 117753
#           Add grist rules for Windows branch of IISIGFILES in order to
#           prevent Jam getting confused over multiple files called 
#           readme.html.
#	12-Apr-2007 (hanje04)
#	    SIR 117985
#	    Need to add CCLDSERVER to link line for iimerge.o as it's needed
#	    for PowerPC Linux. Variable is defined in Jamdefs.ppc_lnx
#	28-Apr-2007 (hweho01)
#	    Add system libraries to the linker list for spatial shared 
#           library on AIX, fix the runtime error. 
#	3-May-2007 (bonro01)
#	    Fix build dependency for Solaris HA cluster files.
#        3-May-2007 (hweho01)
#           Modified IIUdtArLib rule, so it can be used to create spatial  
#           archive file for axp_osf platform. 
#       14-May-2007 (hanal04) Bug 118320
#           iilink no requires -nosol flag to explicitly avoid linking
#           the Spatial Object Library.
#	16-May-2007 (upake01)
#	    Add rule IIKitInstalData and actions for generating Kitinstal.Data
#           for VMS.
#	31-May-2007 (drivi01)
#	    Fix IISIGEXE to properly set LOCATE directory on Windows.
#	07-Jun-2007 (hanje04)
#	    SIR 118425
#	    Add $XERCVERS to variables being replaced by SEDCCPP.
#	13-Jun-2007 (kschendel)
#	    Add a non-absolute symlink action IISYMLINK and use it to
#	    symlink the libxerces aliases in the build/lib subdirectory.
#	    Prior to this fix, the libxerces aliases would point at
#	    the build lib directory, which may have nothing to do with
#	    the ultimate installed lib directory!
#	02-Jul-2007 (drivi01)
#	    Update link custom action, add error check after link
#	    batch command.  Action returns incorrect status if link
#	    command fails with error and the next command in the 
#	    action doesn't fail.
#	02-Jul-2007 (drivi01)
#	    Add the same error check for Debug scenario.
#	31-Jul-2007 (kiria01) b117955
#	    Added rules for fi_defn.txt and fi_defn.awk
#       03-Aug-2007 (Ralph Loen) SIR 118898
#           On Windows, mark the gssapi32.dll and gssapi32.lib files
#           as temporary and delete them after the Kerberos driver is built.
#	10-Aug-2007 (kiria01) b118937
#	    Correct FiRoc etc rules to cater for lp64 adding missing
#	    dependancy and avoiding use of :BS required by Windows.
#	    (MKS awk oddly strips \a from variable parameters!)
#	30-Aug-2007 (drivi01)
#	    Modified link command for executables to use SEARCH_SOURCE
#	    as the directory location to specify full path to MANIFEST
#	    $(>:D) variable sometimes was expecting to multiple 
#	    pathes to a file.
#	5-Sep-2007 (kschendel)
#	    The IICCFLAGS rule has to set both C++FLAGS and CCFLAGS, because
#	    the library source in question might be a c++ file.  Non-PIC
#	    objects don't work too well in shared libraries.
#	04-Oct-2007 (drivi01)
#	    SEARCH_SOURCE doesn't always correspond to source directory.
#	    Adjust command line responsible for manifest compilation
#	    to use $(>[1]:D) to make sure it only uses directory path
#	    of the first input file.
#	15-Oct-2007 (hanje04)
#	    BUG 118937
#	    Set SEARCH and LOCATE correctly for hybrid target in IIFiRoc &
#	    IIFiRocLu as only a single source file (.roc) is used when building
#	    the 2 resulting .o files.
#	15-oct-2007 (abbjo03)
#	    Add change dir steps to VMS FiH/Roc/RocLu actions.
#       8-Oct-2007 (hanal04) Bug 119262
#           Added archive iimerge.a alternative to shared library server.
#	19-oct-2007 (kschendel)
#	    Define ING_VERSDIR so that Jamdefs can read VERS for build
#	    client jamming options.  Update leadin comments.
#	19-Nov-2007 (bonro01)
#	    Update IIGV rule to add dependency for iisysdep.
#	28-Nov-2007 (drivi01)
#	    Added rule IIWiFile to copy and rename blank icons/bmps from 
#	    from/st/gpl_pixmap_unix_win to front/st windows installer 
#	    directories.
#       12-dec-2007 (bolke01)
#           Corrected mis-type VMS sed lines.
#           Changed IICCPPFILE rule to build CCPP files on VMS. It wasn't
#           creating an intermediate file if the .PRT file existed, but the
#           .CCPP file was modified.
#           CCLFM for VMS picked up the compform symbol so the action CCLFM has 
#           been modified to force use of the EXE.
#           Added Clean rules to delete files created from LFM files
#           Correctly detected required directories ( VMS only) that previously
#           gave an error if already existing.
#           Added a specific Rule path for IIINCLUDE for VMS.
#           Added an action for VMS's genrelid iso we can update the patchhtml templates
#           Housekeeping: Added the SUFEXE, SUFXSH to all USETOOL lines
#                         enabling jam to be run from any location.
#                         A second pass of this will be submitted for UNIX/Windows
#           To do: remove all specific IF statements that are hardcoded to
#                  add .exe and .bat to for NT builds.
#	10-Jan-2008 (bonro01)
#	    Add IIRemRCComments to remove Development comments from
#	    shell scripts
#       08-jan-2009 (bolke01)
#           Corrected change of 12-dec-2007 to enable Ingres to build
#           inglink first.  Add Rule IITOOLSDcl.
#           Added additional Depends boot and USETOOL requirements.
#	10-Jan-2008 (drivi01)
#	    Ported to FTjam 2.5.2 on Windows.
#	    Updated IICPEXE to not copy existing binaries if NOREBUILD
#	    is turned on.  NOREBUILD is there more for rebuilding dlls
#	    which wouldn't require rebuilding of headers, formindexes,
#	    and charsets to minimize unnecessary rebuilds.
#	    NOREBUILD doesn't need to be set in _USETOOL as much as it is
#	    remove 4 NOUPDATE conditions.
#	    Grist oosymbol.roc when it is being copied to II_SYSTEM\ingres\lib
#	    so it isn't treated as a separate file and rebuilt 2nd time.
#	    2nd rebuild puts object into lib causing .c file to be newer.
#	    Modify INCLUDES in IISHLIBRARY to more specifically target
#	    dlls being pulled into dlls.
#	    Replace TOOLSET with JAM_TOOLSET which seems to be a prefered
#	    variable in a new jam.
#	    Remove RmTemps and Clean actions overwrites, they're not
#	    not needed on Windows.
#	16-Jan-2008 (kschendel) b121701
#	    Missing usetool of ccpp on iiccppfile temp target caused jam
#	    to sometimes (ie if CONFIG changed) try to ccpp the result
#	    without sed'ing the temp file first, resulting in zero length
#	    output and broken builds.  Fix.
#	04-Feb-2008 (hanje04)
#	    SIR S119978
#	    Add support for Intel OSX
#	10-Mar-2008 (kiria01) b120085
#	    Removed the RmTemps from CCROC so that the .c files can be debugged
#	    and the souce can be picked up by Klocwork
#	11-Mar-2008 (smeke01) b120071
#	    Amended Jam use of Cygwin gawk & sed so that output is DOS
#	    format. Also Cygwin does not supply egrep, so use grep -E.
#	    All done using a USE_CYGWIN switch so as to not affect other
#	    Windows Unix toolsets.
#       10-Mar-2008 (hanal04) Bug 119979
#           Add missing readvers.bat dependency information to allow
#           .pp files to be built from the local directory.
#       23-Apr-2008 (hanje04)
#           Add ability to reference a second location for the Xerces
#           library on hybrid builds using XERCESLOCHB
#       06-may-2008 (horda03)
#           Remove USETOOL ... genrelid from Unix version of IIPtoolsBinSh rule.
#           with this in place Jam -a doesn't rebuild the patchtools/tools/shell/kit
#           files.
#       08-May-2008 (horda03) b120349
#           Manually override headers list when building IPM to include back/dmf/hdr
#           where LGD_STATES is defined. 
#       13-may-2008 (horda03)
#           The IIGV rule on Unix (and linux) requires the iisysdep utility be created
#           first. This dependency was inadvertantly removed, thus cause gv.h creation
#           to fail.
#       16-May-2008 (hanal04) Bug 120390
#           Add a dependency between the embedded and abf parser executables
#           and the grammar files used to build them.
#       21-May-2008 (bolke01) Bug 117648
#           incorporate additional change for building On VMS from any directory.
#       28-may-2008 (horda03)
#           Delete the .map, .stb and .dsf files that may be created as part of
#           the JAM CLEAN. Modified the clean action on VMS to delete each
#           file individually to get around the problem seen when releative
#           paths are used after an absolute path; the absolute's paths device
#           is prepended to the relativ path - so clean may not delete the file.
#	29-may-2008 (joea)
#	    Remove IITOUCH as it is not needed.
#	23-Jun-2008 (drivi01)
#	    Make Ingres Frequent Flyer demo depend on Ingres.Client.dll 
#	    from .NET Data Provider 2.0 so that Frequent Flyer demo is built 
#	    successfully with its dependencies in place and we can
#	    modify it to use .NET Data Provider in the build area to build
#	    the demo.	
#       23-Jun-2008 (hweho01)
#           Include embed/hdr directory for building libqsys library.
#	21-Jul-2008 (kiria01) b120473
#	    Added IIAduPatHdr and IIAduPatBdy for ADU
#       11-Aug-2008 (hweho01)
#           Defined PROD_PKGNAME for product packaging utility files.
#           Added _SEDREL which is used by IIRELDAT for package 
#           configuration files.
#       22-Sep-2008 (horda03)
#           IIPToolsBin and IIPToolsLib now honor the IIOPTIM setting.
#       15-Oct-2008 (whiro01)
#           Added /nologo to $(AR) and $(MT) invocations to reduce noise.
#       16-Oct-2008 (hanal04) Bug 117648
#           Previous change for Bug 117648 broke IIPtoolsBinSh on UNIX.
#       29-Oct-2008 (horda03)
#           Clean build.timestamp on VMS.
#	24-Nov-2008 (drivi01)
#	    Fix SLN2 action, add space between $(DEVENVFLAGS) and $(BUILD)
#	    variables.  $(DEVENVFLAGS) was blank on x86 up to now,
#	    but is causing problems after /nologo was assigned to it.
#	16-dec-2008 (joea)
#	    Replace BYTE_SWAP by BIG_ENDIAN_INT.
#	17-dec-2008 (joea)
#	    Remove byteswap utility.
#       19-Jan-2009 (hanal04) Bug 121162
#           Added IILDFLAGS so that additional LD flags can be specified
#           for specific programs. IILDFLAGS should be placed AFTER IIBINEXE
#           rules or any other rules that may establish an initial value
#           for LINKFLAGS.
#       29-Jan-2009 (hweho01)
#           Added permission settings in IIUdtArLib rule.
#	04-Feb-2009 (bonro01)
#	    Fix IILIBEXE rule to allow the IIOPTIM variable to be defined
#	    for files built with this rule.
#           Define SUFRB to be the opposite of SUFHB so that it can be used
#           with the DBMSEXE rule to set the proper iilink parameter for
#           the non-Hybrid server.  This prevents iilink from prompting for
#	    the 32bit or 64bit server when the build area is defined as a 
#	    running installation.
#	09-Feb-2009 (drivi01)
#	    Update rebase action to get around digitally signed binaries
#	    and the failures that may cause when action executes.
#	    The following changes introduced:
#	    1. We will try to rebase all dlls the way we used to do first
#	    2. If rebase suceeds which it will when the build is being done
#	       for the first time before the binaries are signed, we will
#	       generate a coffbase file with base addresses for each dll.
#	       We will keep re-generating the file every time rebase of all  
#	       dlls succeeds. We will deffinately get a complete coffbase 
#	       before initial buildrel execution (before the image is rolled)
#	       because the image can not be rolled until all binaries are
#	       built.  We will add a padding of 0x10000 to each binary for
#	       growth.
#	    3. If the initial rebase fails (step 1), then use the coffbase
#	       file to rebase just one binary on a base address specified
#	       there.
#	19-Feb-2009 (drivi01)
#	    Update rebase action to do the following:
#	    1.  Use -C flag instead of -c to reduce some of the processing
#		required in the action.
#	    2.  Only run 3rd condition in the action if the shared library
#		is located in $(II_SYSTEM)\ingres\bin
#	    3.  Add functionlity for updating the coffbase file with
#		correct sizes and base addresses after digital signatures were
#		applied and the file can no longer be refreshed using 
#		rebase command.	        
#	23-Feb-2009 (bonro01)
#	    Fix IIRELDAT problem where the target was getting built with zero
#	    length because the rule contained two actions and the first
#	    action was sometimes not getting executed.  This appears to be
#	    a jam bug with dependancies on temporary files.
#	    Fixed the problem by consolidating the action into one _SEDREL
#	    action.
#	12-Mar-2009 (drivi01)
#	    - Make shared libraries depend on binaddr.txt and updcoffbf.exe
#	    to make sure that they're rebased properly after they've been
#	    digitally signed.
#	    - Fix grist on message header files in IIMSGHDR. Dependency
#	    on headers on Windows lists headers without grists, when
#	    message headers attach grists jam can't make the connection
#	    causing a lot of rebuilds.
#	    - Fix Rebase custom action to only run updcoffbf command if the
#	    binary updcoffbf.exe was already built.
#	19-Mar-2009 (bonro01)
#	   Back out part of the previous change which removed the grist from
#	   the IIMSGHDR rule.  This caused some source to fail to compile.
#	24-Jun-2009 (bonro01)
#	    Add IIDBMAXNAME rule to process text files to substitute
#	    DB_MAXNAME.
#	22-Jun-2009 (kschendel) SIR 122138
#	    Check VERS64 for r64_us5 hacks, rather than config-string.
#	    Add ULFLIB to libingres.a dependencies, since mergelibs extracts
#	    ultrace.o from it.  (Doesn't matter on svr-arlib builds, but DOES
#	    matter if svr-shlib.)  Fix a couple VERS64 tests that should have
#	    been VERSHB tests, in dbmsexe and iibinexe rules.  Rework
#	    xerces rule so that xerces primary/secondary architecture is
#	    independent of Ingres build primary/secondary.  (e.g. might be
#	    building int_lnx 32 bit only on a normally a64_lnx 64 bit box.)
#	17-Jul-2009 (kschendel) SIR 122138
#	    Take clean out of IIMKVERS because we don't want to clean VERS.
#	    It is intended to contain site or build customizations, which
#	    should not be lost.
#       18-Aug-2009 (horda03)
#           Ensure .EXE files are built when .LOT files change on VMS.
#       20-Aug-2009 (horda03)
#           Rather than hardcode the "special" VMS .EXE files which are
#           not built using a .LOT file, use a rule VMS_NO_LOT.
#	06-Aug-2009 (drivi01)
#	    Fix IIBULKCOPY to create destination directory where the 
#	    files are being copied.
#	06-Aug-2009 (drivi01)
#	    In efforts to port to Visual Studio 2008, cleaned up
#	    some of the rules for Windows.  The following changes
#	    were made:
#		- Added grists to headers and files being copied to avoid
#	          crossreferences.
#		- Added new flags where neccessary such as $(WCHART)
#		- Added additional routines to enhance clean pseudo target
#		  functionality on Windows.
#		- Added rule IIAdminManifest for creating targets that
#		  need elevations on Vista.
#		- Corrected solutions that needed 2005 compiler to build
#		  to use the existing code instead of hacks put in to 
#		  account for support of 2 compilers.
#		- Modified manifest inclusion for Vista to now include
#		  manifests in all binaries including shared libraries.
#		- Improved manifesting process to use generated manifests
#		  and updated C++ projects or Jamfiles where necessary
#		  to include additional information in manifests
#		- Remove requirements for VS2005 and VS2005SDK variables
#		- Enforce requirements for $(MT) variable to be set.
#	06-Aug-2009 (drivi01)
#	    Cleaned up the Jamrules on Windows:
#	    	- Fixed IIBULKCOPY to create destination directory where the 
#	    	  files are being copied.
#		- Added grists to headers and files being copied to avoid
#	          crossreferences.
#		- Added additional routines to enhance clean pseudo target
#		  functionality on Windows.
#	24-Aug-2009 (drivi01)
#	    In efforts to optimize Windows code with Visual Studio 2008
#	    compiler.  Enhanced IINOOPTIM to work on Wondiws.   
#	28-Aug-2009 (kschendel) b121804
#	    If JAM_AUXINFO is defined (typically as a shell variable),
#	    cause gcc to generate -aux-info into <source>.aux.  (Obviously
#	    this is a gcc extension.)  The aux-info data lists all function
#	    declarations and definitions, and can be processed into a
#	    massive cross-check of function typing across the system.		
#	24-Aug-2009 (bonro01)
#	    Make the VERS override file optional.
#	25-Aug-2009 (hanje04)
#	    Bug 122571
#	    Add IIBinPy, IIUtilPy and ExePy for processing Python modules
#	    into executable scripts.
#	    Remove references to RPM as module has been replaces by a python
#	    script.
#       22-Sep-2009 (hanal04) bug 122620
#           Allow a target shell script called clean to be built in
#           patchtools.
#        2-Oct-2009 (hanal04) Bug 122620
#           Trim the previous change for Bug 122620 to avoid build errors
#           on VMS when PTOOLSBIN is not in use.
#	18-Oct-2009 (bonro01) Bug 116245
#	    Add MkDir to IISIGFILES to make destination dir if necessary.
#	19-Nov-2009 (thich01)
#	    Added HDRGEOS and src/common/adf/adu to IISUBSYS for geospatial.
#	24-Nov-2009 (bonro01)
#	    Fix Windows link problem caused by change 501221 bug 122875
#	17-Dec-2009 (bonro01)
#	    Fix FILE and IIBULKBAT rules so that they make the
#	    destination directory.
#       31-Dec-2009 (horda03)
#           Allow IINEEDOBJ to be used on VMS.
#	25-Jan-2010 (kschendel) b123194
#	    Windows build fixes for 10.0, Cygwin, apache.org Xerces:
#	    - Delete WCHART option which deletes the builtin wchar_t
#	    type definition, was incompatible with apache.org built Xerces.
#	    NOTE: if you start getting link failures against your (old)
#	    Xerces, either recompile it, or get a new one from apache.org.
#	    - IIICEFILE was mkdir'ing junk ice directories in $ING_SRC.
#	    Fix it by attaching the ice path to the target (_t) variable.
#	    - _MNXW action needs to use the DOS style null-device (NUL:),
#	    not the MKS style null-device (C:\nul).
#	    - eliminate duplicated section of copying in INSTALLICE that
#	    wasn't working.
#	19-Feb-2010 (bonro01) b123194
#	    Correct build problem caused by previous change.
#	    Don't eliminate WCHART.  Make /Zc:wchar_t- the default for xerces
#	    2.7 and make the default unset for all newer xerces versions.
#       24-Jan-2010 (hanje04)
#           SIR 123296
#           Allow perms to be over-ridden in IIRemRCComments
#       24-Mar-2010 (hanje04)
#           SIR 123296
#           Add 'grists' to IIRemRCComments as is was getting confused with
#           files of the same name.    
#        4-Feb-2010 (hanal04) Bug 123216
#           Resolve intermittent build failures caused bu HDRGTK being already
#           set without xml2 header location.
#	06-Apr-2010 (hanje04)
#	    SIR 123296
#	    Fix IIRemRCComments after adding grists as targets were always 
#	    being rebuilt. Remove grist an use MkDir instead of MakeLocate
#	    which ensures the target names are always unique.
#	21-Apr-2010 (drivi01) Bug 122651
#	    Switch a REFERENCE_IN_DLL flag to IMPORT_DLL_DATA for ducommon.qsc.
#	    The file was mistakingly getting REFERENCE_IN_DLL flag in the
#	    compiler resulting in extern symbols being imported as 
#	    __declspec(dllimport) on Windows.  This was resulting in
#	    import/export symbol mismatch and link issues. 
#       22-apr-2010 (maspa05) Bug 122651
#           The above problem occurred because of a switch on the full grist
#           filename. Changed this to just the directory - a more general fix.
#	26-Apr-2010 (drivi01) Bug #123633
#	    Add a new rule IISetCMPORTS that is able to set IMPORT_DLL_DATA
#	    or REFERENCE_IN_DLL flags on individual files. The rule should be
#	    called from Jamfiles/MANIFEST files and eliminates the need
#	    for file specific cases in a switch statement in IILIBRARY.
#	26-Apr-2010 (drivi01)
#	    Add new rules for possible reverse-hybrid build on Windows
#	    in a future and for pure 64-bit build.
#	    Port existing rules that are reused to work on Windows.
#	26-Apr-2010 (bonro01)
#	    Add back WCHART variable yet again because it was incorrectly
#	    removed by the previous change.  This is needed to support older
#	    Xerces library versions.
#       27-Nov-2008 (horda03)
#           Ensure the SIG directory exists when building IISIGEXE's.
#	28-Apr-2010 (hanje04)
#	    SIR 123609
#	    Fix actions IIRemRCComments for VMS so it can be used to process
#	    dayfile.dst
#	28-Apr-2010 (hanje04)
#	    SIR 123609
#	    Fix actions IIRemRCComments for Windows.
#	13-May-2010 (bonro01)
#	    Fix typo in IIUCHARALIAS rule from change 504046.
#       21-May-2010 (bonro01)
#           Add conditional compilation for ICE
#       14-Jun-2010 (horda03) b123914
#           Add dependancies to VERS and VERS.<platform> for VMS' kitinstal.data
#       15-Jun-2010 (horda03) b123914
#           Use VERSFILE rather than VERS and VERS.<platform> for kitinstal.data
#           dependancy
#	17-Jun-2010 (hanje04)
#	    BUG 123943
#	    Use more restrictive sed mask in IIRemRCComments so it doesn't
#	    remove the LSB headers
#	3-Jul-2009 (warmerdam)
#	    Added HDRPROJ and src/common/adf/adu to IISUBSYS for geospatial.
#       23-Jul-2010 (horda03)
#           A jam in the genxml directory on NT fails to build the genxml
#           utility because it is unable to find the iilibadf shared library.
#           The IINEEDLIBSW rule is missing the search directories for shared
#           libraries
#	24-Jul-2010 (drivi01)
#	    Remove ICE from build process.
#	28-Jul-2010 (drivi01)
#	    Remove hardcoded dependency of VDBA on SHICEAPILIB.
#	28-Jul-2010 (drivi01)
#	    When msg file in front facilities get updated.  Mnx files
#	    aren't rebuilt b/c there is no dependecy on msg files from
#	    mkfecat script.
#	    Add dependency of fe.cat.msg file on msg files in front.
#	09-Aug-2010 (drivi01)
#	    Port CCLEXW action to cygwin 1.7.  Add u2d conversions
#	    to convert all files to DOS format in the intermediate
#	    steps to avoid syntax errors.
#       13-Aug-2010 (horda03) b124249
#           Rebuild version.rel when the VERS file changes.
#	13-Aug-2010 (drivi01)
#	    Cygwin 1.7 expects shell files on Windows to be
#	    binary and prefers POSIX paths.
#	    Update ShellNt rule to convert shell files to
#	    binary format at build time.
#	16-Aug-2010 (drivi01)
#	    Fix $(USE_CYGWIN) in ShellNT action to 
#	    environment variable %USE_CYGWIN% check.
#       17-Aug-2010 (horda03) b124249
#           Rather than specify VERS or VERS.<platform> use VERSFILE for
#           version.rel dependency.
#       19-Aug-2010 (coomi01) b124278
#           Add IIOPTIM to compile and link stages for rule IITOOLSEXE
#       20-Aug-2010 (horda03)
#           Added IIAWK rule/action to generate .h files (in psl) from
#           some source. Also fixed dependencies in other AWK based
#           rules to ensure correct build order used.
#       09-aug-2010 (joea)
#           Correct _IIAWK action on VMS: need to quote uppercase params.
#	31-Aug-2010 (troal01)
#	    Added IIGeoLibs rule
#	21-Sept-2010 (troal01)
#	    Updated IIGeoLibs to create symlinks
#	30-Sept-2010 (troal01)
#	    IINEEDLIBS updated to only link the geospatial dependencies when
#	    necessary. Also don't dynamically link with ingbuild. GEOS_VERS
#	    GEOSC_VERS and PROJ_VERS added to SEPCCPP rule.
#	01-Oct-2010 (bonro01)
#	    Fix Windows build problems using cygwin
#
#####
# VARIABLE DEFINITIONS for LIBBRARY VARIABLE RULES and EXCEPTIONS

#
# LIB     - postfix for all Libraries
#
# SH      - prefix for all Shared Libraries 
#           i.e.  case SH*LIB* is allowed
#
# PT_     - prefix for PatchTools Libraries
#           i.e.  case PT_*LIB is allowed
#
#
#####
# RULES DESCRIPTIONS
#
# IIINCLUDE part [ facility [ subsys ] ] -- read Jamfile
# IISUBSYS part facility subsys -- set source directories
#
# IIBINEXE program : file.c ; -- an exe for $INGBIN
# IIICEBINEXE program : file.c ; -- an exe for $INGICE/bin
# IISIGEXE program  dir : file.c ; -- an exe for $INGSIG/dir
# IIUTILEXE program : file.c ; -- an exe for $INGUTIL
# IINEEDLIBS program : libnames ; -- set link libraries for exe
# IITOOLSNEEDLIBS program : libnames ; -- set link libraries for tools exe's
# IILINKLIBS program : libnames ; -- non-dependent link libraries
# IIUNDEFS program : symnames ; -- set undefined symbols for exe
# IISETUID program ; -- program will be setuid
# IIUdtShLib SHDEMOUDTLIB : files ; -- create UDT shared library
# IIUdtArLib ARDEMOUDTLIB : files ; -- create UDT Archive library - it is  
#                                      needed on axp_osf platform.
# IIEsqlHdr hdr : hdr ; -- Move EQSQL hdrs to $INGFILES
#
# IILIBRARY library : sources ; -- a library for $INGLIB
# IISHLIBRARY shared library ; -- Create a shared library using mkshlibs
# IISvrArLibrary archive library ; -- Create archive library using mksvrarlib
# IISHLIBFROMARCHIVE shared library : library ; a shared library from an archive
# IIXERCLIB xerces-c.so ; Copy xerces library from XERCESLOC to $ING_BUILD/lib
#			  and create links.
#
# IINOOPTIM source-files : platforms ; -- unset OPTIM when compiling
# IICCFLAGS source-files : symbols ; -- reset CCFLAGS for the named sources
# IILINKFLAGS source-files : symbols ; -- reset CCFLAGS for the named sources
#
# IIExeShell program : file$(SUFSH) ; -- a portable executable script
# IIExeSedShell program : file$(SUFSH) ; -- an executable script prep'd by sed
# IISedShell program : file$(SUFSH) ; -- a script prep'd by sed
# IIRemRCComments program : file$(SUFSH) ; -- Remove comments from script
# IIBINSH program : file$(SUFSH) ; -- a shell-script for $INGBIN
# IIUTILSH program : file$(SUFSH) ; -- a shell-script for $INGUTIL
# IIBinPy program : file$(SUFPY) ; -- a python script if $INGBIN
# IIUtilPy program : file$(SUFPY) ; -- a python script if $INGUTIL
# IIFILESSH program : file.sh ; -- a shell-script for $INGFILES
# IILibSh program : file$(SUFSH) ; -- a shell-script for $INGLIB
# IILDFLAGS programs : symbols ; -- Add specified LD flags for the named progs
#
# IITOOLSEXE program : file.c ; -- an exe for $INGTOOLSBIN
# IITOOLSSH program : file$(SUFSH) ; -- a shell-script for $INGTOOLSBIN
# IITOOLSLIB library : sources ;  -- a library for $INGTOOLSLIB
# IITLIBFILES file ; -- bulk files for $INGTOOLSLIB
# IITMANFILES file ; -- bulk files for $INGTOOLSMAN
# IITFILES file ; -- bulk files for $INGTOOLSFILES
# IITFILE target file : source file ;-- files for $INGTOOLSFILES
# IITBIN files ; -- bulk files for $INGTOOLSWNTBIN 
# IITOOLSWNTEXE program : file.c ;-- an exe for $IITOOLSWNTBIN 
# IIFiRoc adgfi_defn.roc : fi_defn.awk fi_defn.txt ;
# IIFiRocLu adgfi_defn_lu.roc : fi_defn.awk fi_defn.txt ;
# IIFiH adgfi_defn.h : fi_defn.awk fi_defn.txt ;
# IIAduPatHdr adupatexec_ops.h : adupatexec.awk adupatexec.dotty ;
# IIAduPatBdy adupatexec_inc.i : adupatexec.awk adupatexec.dotty ;
# IIAWK target | awk_file source ;
#
# IIUTILBAT files ; -- bulk files (bat and others) for $INGUTIL
# IIBINBAT files ; -- bulk files (bat and others) for $INGBIN
# IITOOLSBAT files ; -- bulk files (bat and others) for $INGTOOLSBIN
# IISIGSTARBAT files ; -- bulk files (bat and others) for $INGSIGSTAR
# IILIBFILES files ; -- bulk files for $INGLIB
# IIBULKBAT directory : files ; -- wrapper for Bulk for windows. 
#                               -- Removes history comments from batch files.
#
# IIQSHHDR header : file.qsh ; -- .qsh -> .h rule
# IISHHDR header : file.sh ; -- .sh -> .h rule
# IIQHHDR header : file.qh ; -- .qh -> .h rule
# IIDUFSHHDR header : file.sh ; -- .sh -> .h rule specifically for duf!hdr
# 
# IIVERSREL VERSREL ; Generates version.rel under ING_BUILD
#
# PatchTools Rules
#
# IIPtoolsBinSh     ; Rule to proccess shell scripts
# IIPtoolsLib       ; Rule to proccess C source for libraries
# IIPtoolsBin       ; Rule to proccess C source for exe's
#
#
####
# Compilation rules
# CCQSC c-file : file.qsc ; -- qsc -> .c rule
# CCSC c-file : file.sc ; -- sc -> .c rule
# CCQC c-file : file.qc ; -- qc -> .c rule
# CCST c-file : .st ; -- create a .c from a .st using CCEQMRG
# CCSY c-file : .sy ; -- create .c from a .st using CCSY2YF and CCIYACC
# CCEQMRG source-file ; -- create a .c file with eqmerge
# CCIYACC source-file ; -- create a .c file with iyacc
# CCBYACC source-file ; -- create a .c file with byacc
# CCLFM	 c-file : form ; -- create a .c from a "form"
# CCROC	 Object : .roc ; -- create a .o from a .c (uses CCROFIX)
# CCROFIX c-file : .roc ; -- create a .c from a read only c file
#
# IIOBJECTS c-file ; -- wrapper for Objects rule.
####
#
# IIFORM file.frm ; -- formindex rule
#
# IIAIFHDR file.h ; file.ccpp ; Pre-process headers is common!aif!hdr
# IIMSGHDR file.msg ; -- .msg -> .h rule
# IIMNX mnx-file : message-file ; -- .msg -> {f<class>,s<class>}.mnx rules 
# IIMNX_v0 mnx-file : message-file ; -- .msg -> {f<class>,s<class>}_v0.mnx
# IIMNX_v1 mnx-file : message-file ; -- .msg -> {f<class>,s<class>}_v1.mnx
# IIMNX_v2 mnx-file : message-file ; -- .msg -> {f<class>,s<class>}_v2.mnx
# IIMNX_v3 mnx-file : message-file ; -- .msg -> {f<class>,s<class>}_v3.mnx
# IIFSMNX mnx-file : message-file ; -- .msg -> {fast,slow}_v<n>.mnx rules RMV
# IIFECAT fe.cat.msg ; -- cat all front end messages into archive.
#
# IICPEXE target-loc/target-file : source-file ; Copy source file to target
# 					loc/file and set EXEMODE on target.
# IIFILE target-file : source-file ; -- file for $INGFILES
# IIFILES file ; -- bulk files for $INGFILES
# IIBFILES dir : file-list ; Bulk copy files to dir under $ING_BUILD 
# IIDFILES dir : file-list ; Bulk copy files to dir under $INGFILES
# IIWiFiles dir : file-list ; Bulk copy files to dir under $INGWININST
# IIWiFile dir file : generic-file ; Copy and rename file to dir under $INGWININST
# IIICEFILE dir/target : source ; Copy source to dir/target under $(INGICE)
# IISIGFILE dir/target : file ; Copy file to dir/target under $(INGSIG)
# IISIGFILES dir : file-list ; Bulk copy files to directory under $(INGSIG)
# IINAMEFILES file ; -- bulk files for $INGFILES/name RMV
# IIDICTFILES file ; -- bulk files for $INGFILES/dictfiles RMV
# IICHARFILES file ; -- bulk files for $INGFILES/charsets RMV
# IICHARSET chsfile ; -- bulk files for $INGFILES/charsets/<dir>/desc.chx
# IIHELPFILES -- bulk help files for $INGMSG
# IILangFile lang target : source-file ; Copy individual laguage files.
#
# IIUDTPPFILE preprocess-file ; -- yypp/yapp-file for $UDTDEMO
# IIUDTFILES file ; -- files for $UDTDEMO
# IIUDTOBJECT source-file ; .o's for $UDTDEMO
# IIUDTSHELL shell-script : shell-source ; -- shell-scripts for $UDTDEMO
# IIUDTBAT files ; -- bulk files (bat and others) for $UDTDEMO
# IIUDTIIADD iiadd.h ; -- build iiadd.h for $INGFILES
# UDTOBJECT object-module : source-file ; -- UDT-specific Object rule
# UDTHDRRULE on source-file = UDTHDRRULE ; -- UDT-specific HDRRULE rule
#
# IICOLDATA collation-file : .dsc file ; -- collation data file for $INGCOL
# IICOLFILES .dsc file ; -- build collation file for $INGCOL
#
# IIABFCFG config.done ; -- configure ABF
#
# IIABFOBJS abfmodule ; -- special ABF object module for $ING_BUILD/lib
# IIABFLINK linkname : filename ; -- links to special ABF library modules
# IIABFDEMO file ; -- copy ABF demo files to $ING_BUILD/files/abfdemo
#
# IIOSLHDR header : yypp-file ; -- special handling for oslhdr.h
# IIEQDEF pp-file ; -- build $ING_BUILD/files/eqdef.h, eqdefc.h
# IIEQDEFCC eqdefcc.pp ; -- build $ING_BUILD/files/eqdefcc.h
#
# IIUTLD def-file : yypp-file ; -- make $INGFILES/utld.def
# IIDEF yypp-file ; -- create a .def file with yypp/yapp
#
# IICRS crs-file ; -- process a .crs file with ccpp
#
# IIPRT ccpp-file ; -- create a .prt file with ccpp
# IIRELDAT release.dat : release.ccpp ; -- create the release.dat file
# IIINSTALLDAT install.dat : release.dat ; -- create the install.dat link
# IIINSTALLHLP source-file ; -- copy installer help file to $INGMANIFEST
# IILIBPRT lib.prt : lib.yypp ; -- create the lib.prt file
# IIUCHARMAP mapfile : .xml ; -- create characterset map files.
# IIUCHARALIAS maptable : .xml ; Builds characterset lookup table files
# IIUCHARFILES file ; -- bulk files for $INGFILES/ucharmaps
#
# IIINGBLDLINK ingbuild ; -- create the $INGINSTALL/ingbuild link
#
#####
# "Boot-strap rules"
# IIBZARCH bzarch.h ; -- make bzarch.h
# IICLSECRET clsecret.h ; -- make clsecret.h
# IIGV gv.h ; -- make gv.h
# IIDEFAULT default.h ; -- make default.h
# IIGENERIC generic.h ; -- make generic.h
# IIIISYSDEP iisysdep ; -- make $ING_BUILD/utility/iisysdep
# IIINGDIRS MKIDIRDONE ; -- make $ING_BUILD directories
# IIMKVERS VERS ; -- generate VERS file in tools!port!conf if missing
#####
#
# IITIMEZONE tz-file ; -- build the timezone file
#
# IIMSGDOC messages.doc ; -- build the messages.doc file
# IIMSGTXT messages.txt : file.msg ; -- build the messages.txt file
#
# IIUSERADT iiuseradt.c ; -- build $ING_BUILD/lib/iiuseradt.o
# IICLSADT iiclsadt.c ; -- build $ING_BUILD/lib/iiclsadt.o
# 
# IIPWD ingvalidpw.x ; -- create $INGFILES/iipwd/ingvalidpw.c
#
# IIUUENCODELIB lib.$(LIBSFX) : file.enc ; -- uudecode a uuencoded library
#
# IISIGCACHE file ; -- files destined for sig/cachelock RMV
# IISIGSTAREXE target : source-file ; -- executable for $INGSIGSTAR
# IISIGSTARSH target : source-file ; -- shell-script for $INGSIGSTAR
# IISIGSTARFILE source-file ; -- file for $INGSIGSTAR RMV
#
# IILIBINGRES target ; -- make libingres.a
# IIMERGELIB library : libraries ; -- a generic IILIBINGRES rule
#
# IILIBEXE target : source-file ; -- make iimerge.o
# IILINKS target : dep ; -- make links to iimerge
#
# IICCPPFILE target : input-file ; -- Create target using ccpp
# IIHDRCCPP .h : .ccpp ; -- Create hdr file using ccpp
# IIMAKEFILE target ; -- Create target using make
#####
#
# IICHECKKEYPAIR keypair.snk ; -- Check if keypair.snk exists for Windows
#
# IIFASTI config.dat ; -- Fast installation
#
# ShellNT exe : source ; -- replacement of Shell for NT
#
# IIRCTORES rcfile ; -- Generates .RES file from .RC file
# IIREMDIRS dirs ; -- Removes all the directories recursively
# IIUDTFILE target : source ; -- Copy source file to $(UDTDEMO)/target file
#
#####

# Macro dependencies for build.
DEPENDS all : boot hdrs shlibs forms ice ;
DEPENDS first : hdrs boot ;
DEPENDS hdrs : boot ;
DEPENDS ice : files ;
NOTFILE boot msghdrs hdrs shlibs forms ice ;
#DEPENDS postbuild : boot hdrs shlibs exe files ;

# ING_SRC is where all the code resides if it's not set, bail.

if ! $(ING_SRC)
{
	ECHO "!!!!!ERROR!!!!!!!" ;
	ECHO "\$ING_SRC not defined" ;
	ECHO "Please source env/bldenv.sh under the $ING_ROOT" ;
	EXIT ;
}

# ING_BUILD=II_SYSTEM/ingres
# II_SYSTEM is where the built item go. If it's not set, bail.

if ! $(VMS) && ! $(II_SYSTEM)
{
    ECHO "!!!!!ERROR!!!!!!!" ;
    ECHO "Environment variable II_SYSTEM not defined" ;
    ECHO "Please source <startup script> under the <directory>" ;
    EXIT ;
}

if $(NT) && ! $(MT)
{
    ECHO "!!!!!!!WARNING!!!!!" ;
    ECHO "MT environment variable must be set to point to mt.exe!!" ;
    ECHO "mt.exe is a Microsoft Manifest Tool available in VS 2008 SDK!!" ;
    ECHO "This is absolutely required for all savesets!!!" ;
    EXIT ;
}


if ! $(VMS)
{
# ING_JAM is the location of all things jam
    ING_JAM = $(ING_SRC)/tools/port/jam/ ;
    ING_VERSDIR = $(ING_SRC)/tools/port/conf/ ;
}
else
{
    ING_SRC = ING_SRC: ;
    ING_BUILD = ING_BUILD: ;
    ING_ROOT = ING_ROOT: ;
    ING_TOOLS = ING_TOOLS: ;
    ING_JAM = ING_SRC:[tools.port.jam] ;
    ING_VERSDIR = ING_SRC:[tools.port.conf] ;
    PTOOLSROOT = PTOOLSROOT: ;
    PTOOLSBIN = PTOOLSROOT:[bin] ;
    XERCESCROOT = XERCESCROOT: ;
    KRB5HDR = KRB$ROOT:[INCLUDE] ;
}

# Include the other definitions used in rules and actions
include $(ING_JAM)Jamdefs ;

# Make sure build.timestamp gets removed by 'jam clean' if it exists

if ! ($VMS)
{
Clean clean : $(ING_BUILD)$(DFS)build.timestamp ;
}
else
{
# On VMS The above Clean doesn't work.
Clean clean : ING_BUILD:[000000]build.timestamp ;
}
#
# Rules - Only rules should be in this section. Actions should go in the
#	  following ("Actions") section.
#

if $(UNIX)
{
#
# This rule is an override for the Jambase rule Object 
# This rule needed to be overridden to modify the header file specification
# for the common/adf/admin directory to eliminiate the inclusion of the
# $(SEARCH_SOURCE) directory. It adds a $(HDROVERRIDE) variable so that
# the current source directory is not added to the list of include
# directories, so that the exact include path can be specified.
#
rule Object
{
	# locate object and search for source, if wanted

	Clean clean : $(<) ;

	MakeLocate $(<) : $(LOCATE_TARGET) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	# Save HDRS for -I$(HDRS) on compile.
	# We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
	# in the .c file's directory, but generated .c files (from
	# yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
	# different from $(SEARCH_SOURCE).

	if $(HDROVERRIDE)
	{
	    HDRS on $(<) = $(HDROVERRIDE) ;
	}
	else
	{
	    HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;
	}

	# handle #includes for source: Jam scans for headers with
	# the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
	# with the scanned file as the target and the found headers
	# as the sources.  HDRSEARCH is the value of SEARCH used for
	# the found header files.  Finally, if jam must deal with 
	# header files of the same name in different directories,
	# they can be distinguished with HDRGRIST.

	# $(SEARCH_SOURCE:E) is where cc first looks for #include 
	# "foo.h" files.  If the source file is in a distant directory, 
	# look there.  Else, look in "" (the current directory).


	HDRRULE on $(>) = HdrRule ;
	HDRSCAN on $(>) = $(HDRPATTERN) ;
	HDRSEARCH on $(>) = 
		$(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;

	HDRGRIST on $(>) = $(HDRGRIST) ;

	# propagate target specific-defines

	DEFINES on $(<) += $(DEFINES) ;

	# if source is not .c, generate .c with specific rule

	switch $(>:S)
	{
	    case .asm : As $(<) : $(>) ;
	    case .c :	Cc $(<) : $(>) ;
	    case .C :	C++ $(<) : $(>) ;
	    case .cc :	C++ $(<) : $(>) ;
	    case .cpp : C++ $(<) : $(>) ;
	    case .f :	Fortran $(<) : $(>) ;
	    case .l :	Cc $(<) : $(<:S=.c) ;
			Lex $(<:S=.c) : $(>) ;
	    case .s :	As $(<) : $(>) ;
	    case .y :	Cc $(<) : $(<:S=$(YACCGEN)) ;
			Yacc $(<:S=$(YACCGEN)) : $(>) ;
	    case * :	UserObject $(<) : $(>) ;
	}
}
}
#
# This first set of rules are just wrappers for the rules in Jambase.
# The only additional work is setting the location of the target and
# the extra dereference of symbolic library names.  
#

# Bulk wrappers
rule IIDLL		
{ 
    IICOPY $(INGBIN)/$(<) 	: $(<) ; 
    SEARCH on $(<) = $(SEARCH_SOURCE) $(INGLIB) ;
#    DEPENDS hdr : $(INGBIN)/$(<) ;
}
rule IICOLFILES
{
    if $(NT)
    {
        IIBULKCOPY $(INGCOL) : $(<) ;
	Clean clean : $(INGCOL)$(DFS)$(<) ;
    }
    else
    {
        BULK $(INGCOL) 		: $(<) ;
        Clean clean : $(INGCOL)/$(<) ;
    }
   if $(VERSHB)
   {
        BULK $(INGCOL)$(DFS)$(SUFHB)		: $(<) ;
        Depends $(<) : $(INGCOL)$(DFS)$(SUFHB) ;
        MkDir $(INGCOL)$(DFS)$(SUFHB) ;
        Clean clean : $(INGCOL)$(DFS)$(SUFHB)$(DFS)$(<) ;
   }
}

rule IIRFILES
{
	if $(NT)
	{
		IIBULKCOPY $(II_SYSTEM) : $(<) ;
	}
	else
	{
		Bulk $(II_SYSTEM) : $(<) ;
	}
	Clean clean : $(ING_BUILD)$(DFS)$(<) ;
}

rule IIBFILES		
{ 
    if $(NT)
    {
        IIBULKCOPY $(ING_BUILD)$(SLASH)$(<) : $(>) ;
    }
    else
    {    
	local _dir = [ FDirName $(ING_BUILD) $(<) ] ;
    	Bulk $(_dir) : $(>) ;
    	Clean clean : $(_dir)$(DFS)$(>) ;
    }
}

rule IIWiFiles
{
	for i in $(>)
	{
		local _s = [ FGristFiles $(i) ] ;
		local _file = [ FDirName $(INGWININST) $(<) $(i:BS) ] ;

		_IICOPYFILE $(_file) : $(_s) ;
		Depends hdrs : $(_file) ;
		Depends $(_file) : $(_s) ;
		SEARCH on $(_s) = $(SEARCH_SOURCE) ;
		
		Clean clean : $(_file) ;
	}		


}

rule IIWiFile
{
	for i in $(>)
	{
		local _s = [ FGristFiles $(i) ] ;
		local _file = [ FDirName $(INGWININST) $(<) ] ;

		_IICOPYFILE $(_file) : $(_s) ;
		Depends hdrs : $(_file) ;
		Depends $(_file) : $(_s) ;
		SEARCH on $(_s) = $(SEARCH_SOURCE) ;
		
		Clean clean : $(_file) ;
	}		

}

rule IIDFILES
{
    local _s = [ FGristFiles $(>) ] ;
    Dir = [ FDirName $(INGFILES) $(<) ] ;

    if $(NT)
    {
        IIBULKCOPY $(Dir) : $(_s) ;
    }
    else
    {
        Bulk $(Dir) : $(_s) ;
    }

    Depends $(_s) : $(Dir:G=dir) ;
    MkDir $(Dir:G=dir) ;

    Clean clean : $(Dir)$(DFS)$(>) ;
}
rule IIDLL		
{ 
    IICOPY $(INGBIN)/$(<) 	: $(<) ; 
#    DEPENDS hdr : $(INGBIN)/$(<) ;
}

rule FILE
{
	File $(<) : $(>) ;
	MkDir $(<:D) ;
	Depends $(<) : $(<:D) ;
	Clean clean : $(<) ;
}

rule IIFILE		
{
    FILE $(INGFILES)$(DFS)$(<) : $(>) ;
    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    
    Clean clean : $(INGFILES)$(DFS)$(<:D=) ;
}
rule IIFILES
{
    if $(NT)
    {
	local _g = [ FGristFiles $(<) ] ;
        IIBULKCOPY $(INGFILES) : $(_g) ;
	MkDir $(INGTOOLSFILES) ;
    }
    else
    {
        BULK $(INGFILES) 		: $(<) ;
        Clean clean : $(INGFILES)(DFS)$(<) ;
    }
}
rule IIHELPFILES	
{ 
    if $(NT)
    {
        IIBULKCOPY $(INGMSG) : $(<) ;
    }
    else
    {
    	BULK $(INGMSG) 		: $(<) ;
    	Clean clean : $(INGMSG)/$(<) ;
    }
}

rule IIICEFILE		
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = $(INGICE)$(DFS)$(<) ;

    DEPENDS files : $(_t) ;
    SEARCH on $(_s) = $(SEARCH_SOURCE) ;

    switch $(_s)
    {
	case *.html : 	_i = $(_s)_ ;
		      	_ICEHTML $(_i) : $(_s) ;
    		      	FILE $(_t) : $(_i) ;

		      	DEPENDS $(_t) : $(_i) ;
		      	DEPENDS $(_i) : $(_s) ;
		      	LOCATE on $(_i) = $(SEARCH_SOURCE) ;
		      	SEARCH on $(_i) = $(SEARCH_SOURCE) ;
		
		      	RmTemps $(_t) : $(_i) ;


	case *.css : 	_i = $(_s)_ ;
		      	_ICEHTML $(_i) : $(_s) ;
    		      	FILE $(_t) : $(_i) ;

		      	DEPENDS $(_t) : $(_i) ;
		      	DEPENDS $(_i) : $(_s) ;
		      	LOCATE on $(_i) = $(SEARCH_SOURCE) ;
		      	SEARCH on $(_i) = $(SEARCH_SOURCE) ;
		
		      	RmTemps $(_t) : $(_i) ;

	case *.h :		FILE $(_t) : $(_s:G=) ;
			DEPENDS $(_t): $(_s:G=) ;
			SEARCH on $(_s:G=) = $(SEARCH_SOURCE) ;

  	case * 	: 	FILE $(_t) : $(_s) ;
		 
		 	DEPENDS $(_t) : $(_s) ;
			SEARCH on $(_s) = $(SEARCH_SOURCE) ;
    }

    Clean clean : $(_t) ;
}

rule IILangFile
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = [ FGristFiles $(<[2]) ] ;
    local _dir = [ FDirName $(INGFILES) $(<[1]) ] ;

    FILE $(_t) : $(_s) ;

    Depends $(_t) : $(_s) ;
    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
    LOCATE on $(_t) = $(_dir) ;

    Clean clean : $(_t) ;
}
   
rule IIEsqlHdr
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = $(<) ;

    EsqlHdr $(_t) : $(_s) ;

    Depends $(_t) : $(_s) ;
    Depends hdrs : $(_t) ;
    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
    LOCATE on $(_t) = $(INGFILES) ;

}
if $(BUILD_ICE)
{
rule IIICECAZIP
{
  if $(NT)
  {
	DEPENDS ice : $(INGICE)/$(<) ;
	DEPENDS $(INGICE)/$(<) : $(INGICEZIP) ;

	_INSTALLICE $(INGICEZIP) ;
	#_USETOOL $(<) : icepublic.bat ;
	
	switch $(<)
	{
		case *ColdFusion* :
					_CAZIP $(INGICE)/$(<) : $(INGICE)/$(<:D) ;
					_USETOOL $(<) : cazipxp.exe ;

		case *icetutor* :
					_CAZIP $(INGICE)/$(<) : $(INGICEZIP) ;
					_USETOOL $(<) : cazipxp.exe ;				
	}
	#_CAZIP $(INGICE)/$(<) ;
	#_USETOOL $(<) : cazipxp.exe ;
	Clean clean : $(INGICE)/$(<) ;	
  }
}
}

rule IICF
{
	DEPENDS files : $(INGICE)$(SLASH)$(<) ;
	DEPENDS files : $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs ;
        Depends files : $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs$(SLASH)CFML ;
        Depends files : $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs$(SLASH)IngresIce$(SLASH)Docs ;
        Depends files : $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs$(SLASH)IngresIce$(SLASH)Icons ;

	_CF $(INGICE)$(SLASH)$(<) ;
	_CF $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs ;
	_CF $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs$(SLASH)CFML ;
	_CF $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs$(SLASH)IngresIce$(SLASH)Docs ;
	_CF $(INGICE)$(SLASH)$(<)$(SLASH)TagDefs$(SLASH)IngresIce$(SLASH)Icons ;

}
rule IISIGFILE
{
    FILE $(ING_BUILD)/sig/$(<) : $(>) ;
    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    Clean clean : $(ING_BUILD)/sig/$(<) ;
}

rule IISIGFILES 	
{
    local _s = [ FGristFiles $(>) ]  ;
    local _dir = [ FDirName $(ING_BUILD) sig $(<) ] ;

    if $(NT)
    {
        IIBULKCOPY $(_dir) : $(_s) ;
    }
    else
    {
        MkDir $(_dir) ;
        Depends $(_s) : $(_dir) ;
        Bulk $(_dir) : $(_s) ;
    }

    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
    
    Clean clean : $(_s:D=$(_dir)) ;
}
rule IITLIBFILES	
{ 
    if $(NT)
    {
        IIBULKCOPY $(INGTOOLSLIB) : $(<) ;
    }
    else
    {
        BULK $(INGTOOLSLIB) 		: $(<) ; 
    	Clean clean : $(INGTOOLSLIB)/$(<) ;
    }
}
rule IITMANFILES	
{ 
    if $(NT)
    {
        IIBULKCOPY $(INGTOOLSMAN) : $(<) ;
    }
    else
    {
    	BULK $(INGTOOLSMAN) 		: $(<) ;
    	Clean clean : $(INGTOOLSMAN)/$(<) ;
    }
}
rule IITFILES   
{ 
    IIBULKCOPY $(INGTOOLSFILES) : $(<) ; 
    DEPENDS files : $(<) ;
}
rule IITFILE
{
    FILE $(INGTOOLSFILES)/$(<)       : $(>) ;
    SEARCH on $(<) = $(SEARCH_SOURCE) ;
}
rule IITBIN
{
    local p = [ FGristFiles $(<) ] ;
    IIBULKCOPY $(INGTOOLSWNTBIN) : $(p) ;
    DEPENDS files : $(p) ;
}

rule IIUDTFILES 	
{
    if $(NT)
    {
        local p = [ FGristFiles $(<) ] ;
        IIBULKCOPY $(UDTDEMO) : $(p) ;
    }
    else
    { 
        BULK $(UDTDEMO) 		: $(<) ; 
    }
}

rule IIUDTFILE
{
    FILE $(<) : $(>) ;
    LOCATE on $(<) = $(UDTDEMO) ;
    Clean clean : $(UDTDEMO)/$(<) ;
}

rule IIBULKBAT
{
    local i ;

    for i in $(>)
    {
	local t = $(SEARCH_SOURCE)/$(i:G=) ;
	local SUFFIX = $(i:S) ;
	switch $(SUFFIX:U)
	{
		case *.BAT : _IICOPYBAT $(i) : $(t) ;
		case *.SQL : _IICOPYSQL $(i) : $(t) ;
		case *	   : _IICOPYFILE $(i) : $(t) ;
	}
        DEPENDS $(i) : $(t) ;
        LOCATE on $(i) = $(<) ;
	SEARCH on $(t) = $(SEARCH_SOURCE) ;
	MkDir $(<) ;
	Depends $(i) : $(<) ;
    }
    DEPENDS boot : $(>) ;
    Clean clean : $(>) ;
}

rule IIBULKCOPY
{

    local i ;

    for i in $(>)
    {
	local SUFFIX = $(i:S) ;
	switch $(SUFFIX:U)
	{
		case *.BAT : _IICOPYBAT $(<)$(DFS)$(i:BS) : $(i) ;
		case *.SQL : _IICOPYSQL $(<)$(DFS)$(i:BS) : $(i) ;
		case *	   : _IICOPYFILE $(<)$(DFS)$(i:BS) : $(i) ;
	}
	DEPENDS $(<)$(DFS)$(i:BS) : $(i) ;
	DEPENDS $(<)$(DFS)$(i:BS) : $(<) ;
	MkDir $(<) ;
	DEPENDS files : $(<)$(DFS)$(i:BS) ;
	SEARCH on $(i) = $(SEARCH_SOURCE) ;
	Clean clean : $(<)$(DFS)$(i:BS) ;
    }
}


rule IITOOLSBAT
{
    if $(NT)
    {
      IIBULKBAT $(INGTOOLSBIN) : $(<) ;
      DEPENDS boot : $(<) ;
      MakeLocate $(<) : $(INGTOOLSBIN) ;
    }
}
rule IIBINBAT
{
    local p = [ FGristFiles $(<) ] ;
    IIBULKCOPY $(INGBIN) : $(p) ;
    DEPENDS files : $(p) ;
}
rule IIUTILBAT
{
    local p = [ FGristFiles $(<) ] ;
    IIBULKCOPY $(INGUTIL) : $(p) ;
    DEPENDS files : $(p) ;
}
rule IILIBFILES
{
    IIBULKCOPY $(INGLIB) : $(<) ;
}
rule IISIGSTARBAT
{
    local p = [ FGristFiles $(<) ] ;
    IIBULKCOPY $(INGSIGSTAR) : $(p) ;
    DEPENDS files : $(p) ;
}
rule IIUDTBAT
{
    local p = [ FGristFiles $(<) ] ;
    IIBULKCOPY $(UDTDEMO) : $(p) ;
    DEPENDS files : $(p) ;
}

# Shell wrappers
rule IIFILESSH
{
    if ! $(NT)
    {
        Shell $(<) : $(>) ;
    }
    else
    {
        ShellNT $(<) : $(>) ;
    }
    LOCATE on $(<) = $(INGFILES) ;
}
rule IISIGSTARSH
{
    if ! $(NT)
    {
        Shell $(<) : $(>) ;
    }
    else
    {
        ShellNT $(<) : $(>) ;
    }
    LOCATE on $(<) = $(INGSIGSTAR) ;
}
rule IIUDTSHELL
{
    if ! $(NT)
    {
        IIExeShell $(<) : $(>) ;
    }
    else
    {
        ShellNT $(<) : $(>) ;
    }
    LOCATE on $(<) = $(UDTDEMO) ;
}

rule DBMSEXE
{
    DEPENDS $(<) : $(>) ;
    DEPENDS exe : $(<) ;
    _USETOOL $(<) : iilink ingprenv ;
    PARMLPHB on $(<) = "-$(SUFRB)" ;
    _IILINK $(<) : $(>) ;
    LOCATE on $(<) = $(INGBIN) ;

    # Don't make lp32 servers, for now.  This ought to be
    # controlled more independently, not hardwired.

    if $(VERSHB) && $(BUILD_ARCH) != "64+32"
    {   

    DEPENDS $(SUFHB)/$(<) : $(SUFHB)/$(>) ;
    DEPENDS exe : $(SUFHB)/$(<) ;
    _USETOOL $(SUFHB)/$(<) : iilink ;
    PARMLPHB on $(SUFHB)/$(<) = "-$(SUFHB)" ;
    _IILINK $(SUFHB)/$(<) : $(SUFHB)/$(>) ;
    LOCATE on $(SUFHB)/$(<) = $(INGBIN) ;
    DEPENDS $(<) : $(INGBIN)/$(SUFHB) ;
    MkDir $(INGBIN)/$(SUFHB) ;

    }
}

# Main wrappers
rule IIBINEXE 		
{ 
	if $(VMS)
	{
            VMS_LOT $(<) : $(>) ;

	    _USETOOL $(<:S=.exe) : inglink$(SUFXSH) ;

	    Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
            Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                           $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
	}
            
	Main $(<) : $(>) ; 

	if $(NT) 
	{
   		local _o _g ;
		for _o in $(>)	
		{
			_g = [ FGristFiles $(_o:S=$(SUFOBJ)) ] ;
			switch $(_g:G)
			{
				case *front*abf*impexp*	   	: CMPORTS = $(PORTIMP) ;
				case *front*embed*cobol*        : CMPORTS = $(PORTIMP) ;
				case *testtool*sep*listexec* 	: CMPORTS = $(PORTIMP) ;
				case *testtool*sep*sep*		: CMPORTS = $(PORTIMP) ;
				case *common*aif*demo*          : CMPORTS = $(PORTIMP) ;
				case *common*aif*ait*		: CMPORTS = $(PORTIMP) ;
				case *common*gcf*gcd*		: CMPORTS = $(PORTIMP) ;
				case *common*gcf*gcc*		: CMPORTS = $(PORTIMP) ;
				case *back*ascf*ascd*		: CMPORTS = $(PORTREF) ;
			        case *front*misc*impxml*	: CMPORTS = $(PORTIMP) ;
				case *dbutil*duf*		: CMPORTS = $(PORTIMP) ;
				case *front*dict*dictutil*	: CMPORTS = $(PORTIMP) ;
				case *front*st*ipm*		: CMPORTS = $(PORTIMP) ;
				case *front*misc*		: CMPORTS = $(PORTIMP) ;
				case *front*tm*			: CMPORTS = $(PORTIMP) ;
				case *cl*clf*er*		: CMPORTS = $(PORTIMP) ;
				case *				: CMPORTS = "" ;
			}
			switch $(_o:S)
			{
			case *cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) $(WCHART) ;
			case * : CCFLAGS on $(_g) += $(CMPORTS) ;
			}
		}
	LOCATE on $(<:S=.$(EXESFX)) = $(INGBIN) ; 
	LOCATE on $(<:S=.map) = $(INGBIN) ; 
	LOCATE on $(<:S=.$(LIBSFX)) = $(INGBIN) ; 
	LOCATE on $(<:S=.exp) = $(INGBIN) ; 
	LOCATE on $(<:S=.pdb) = $(INGBIN) ; 
	LOCATE on $(<:S=.ilk) = $(INGBIN) ; 
	LOCATE on $(<:S=.$(EXESFX)).manifest = $(INGBIN) ; 
	Clean clean : $(<:S=.$(EXESFX)) $(<:S=.map) 
                      $(<:S=.$(LIBSFX)) $(<:S=.exp)
		      $(<:S=.pdb) $(<:S=.ilk) $(<:S=.$(EXESFX)).manifest ;

	if $(VERSHB)
	{
    	  	MainHB $(<) : $(>) ;
		local _o _g ;
		for _o in $(>)	
		{
			_g = [ FGristFiles $(SUFHB)$(DFS)$(_o:S=$(SUFOBJ)) ] ;
			switch $(_g)
			{
				case *front*abf*impexp*	   	: CMPORTS = $(PORTIMP) ;
				case *front*embed*cobol*        : CMPORTS = $(PORTIMP) ;
				case *testtool*sep*listexec* 	: CMPORTS = $(PORTIMP) ;
				case *testtool*sep*sep*		: CMPORTS = $(PORTIMP) ;
				case *common*aif*demo*          : CMPORTS = $(PORTIMP) ;
				case *common*aif*ait*		: CMPORTS = $(PORTIMP) ;
				case *common*gcf*gcd*		: CMPORTS = $(PORTIMP) ;
				case *common*gcf*gcc*		: CMPORTS = $(PORTIMP) ;
				case *back*ascf*ascd*		: CMPORTS = $(PORTREF) ;
			        case *front*misc*impxml*	: CMPORTS = $(PORTIMP) ;
				case *dbutil*duf*		: CMPORTS = $(PORTIMP) ;
				case *front*dict*dictutil*	: CMPORTS = $(PORTIMP) ;
				case *front*st*ipm*		: CMPORTS = $(PORTIMP) ;
				case *front*misc*		: CMPORTS = $(PORTIMP) ;
				case *front*tm*			: CMPORTS = $(PORTIMP) ;
				case *cl*clf*er*		: CMPORTS = $(PORTIMP) ;
				case *				: CMPORTS = "" ;
			}
			switch $(_o:S)
			{
			case *cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) ;
			case * : CCFLAGS on $(_g) += $(CMPORTS) ;
			}
		}

	LINK on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINK32) ;
	LINKFLAGS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKFLAGS32) ;
	LIBP on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LIB32) $(SDK32) ;
	LINKLIBS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKLIBS32) ;

	LOCATE on $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) = $(INGBIN) ; 
	LOCATE on $(SUFHB)$(DFS)$(<:S=.map) = $(INGBIN) ; 
	LOCATE on $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) = $(INGBIN) ; 
	LOCATE on $(SUFHB)$(DFS)$(<:S=.exp) = $(INGBIN) ; 
	LOCATE on $(SUFHB)$(DFS)$(<:S=.pdb) = $(INGBIN) ; 
	LOCATE on $(SUFHB)$(DFS)$(<:S=.ilk) = $(INGBIN) ; 
	LOCATE on $(SUFHB)$(DFS)$(<:S=.$(EXESFX)).manifest = $(INGBIN) ; 
	Clean clean : $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) $(SUFHB)$(DFS)$(<:S=.map) 
                      $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) $(SUFHB)$(DFS)$(<:S=.exp)
		      $(SUFHB)$(DFS)$(<:S=.pdb) $(SUFHB)$(DFS)$(<:S=.ilk) 
		      $(SUFHB)$(DFS)$(<:S=.$(EXESFX)).manifest ;

	}
	}
	else	
	{
          if $(<) = icesvr && $(VERS64) = r64_us5
          {
           LINKFLAGS on $(<) = $(CCLDMACH) $(LD_ICE_FLAGS) ; 
          }
	  LOCATE on $(<:S=$(SUFEXE)) = $(INGBIN) ; 
          for _p in $(>)
          {
             local _s = [ FGristFiles $(_p) ] ;
             OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
          }
          IICCFLAGS $(>:S=$(SUFOBJ)) : CCPICFLAG ;
          switch $(>:S)
          {
            case .cpp :
	    LINK on $(<) = $(C++) ;
            if $(VERS) = usl_us5
            {
                LINKFLAGS on $(<) = $(C++LDMACH) ;
            }
          }
	}

       if $(VERSHB) && ! $(NT)
       {
    	  MainHB $(<) : $(>) ;
          if $(<) = icesvr && $(VERS64) = r64_us5
          {
          LINKFLAGS on $(SUFHB)$(DFS)$(<) = $(CCLDMACHHB) $(LD_ICE_FLAGS) ;
          }
    	  LOCATE on $(SUFHB)$(DFS)$(<) = $(INGBIN) ;
          for _p in $(>)
          {
              local _s = [ FGristFiles $(SUFHB)$(DFS)$(_p) ] ;
              OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
          }
    	  IICCFLAGS $(SUFHB)$(DFS)$(>:S=$(SUFOBJ)) : CCPICFLAG ;
    	  Depends $(SUFHB)$(DFS)$(<) : $(INGBIN)$(DFS)$(SUFHB) ;
    	  MkDir $(INGBIN)$(DFS)$(SUFHB) ;

    	  switch $(>:S)
    	  {
    		case .cpp :
		LINK on $(SUFHB)$(DFS)$(<) = $(C++) ;
     	  }
	}
}

rule MainHB
{
    MainFromObjects $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(>:S=$(SUFOBJ)) ;
    ObjectsHB $(SUFHB)$(DFS)$(>) ;
    LINKFLAGS on $(SUFHB)$(DFS)$(<:$(SUFOBJ)) += $(CCLDMACHHB) $(LDLIBMACHHB) ;
}

rule IIICEBINEXE
{ 
	MAIN $(<) : $(>) ;
	if $(NT)
	{
	LOCATE on $(<:S=.$(EXESFX)) = $(INGICE)$(DFS)bin ; 
	SEARCH on $(<:S=.$(EXESFX)) = $(INGICE)$(DFS)bin ;
	}
	else
	{
	LOCATE on $(<) = $(INGICE)$(DFS)bin ; 
	}
        for _p in $(>)
        {
           local _s = [ FGristFiles $(_p) ] ;
           OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
        }
	IICCFLAGS $(>:S=$(SUFOBJ)) : CCPICFLAG ;

	if $(VERSHB) && ! $(NT)
	{
    	MainHB $(<) : $(>) ;
    	LOCATE on $(SUFHB)$(DFS)$(<) = $(INGICE)$(DFS)bin ;
        for _p in $(>)
        {
           local _s = [ FGristFiles $(SUFHB)$(DFS)$(_p) ] ;
           OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
        }
    	IICCFLAGS $(SUFHB)$(DFS)$(>:S=$(SUFOBJ)) : CCPICFLAG ;
    	Depends $(<) : $(INGICE)$(DFS)bin$(DFS)$(SUFHB) ;
    	MkDir $(INGICE)$(DFS)bin$(DFS)$(SUFHB) ;

	if $(NT) 
	{
	LINK on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINK32) ;
	LINKFLAGS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKFLAGS32) ;
	LINKLIBS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKLIBS32) ;
	LIBP on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LIB32) $(SDK32) ;
	}
	}
}

rule IISIGEXE	 	
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = [ FAppendSuffix $(<[1]) : $(SUFEXE) ] ;

    if $(VMS)
    {
        VMS_LOT $(<) : $(>) ;

	_USETOOL $(<:S=.exe) : inglink$(SUFXSH) ;

        Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
        Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                       $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
    }

    Main $(<[1]) : $(>) ;

    Depends shell : $(_t) ;
    Depends $(_t) : $(_s) ;
    MakeLocate $(_t) : [ FDirName $(INGSIG) $(<[2]) ] ;
    Clean clean : $(_t) ;

    LOCATE on $(<[1]:S=$(SUFEXE)) = [ FDirName $(INGSIG) $(<[2]) ] ;
    for _p in $(>)
    {
        local _s = [ FGristFiles $(_p) ] ;
        OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
    }
    IICCFLAGS $(>:S=$(SUFOBJ)) : CCPICFLAG ;

}
rule IISIGSH	 	
{
    if ! $(NT)
    {
        IIExeShell $(<[1]) : $(>) ;
    }
    else
    {
        ShellNT $(<[1]) : $(>) ;
    }
    LOCATE on $(<[1]:S=$(SUFXSH)) = [ FDirName $(INGSIG) $(<[2]) ] ;
}

rule IICkpScript
{
    IIExeShell $(<) : $(>) ;
    LOCATE on $(<:S=$(SUFXSH)) = [ FDirName $(INGFILES) checkpoint ] ;
}

rule VMS_NO_LOT
{
   # Create a Global variable indicating that the .EXE file doesn't use
   # a .LOT file. 
   local tgt ;

   for tgt in $(<:B)
   {
      USE_LOT_$(tgt) = 0 ;
   }
}

rule VMS_LOT
{
   local _src ;

   for _src in $(<)
   {
      if $(USE_LOT_$(_src:B):E=1) = 1
      { 
         Depends $(_src:S=.exe) : $(_src:S=.lot) ;
         SEARCH on $(<:S=.lot) = $(SEARCH_SOURCE) ;
      }
   }
}

rule IITOOLSEXE 	
{ 
	if $(VMS)
	{
            VMS_LOT $(<) : $(>) ;

            _USETOOL $(<:S=.exe) : inglink$(SUFXSH) ;

	    Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
            Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                           $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
	}


	for _o in $(>)	
	{
		_g = [ FGristFiles $(_o:S=$(SUFOBJ)) ] ;
		switch $(_g:G)
		{
			case *testtool*sep*listexec* 	: CMPORTS = $(PORTIMP) ;
			case *testtool*sep*sep*		: CMPORTS = $(PORTIMP) ;
			case *testtool*sep*sepcl*	: CMPORTS = $(PORTIMP) ;
			case *				: CMPORTS = $(PORTIMP) ;
					
		}
		switch $(_o:S)
		{
		case *.cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) $(WCHART) ;
		case * : CCFLAGS on $(_g) += $(CMPORTS) ;
		}
		OPTIM on $(_g) ?= $(IIOPTIM) ;
	}

    LINKFLAGS on $(<) = $(CCLDMACH) $(IIOPTIM) ;
    MAIN $(<) : $(>) ; 
    if ! $(NT) 
    { 
	LOCATE on $(<:S=$(SUFEXE)) = $(INGTOOLSBIN) ; 
    }  
    else
    {
	LOCATE on $(<:S=.$(EXESFX)) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.map) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.$(LIBSFX)) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.exp) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.pdb) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.ilk) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.$(EXESFX)).manifest = $(INGTOOLSWNTBIN) ; 
	Clean clean : $(<:S=.$(EXESFX)) $(<:S=.map) 
                      $(<:S=.$(LIBSFX)) $(<:S=.exp)
		      $(<:S=.pdb) $(<:S=.ilk) $(<:S=.$(EXESFX)).manifest ;
    }

   if $(VERSHB)
   {
     MainHB $(<:S=$(SUFEXE)) : $(>) ;
     LOCATE on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(INGTOOLSBIN) ;
     Depends $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) : $(INGTOOLSBIN)$(DFS)$(SUFHB) ;
     MkDir $(INGTOOLSBIN)$(DFS)$(SUFHB) ;

     if $(NT)
     {
	LINK on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINK32) ;
	LINKFLAGS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKFLAGS32) ;
	LIBP on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LIB32) $(SDK32) ;
	LINKLIBS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKLIBS32) ;
     }
   }

}

rule IIUTILEXE 		
{ 
	if $(VMS)
	{
            VMS_LOT $(<) : $(>) ;

	    _USETOOL $(<:S=.exe) : inglink$(SUFXSH) ;

	    Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
            Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                           $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
	}
	Main $(<) : $(>) ; 
	if $(NT)
	{
	local _o _g ;	

	switch $(<)
	{
		case aducompile*	: DEPENDS $(<) : $(SHULFLIB) $(SHULFLIBDATA) 
							$(SHSCFLIB) $(SHSCFLIBDATA) 
							$(SHDMFLIB) $(SHDMFLIBDATA) 
							$(SHPSFLIB) ;
		case compform*		: DEPENDS $(<) : $(SHDMFLIB) $(SHDMFLIBDATA) 
							$(SHPSFLIB) ;
	}	

	for _o in $(>)	
	{
		_g = [ FGristFiles $(_o:S=$(SUFOBJ)) ] ;
		switch $(_g:G)
		{
			case *common*adf*adl*	   : CMPORTS = $(PORTIMP) ;
			case *			   : CMPORTS = $(PORTIMP) ;
	
		}
		switch $(_o:S)
		{
		case *.cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) $(WCHART) ;
		case * : CCFLAGS on $(_g) += $(CMPORTS) ;
		}
		
	}
	LOCATE on $(<:S=.$(EXESFX)) = $(INGUTIL) ; 
	LOCATE on $(<:S=.map) = $(INGUTIL) ; 
	LOCATE on $(<:S=.$(LIBSFX)) = $(INGUTIL) ; 
	LOCATE on $(<:S=.exp) = $(INGUTIL) ; 
	LOCATE on $(<:S=.pdb) = $(INGUTIL) ; 
	LOCATE on $(<:S=.ilk) = $(INGUTIL) ; 
	LOCATE on $(<:S=.$(EXESFX)).manifest = $(INGUTIL) ; 
	Clean clean : $(<:S=.$(EXESFX)) $(<:S=.map) 
                      $(<:S=.$(LIBSFX)) $(<:S=.exp)
		      $(<:S=.pdb) $(<:S=.ilk) $(<:S=.$(EXESFX)).manifest ;


	if $(VERSHB)
	{
		local _o _g ;	
		MainHB $(<) : $(>) ;
		switch $(<)
		{
		case aducompile*	: DEPENDS $(SUFHB)$(DFS)$(<) : $(SHULFLIBHB) $(SHULFLIBDATAHB) 
							$(SHSCFLIBHB) $(SHSCFLIBDATAHB) 
							$(SHDMFLIBHB) $(SHDMFLIBDATAHB) 
							$(SHPSFLIBHB) ;
		case compform*		: DEPENDS $(SUFHB)$(DFS)$(<) : $(SHDMFLIBHB) $(SHDMFLIBDATAHB) 
							$(SHPSFLIBHB) ;
		}	

		for _o in $(>)	
		{
			_g = [ FGristFiles $(SUFHB)$(DFS)$(_o:S=$(SUFOBJ)) ] ;
			switch $(_g)
			{
			case *common*adf*adl*	   : CMPORTS = $(PORTIMP) ;
			case UNI*		   : C++ on $(SUFHB)$(DFS)$(_g:S=$(SUFOBJ)) = $(CC32) ;
			case *			   : CMPORTS = $(PORTIMP) ;
	
			}
			switch $(_o:S)
			{
			case *.cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) ;
				     C++ on $(_g) = $(CC32) ;
			case * : CCFLAGS on $(_g) += $(CMPORTS) ;
			}
		
		}
		DEPENDS $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) : $(INGUTIL)$(DFS)$(SUFHB) ;
		MkDir $(INGUTIL)$(DFS)$(SUFHB) ;
		LINK on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINK32) ;
		LINKFLAGS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKFLAGS32) ;
		LIBP on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LIB32) $(SDK32) ;
		LINKLIBS on $(SUFHB)$(DFS)$(<:S=$(SUFEXE)) = $(LINKLIBS32) ; 

		LOCATE on $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) = $(INGUTIL) ; 
		LOCATE on $(SUFHB)$(DFS)$(<:S=.map) = $(INGUTIL) ; 
		LOCATE on $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) = $(INGUTIL) ; 
		LOCATE on $(SUFHB)$(DFS)$(<:S=.exp) = $(INGUTIL) ; 
		LOCATE on $(SUFHB)$(DFS)$(<:S=.pdb) = $(INGUTIL) ; 
		LOCATE on $(SUFHB)$(DFS)$(<:S=.ilk) = $(INGUTIL) ; 
		LOCATE on $(SUFHB)$(DFS)$(<:S=.$(EXESFX)).manifest = $(INGUTIL) ; 
		Clean clean : $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) $(SUFHB)$(DFS)$(<:S=.map) 
                      $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) $(SUFHB)$(DFS)$(<:S=.exp)
		      $(SUFHB)$(DFS)$(<:S=.pdb) $(SUFHB)$(DFS)$(<:S=.ilk) 
		      $(SUFHB)$(DFS)$(<:S=.$(EXESFX)).manifest ;


	}

	}
	else
	{
	  LOCATE on $(<:S=$(SUFEXE)) = $(INGUTIL) ; 
          for _p in $(>)
          {
             local _s = [ FGristFiles $(_p) ] ;
             OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
          }
          IICCFLAGS $(>:S=$(SUFOBJ)) : CCPICFLAG ;

          switch $(>:S)
          {
             case .cpp :
	       LINK on $(<) = $(C++) ;
               if $(VERS) = usl_us5
               {
                   LINKFLAGS on $(<) = $(C++LDMACH) ;
               }
          }
	}

	if $(VERSHB) && ! $(NT)
	{
    	  MainHB $(<) : $(>) ;
    	  LOCATE on $(SUFHB)$(DFS)$(<) = $(INGUTIL) ;
          for _p in $(>)
          {
              local _s = [ FGristFiles $(SUFHB)$(DFS)$(_p) ] ;
              OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
          }
    	  IICCFLAGS $(SUFHB)$(DFS)$(>:S=$(SUFOBJ)) : CCPICFLAG ;
    	  Depends $(<) : $(INGUTIL)$(DFS)$(SUFHB) ;
    	  MkDir $(INGUTIL)$(DFS)$(SUFHB) ;

    	  switch $(>:S)
    	  {
    	    case .cpp :
		LINK on $(SUFHB)$(DFS)$(<) = $(C++) ;
    	  }
	}
}

rule IITOOLSWNTEXE 		
{ 
	MAIN $(<) : $(>) ; 
	local _o _g ;
	for _o in $(>)	
	{
		_g = [ FGristFiles $(_o:S=$(SUFOBJ)) ] ;
		switch $(_g:G)
		{
			case *testtool*sep*listexec* 	: CMPORTS = $(PORTIMP) ;
			case *testtool*sep*sep*		: CMPORTS = $(PORTIMP) ;
			case *testtool*sep*sepcl*	: CMPORTS = $(PORTIMP) ;
		}
		switch $(_o:S)
		{
		case *cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) $(WCHART) ;
		case * : CCFLAGS on $(_g) += $(CMPORTS) ;
		}
	}
	LOCATE on $(<:S=.$(EXESFX)) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.map) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.$(LIBSFX)) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.exp) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.ilk) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.pdb) = $(INGTOOLSWNTBIN) ; 
	LOCATE on $(<:S=.$(EXESFX)).manifest = $(INGTOOLSWNTBIN) ; 
	Clean clean : $(<:S=.$(EXESFX)) $(<:S=.map) 
                      $(<:S=.$(LIBSFX)) $(<:S=.exp) 
		      $(<:S=.pdb) $(<:S=.ilk) 
		      $(<:S=.$(EXESFX)).manifest ;
}

rule IIAWK
{
        local t = [ FGristFiles $(<) ] ;
        local s = [ FGristFiles $(>) ] ;

        _IIAWK $(t) : $(s) ;
        DEPENDS $(t) : $(s) ;
        DEPENDS hdrs : $(t) ;

        LOCATE on $(t) = $(SEARCH_SOURCE) ;
        SEARCH on $(s) = $(SEARCH_SOURCE) ;
        DEPENDS $(<) : $(>) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

        Clean clean : $(t) ; 
        if $(VERSHB)
        {
            DEPENDS <$(SOURCE_GRIST)!$(SUFHB)>$(<) : $(s) ;
            LOCATE on <$(SOURCE_GRIST)!$(SUFHB)>$(<) = $(SEARCH_SOURCE) ;
            SEARCH on <$(SOURCE_GRIST)!$(SUFHB)>$(<) = $(SEARCH_SOURCE) ;
        }
}


rule IIFiRoc
{
	local t = [ FGristFiles $(<) ] ;
	local s = [ FGristFiles $(>) ] ;

	FiRoc $(t) : $(s) ;
	DEPENDS $(t) : $(s) ;
	DEPENDS hdrs : $(t) ;
        DEPENDS $(<) : $(>) ;

	LOCATE on $(t) = $(SEARCH_SOURCE) ;
	SEARCH on $(s) = $(SEARCH_SOURCE) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(t) ;
	if $(VERSHB)
	{
	    DEPENDS <$(SOURCE_GRIST)!$(SUFHB)>$(<) : $(s) ;
	    LOCATE on <$(SOURCE_GRIST)!$(SUFHB)>$(<) = $(SEARCH_SOURCE) ;
	    SEARCH on <$(SOURCE_GRIST)!$(SUFHB)>$(<) = $(SEARCH_SOURCE) ;
	}
}

rule IIFiRocLu
{
	local t = [ FGristFiles $(<) ] ;
	local s = [ FGristFiles $(>) ] ;

	FiRocLu $(t) : $(s) ;
	DEPENDS $(t) : $(s) ;
	DEPENDS hdrs : $(t) ;
        DEPENDS $(<) : $(>) ;

	LOCATE on $(t) = $(SEARCH_SOURCE) ;
	SEARCH on $(s) = $(SEARCH_SOURCE) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(t) ;
	if $(VERSHB)
	{
	    DEPENDS <$(SOURCE_GRIST)!$(SUFHB)>$(<) : $(s) ;
	    LOCATE on <$(SOURCE_GRIST)!$(SUFHB)>$(<) = $(SEARCH_SOURCE) ;
	    SEARCH on <$(SOURCE_GRIST)!$(SUFHB)>$(<) = $(SEARCH_SOURCE) ;
	}
}

rule IIFiH
{
	local t = [ FGristFiles $(<) ] ;
	local s = [ FGristFiles $(>) ] ;

	FiH $(t) : $(s) ;
	DEPENDS $(t) : $(s) ;
	DEPENDS hdrs : $(t) ;
        DEPENDS $(<) : $(>) ;

	LOCATE on $(t) = $(SEARCH_SOURCE) ;
	SEARCH on $(s) = $(SEARCH_SOURCE) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(t) ;
}

rule IIAduPatHdr
{
	local t = [ FGristFiles $(<) ] ;
	local s = [ FGristFiles $(>) ] ;
	AduPatHdr $(t) : $(s) ;
	DEPENDS $(t) : $(s) ;
	DEPENDS hdrs : $(t) ;
        DEPENDS $(<) : $(>) ;
	LOCATE on $(t) = $(SEARCH_SOURCE) ;
	SEARCH on $(s) = $(SEARCH_SOURCE) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	Clean clean : $(t) ;
}

rule IIAduPatBdy
{
	local t = [ FGristFiles $(<) ] ;
	local s = [ FGristFiles $(>) ] ;
	AduPatBdy $(t) : $(s) ;
	DEPENDS $(t) : $(s) ;
	DEPENDS hdrs : $(t) ;
        DEPENDS $(<) : $(>) ;
	LOCATE on $(t) = $(SEARCH_SOURCE) ;
	SEARCH on $(s) = $(SEARCH_SOURCE) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	Clean clean : $(t) ;
}


#
# Patchtools rules
#

rule IIPToolsLib
{
    #--- Over-ride default location
    #    Without this definition the libraries are
    #    searched for in the local directory and all
    #    files are rebuilt every time jam is run.

    LOCATE_TARGET = $(PTOOLSLIB) ;

    Library $(<) : $(>) ;

    if ! $(NT)
    {
       for _p in $(>)
       {
          local _s = [ FGristFiles $(_p) ] ;
          OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
       }
    }

    Clean clean : $(<) ;
}
 
rule IIPToolsBin 	
{ 
    local _t = $(<:S=$(SUFEXE)) ;

    if $(VMS)
    {
        VMS_LOT $(<) : $(>) ;

	_USETOOL $(_t) : inglink$(SUFXSH) ;

        Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
        Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                       $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
    }

    Main $(_t) : $(>) ;
    MakeLocate $(_t) : $(PTOOLSBIN) ;

    if ! $(NT)
    {
       for _p in $(>)
       {
          local _s = [ FGristFiles $(_p) ] ;
          OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
       }
    }
    Clean clean : $(<) ;
}

# Compilation wrappers

# Override default rule for "As" as Ingres assembler files need to be 
# pre processed first
rule As
{
	DEPENDS $(<) : $(>) ;
}
rule AsMigr
{
    Depends $(<) : $(>) ;
}
rule CC { Cc $(<) : $(>) ; }

# Misc wrappers

rule IILINKLIBS 	{ LINKLIBS on $(<) = $($(>)) $(LINKLIBS) ; }
rule IISETUID 		{ MODE on $(<:S=$(SUFEXE)) = 4755 ; }
rule IIUNDEFS 		
{ 
  if ! $(NT)
  {
    UNDEFINES $(<) : $(>) ; 
    if $(VERSHB)
    {
    	UNDEFINES $(SUFHB)/$(<) : $(>) ;
    }
  }
}

rule IIOBJECTS
{
    Objects $(<) ;

    if $(VERSHB)
    {
	ObjectsHB $(SUFHB)/$(<) ;
    }

    if ! $(NT)
    {
      IICCFLAGS $(<:S=$(SUFOBJ)) : OPTIM ;
      IICCFLAGS $(<:S=$(SUFOBJ)) : CCPICFLAG ;
    }
}

rule IIKRB5OBJECTS
{
     if $(NT)
     {
         for i in $(<)
         {
             local _t = $(i:S=$(SUFOBJ)) ;
             CCFLAGS on $(_t) += $(PORTREF) ;
             DEPENDS files : $(_t) ;
             LIBOBJECT $(_t) : $(i) ;
             LOCATE on $(_t) = $(INGLIB) ;
             Clean clean : $(_t) ;

	     if $(VERSHB)
	     {
		local _t = $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) ;
		CCFLAGS on $(_t) += $(PORTREF) ;
		DEPENDS files : $(_t) ;
		LIBOBJECT $(_t) : $(i) ;
		LOCATE on $(_t) = $(INGLIB) ;
		Clean clean : $(_t) ;
	     }
        }
    }
}

rule IIINCLUDE
{
	# Paths must be non-local now

	THITHER = true ;

    if $(VMS)
    {
	if $(<[6])
	{
	    ECHO "ERROR: IIINCLUDE rule cannot process Jamfile in:" ;
	    ECHO "" ;
	    ECHO "	$(<)" ;
	    ECHO "" ;
	    ECHO "Directory tree is too deep, rule in:" ;
	    ECHO "" ;
	    ECHO "	$(ING_JAM)/Jamrules" ;
	    ECHO "" ;
	    ECHO "must be modified" ;
	    EXIT ;
	}
	else if $(<[5])
	{
	    INFILE = [$(<[1]).$(<[2]).$(<[3]).$(<[4]).$(<[5])]$(JAMFILE) ;
	}
	else if $(<[4])
	{
	    INFILE = [$(<[1]).$(<[2]).$(<[3]).$(<[4])]$(JAMFILE) ;
	}
	else if $(<[3])
	{
	    INFILE = [$(<[1]).$(<[2]).$(<[3])]$(JAMFILE) ;
	}
	else if $(<[2])
	{
	    INFILE = [$(<[1]).$(<[2])]$(JAMFILE) ;
	}
	else
	{
	    INFILE = [$(<[1])]$(JAMFILE) ;
	}

   }
   else
   {
	if $(<[6])
	{
	    ECHO "ERROR: IIINCLUDE rule cannot process Jamfile in:" ;
	    ECHO "" ;
	    ECHO "	$(<)" ;
	    ECHO "" ;
	    ECHO "Directory tree is too deep, rule in:" ;
	    ECHO "" ;
	    ECHO "	$(ING_JAM)/Jamrules" ;
	    ECHO "" ;
	    ECHO "must be modified" ;
	    EXIT ;
	}
	else if $(<[5])
	{
	    INFILE = $(<[1])/$(<[2])/$(<[3])/$(<[4])/$(<[5])/$(JAMFILE) ;
	}
	else if $(<[4])
	{
	    INFILE = $(<[1])/$(<[2])/$(<[3])/$(<[4])/$(JAMFILE) ;
	}
	else if $(<[3])
	{
	    INFILE = $(<[1])/$(<[2])/$(<[3])/$(JAMFILE) ;
	}
	else if $(<[2])
	{
	    INFILE = $(<[1])/$(<[2])/$(JAMFILE) ;
	}
	else
	{
	    INFILE = $(<[1])/$(JAMFILE) ;
	}

   }
	SEARCH on $(INFILE) = $(ING_CODE) ;

	include $(INFILE) ;
}

rule IISUBSYS 
{
    if $(VMS)
    {
	HDR1 = $(ING_CODE)[$(<[1]).$(<[2]).hdr] ;	# facility header
	HDR2 = $(ING_CODE)[$(<[1]).hdr.hdr] ;		# part header
    }
    else
    {
	HDR1 = $(ING_CODE)/$(<[1])/$(<[2])/hdr ;    # facility header
	HDR2 = $(ING_CODE)/$(<[1])/hdr/hdr ;        # part header
    }

    HDR3 = ;                                    # misc headers
    HDRM = ;				    # grammar merge directory
    USEPIC = ;				# use PIC flag when compiling
    HDROVERRIDE = ;				# override for default hdrs
    
    #
    # Eliminate HDR1/HDR2 for one of three reasons:
    #	
    # 1) They duplicates HDRCL, HDRGL, or HDRCOMMON
    # 2) They don't exist and esqlc would complain
    # 3) They don't exist in the testing tree.
    #

    switch $(<[1])/$(<[2])
    {
	# Avoid doubling up HDRCOMMON, GL, CL

	case cl/*	: 	   HDR2 = ;
	case common/*	: 	   HDR2 = ; USEPIC = TRUE ;
	case gl/*	: 	   HDR2 = ; USEPIC = TRUE ;

	# esql won't stand for nonexistent directories

	case front/qbf  : HDR1 = ; 
	case front/dict : HDR1 = ; 
	case front/pt : HDR1 = ; 
	case front/vdba : HDR1 = ; 

	# These 8-balls don't follow the rules

	case testtool/achilles :   HDR2 = ;	# has HDR1
	case testtool/sep : 	   HDR2 = ;	# has HDR1

	case dbutil/*	: 	   HDR2 = ;	# has HDR1
	case sig/*	: HDR1 = ; HDR2 = ;
        case be/*	: HDR1 = ; HDR2 = ;
        case tst/*      : HDR1 = ; HDR2 = ;
        case testtool/* : HDR1 = ; HDR2 = ;
        case patchtools/tools : HDR1 = ; HDR2 = ;

	# Enterprise Access (aka gateway) has slightly different rules
	# These are for "thin" gateways like Oracle, etc.
	# These are NOT for "fat" gateways like RMS
	# EA_HDRCLFWGC, EA_TYPE_HDRS, EA_UDB_INCLUDE_HDR, etc. are
	# defined in the !gateway! specific Jamdefs files
        case gateway/* : HDR2 = $(ING_CODE)/$(<[1])/gwf/hdr ; switch $(<[1])/$(<[2])
	{
		case gateway/gwf : HDR1 = $(HDRGCF) $(EA_HDRCLFWGC) $(EA_TYPE_HDRS) $(HDR1) ;  ## HDRGCF only needed in gwf!gwu for gcnint.h, EA_TYPE_HDRS needed for gws and gwf
		case * : HDR1 = $($(EA_SERVER_TYPE:U)_INCLUDE_HDR) $(HDR1) ; ## i.e. EA_UDB_INCLUDE_HDR, EA_ORA_INCLUDE_HDR, etc.
	}
    }

    #
    # Set HDR3/HDRM for special cases (poorly layered code?)
    #
    # Specific subdirs first, then generic cases.
    #
    
    switch $(<[1])/$(<[2])
    {
	case back/gwf   : HDR3 = $(HDRDMF) ;
	case back/awsf   : HDR3 = $(HDRCOMMON) $(HDRAIF) $(HDRSCF) ;
	case back/ascf   : HDR3 = $(HDRCOMMON) $(HDRAIF) $(HDRSCF) ;
	case common/adf : HDR3 = $(HDRBACK) ;
	case common/aif : HDR3 = $(HDRBACK) ;
	case common/gcf : HDR3 = $(HDRAIF) ;
	case common/cuf : HDR3 = $(HDRAIF) ;
	case common/ddf : HDR3 = $(HDRAIF) ;
	case common/jdbc : HDR3 = $(HDRAIF) ;
	case common/odbc : HDR3 = $(HDRAIF) $(HDREMBED) ;
	case front/abf  : HDR3 = $(HDREMBED) ;
			  HDRM = $(HDRABFM) ;
	case front/embed : HDRM = $(HDREMBEDM) ;
	case dbutil/*   : HDR3 = $(HDRCOMMON) $(HDRBACK) $(HDRDMF) $(HDRAIF) ;
	case front/*    : HDR3 = $(HDRFRONTCLF) $(HDRAIF) ;
	case tst/stress   : HDR3 = $(HDRSTRESS) $(INGFILES) ;
	case sig/dp	: HDR3 = $(HDRAIF) $(HDRBACK) $(HDRDMF) ;
	case sig/*   	: HDR3 = $(HDRAIF) $(HDRFRONT) ;
	case testtool/* : HDR3 = $(HDRFRONT) $(HDRFRONTCL) $(HDRCLF) ;
	case x11-src/*  : HDR3 = $(HDRX11) $(HDRMOTIF) ;
	case w4gl/*     : HDR3 = $(HDRFRONT) $(HDRX11) $(HDRMOTIF) ;
    }

    HDRS = $(HDRMACH) $(HDR1) $(HDR2) $(HDR3) $(HDRCOMMON)
	$(HDRGL) $(HDRCL) $(HDRCLF) ;

	
    #
    # Now totally override HDRS in special cases.
    #

    switch $(<[1])/$(<[2])/$(<[3])
    {
	case common/odbc/winspecials_win :
			HDRS = $(HDRAIF) $(HDREMBED) $(HDRDRV) $(HDRCOMMON)
				  $(HDRCL) $(HDRCLF) $(HDR1) $(HDR2) $(HDRGL) ;
	case common/adf/admin :
			if $(UNIX)
			{
			    HDROVERRIDE = $(INGFILES) $(UDTDEMO) ; }
			else
			{
			    HDRS = $(INGFILES) $(UDTDEMO) ;
			}
	case common/adf/adl   :
			HDRS = $(HDRS) $(HDRICE) $(HDRFRONT) $(HDRSAX) ;
        case common/adf/adu  :
			HDRS = $(HDRS) $(HDRGEOS) $(HDRPROJ) ;
	case common/adf/ads   :
			if $(NT)
			{
			    HDRS = $(INGFILES) $(UDTDEMO) ;
			}
			else
			{
			    HDRS = $(INGFILES) ;
			}
	case vec31/src/*      :
			HDRS = $(VECINC) ;
	case tools/*/*	      :
			HDRS = $(HDRTOOLS) $(HDRCL) $(HDRCLF) $(HDRGL) $(HDRCOMMON) ;
        case patchtools/tools/exec :
			HDRS = $(HDRPTOOLSEXEC) $(HDRCL) $(HDRCLF) $(HDRGL)
				$(HDRFRONT) ;
	case front/embed/libqtxxa* :
			HDRS = $(HDR1) $(HDR2) $(HDR3) $(HDRCOMMON) $(HDRGL)
				$(HDRCL) $(HDRTUXEDO) . ; 
	case front/ice/apache :
			HDRS = $(HDRS) $(HDRAPACHE) ;
	case front/ice/plays :
			HDRS = $(HDRS) $(HDRPLAYSRC) ;
	case front/ice/ICETranslate :
			HDRS = $(HDRS) $(HDRICE) $(HDRFRONT) $(HDRSAX) ;
	case front/misc/impxml 	:
			HDRS = $(HDRS) $(HDRICE) $(HDRFRONT) $(HDRSAX) ;
	case front/st/rfapi*	:
			HDRS = $(HDRS) $(HDRST) ;
	case front/st/gtkinstall_unix_win :
			HDRS = $(HDRS) $(HDRST) $(HDRGTK) ;
	case front/st/gtkinstall_unix :
			HDRS = $(HDRS) $(HDRST) $(HDRGTK) $(HDRXML2) ;
        case front/st/ipm :
                        HDRS = $(HDRS) $(HDRDMF) ;
	case front/st/packman* :
			HDRS = $(HDRS) $(HDRST) $(HDRGTK) ;
	case front/st/tngapi*	:
			HDRS = $(HDRS) $(HDRGCF) $(HDRST) ;
	case front/st/odbcadmn* :
			HDRS = $(HDRS) $(HDRODBC) ;
        case front/frontcl/libqsys* :
                        HDRS = $(HDRS) $(HDREMBED) ;
    }

    # Kerberos headers break the rules

    if $(<[4]) = krb5
    {
	HDRS = $(HDRS) $(KRB5HDR) $(HDRGCS) ;
    }

    # One wildcat locate.

    if $(<[1])/$(<[2])/$(<[3]) = common/adf/admin
    {
	LOCATE_TARGET = $(UDTDEMO) ;
    }
	
}

rule IINEEDLIBS 	
{ 
 	local _g _libs ;

	if ! $(NT)
	{
	    if $(<:S) != $(SUFOBJ)
	    {
		LINKLIBS on $(<) = $(LINKLIBS) -L$(INGLIB) ; 
	    }
	    if $(VERSHB)
	    {
		LINKLIBS on $(SUFHB)/$(<) = $(LINKLIBS) -L$(INGLIB)/$(SUFHB) ; 
	    }
	}

	for l in $(>)
	{
 	    _g = [ FGristFiles $(l:S=$(SUFOBJ)) ] ;
	    if ! $(l) { ECHO $(l) "UNDEFINED" ; }
	

	    if $(NT)
	    {
		switch $(l)
		{  
			case DMFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case ULFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case SCFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case QEFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case GCFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case SXFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case GWFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case OPFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case QSFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case RDFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case TPFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case RQFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case PSFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
 			case APILIB :
 			     local SUFLIB = .$(LIBSFX) ;
 			     switch $(_g)
 			     {
 				case *common*aif*demo* : DEPENDS $(<:S=.$(EXESFX)) : $($(l)) ;
     			 			         LIBS $(<) : $($(l)) ;
 				case * : INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
			     		 LIBS $(<) : $(IMP$(l)) ;
 			     }
			case ICELIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
 			case ICEAPILIB :
			     local SUFLIB = .$(LIBSFX) ;
 			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
 			     LIBS $(<) : $(IMP$(l)) ;	
			case ADFLIB : 
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case ULFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			     LIBS $(<) : $(IMP$(l)DATA) ;
			case CUFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $(IMP$(l)) ;
			case COMPAT :
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(SH$(l)) ;
 			     LIBS $(<) : $(SH$(l)DATA) ;
			case COMPAT* :	     
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(<:S=.$(EXESFX)) : $(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $(SH$(l)) ;
 			     LIBS $(<) : $(SH$(l)DATA) ;

 			case C_APILIB : LIBS $(<) : $($(l)) ;

			case *APILIB :
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
			case *PSFLIB :
			     local SUFLIB  = .$(LIBSFX) ;
     			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
			case *CUFLIB :
			     local SUFLIB  = .$(LIBSFX) ;
     			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
			case *NEWORDERLIB :
			     local SUFLIB  = .$(LIBSFX) ;
     			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
			case SHXERCESLIB :
			     LIBS $(<) : $($(l)) ;
			case SH*LIB* : 
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l)DATA:S=.$(SLSFX)) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
			     LIBS $(<) : $($(l)DATA) ;
			     SEARCH on $($(l)) = $(INGBIN) ;
			     SEARCH on $($(l)DATA) = $(INGBIN) ;
			     SEARCH on $($(l):S=.$(LIBSFX)) = $(INGLIB) ;
			     SEARCH on $($(l)DATA:S=.$(LIBSFX)) = $(INGLIB) ;
			case IMP*DATA :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l)) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
			case IMPEXPLIB : 
			     LIBS $(<) : $($(l)) ;
			case IMPXMLLIB :
			     LIBS $(<) : $($(l)) ;
			case IMP* :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l)) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):B)data.$(SLSFX) ;
			     LIBS $(<) : $($(l)) ;
			case * :
			     LIBS $(<) : $($(l)) ;

 		}

		if $(VERSHB)
		{
			switch $(l)
			{  
			case DMFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case ULFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case SCFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case QEFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case GCFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case SXFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case GWFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case OPFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case QSFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case RDFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case TPFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case RQFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case PSFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
 			case APILIB :
 			     local SUFLIB = .$(LIBSFX) ;
 			     switch $(_g)
 			     {
 				case *common*aif*demo* : DEPENDS $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l)) ;
     			 			         LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
 				case * : INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
			     		 LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
 			     }
			case ICELIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
 			case ICEAPILIB :
			     local SUFLIB = .$(LIBSFX) ;
 			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
 			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;	
			case ADFLIB : 
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case ULFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)DATA) ;
			case CUFLIB :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMP$(l)) ;
			case COMPAT :
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(SH$(l)) ;
 			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(SH$(l)DATA) ;
			case COMPAT* :	     
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) ;
	  	             INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(SH$(l)) ;
 			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(SH$(l)DATA) ;

 			case C_APILIB : LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case NETAPILIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case *APILIB :
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case *PSFLIB :
			     local SUFLIB  = .$(LIBSFX) ;
     			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case *CUFLIB :
			     local SUFLIB  = .$(LIBSFX) ;
     			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case *NEWORDERLIB :
			     local SUFLIB  = .$(LIBSFX) ;
     			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case SHXERCESLIB :
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case SH*LIB* : 
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l)DATA:S=.$(SLSFX)) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)DATA) ;
			     SEARCH on $(SUFHB)$(DFS)$($(l)) = $(INGBIN) ;
			     SEARCH on $(SUFHB)$(DFS)$($(l)DATA) = $(INGBIN) ;
			     SEARCH on $(SUFHB)$(DFS)$($(l):S=.$(LIBSFX)) = $(INGLIB) ;
			     SEARCH on $(SUFHB)$(DFS)$($(l)DATA:S=.$(LIBSFX)) = $(INGLIB) ;
			case IMP*DATA :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l)) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case IMPEXPLIB : 
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case IMPXMLLIB :
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case IMP* :
			     local SUFLIB = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l)) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):B)data.$(SLSFX) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case *32* : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case MSILIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case ODBCLIB* : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case GDILIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case VERSIONLIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case NETAPILIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case RPCLIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case HTMLHELPLIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case CLUSAPI : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case MORELIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case SYS*LIB : LIBS $(SUFHB)$(DFS)$(<) : $($(l)) ;
			case *MMLIB : LIBS $(<) : $($(l)) ;
			case *LIB :
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case * :
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;

			SEARCH on $(SUFHB)$(DFS)$(SH$(l):S=.$(SLSFX)) = $(INGBIN) ;
			SEARCH on $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(SLSFX)) = $(INGBIN) ;
			SEARCH on $(SUFHB)$(DFS)$(SH$(l)) = $(INGLIB) ;
			SEARCH on $(SUFHB)$(DFS)$(SH$(l)DATA) = $(INGLIB) ;
			SEARCH on $(SUFHB)$(DFS)$(SH$(l):S=.$(LIBSFX)) = $(INGLIB) ;
			SEARCH on $(SUFHB)$(DFS)$(SH$(l)DATA:S=.$(LIBSFX)) = $(INGLIB) ;
		        SEARCH on $(SUFHB)$(DFS)$(l) = $(INGBIN) ;

 		}
		}

			SEARCH on $(SH$(l):S=.$(SLSFX)) = $(INGBIN) ;
			SEARCH on $(SH$(l)DATA:S=.$(SLSFX)) = $(INGBIN) ;
			SEARCH on $(SH$(l)) = $(INGLIB) ;
			SEARCH on  $(SH$(l)DATA) = $(INGLIB) ;
			SEARCH on $(SH$(l):S=.$(LIBSFX)) = $(INGLIB) ;
			SEARCH on $(SH$(l)DATA:S=.$(LIBSFX)) = $(INGLIB) ;
		        SEARCH on $(l) = $(INGBIN) ;
	    }	  
	    else
	    {
	       switch $(l)
	       {
		case SHEMBEDLIB :
	            LINKLIBS on $(<) += $($($(l))_LINKFLAG) ; 
		    Depends $(<:S=$(SUFEXE)) : $($($(l))) ;
		    if $(VERSHB)
		    {
                        if $(VERS64) = r64_us5
                          {
                            LINKLIBS on $(SUFHB)/$(<) += -L$(INGLIB) $($($(l))_LINKFLAG64) ;
                          }
                         else
                          {
                            LINKLIBS on $(SUFHB)/$(<) += $($($(l))_LINKFLAG) ;
                          }
		        Depends $(SUFHB)/$(<) : $($($(l))HB) ;
		    }
		    SEARCH on $($($(l))) = $(INGLIB) ;	 
		    if $(VERSHB) { SEARCH on $($($(l))HB) = $(INGLIB) ; }
		case SH*LIB : 
	            LINKLIBS on $(<) += $($(l)_LINKFLAG) ; 
		    Depends $(<:S=$(SUFEXE)) : $($(l)) ;
		    if $(VERSHB)
		    {
                        if $(VERS64) = r64_us5
                          {
                            LINKLIBS on $(SUFHB)/$(<) += -L$(INGLIB) $($(l)_LINKFLAG64) ;
                          }
                        else
                          {
                            LINKLIBS on $(SUFHB)/$(<) += $($(l)_LINKFLAG) ;
                          }
		        Depends $(SUFHB)/$(<) : $($(l)HB) ;
		    }
		    SEARCH on $($(l)) = $(INGLIB) ;	 
		    if $(VERSHB) { SEARCH on $($(l)HB) = $(INGLIB) ;	 }
		case ICELIB :
		    for j in $(ICELIB)
		    {
			LIBS $(<) : $(j) ;
		    }
		    if $(VERSHB)
		    {
		    for j in $(ICELIBHB)
		    {
			LIBS $(SUFHB)/$(<) : $(j) ; 
		    }
		    }
		    SEARCH on $($(l)) = $(INGLIB) ;	 
		    if $(VERSHB) { SEARCH on $($(l)HB) = $(INGLIB) ;	 }
		case GTKLIBS :
			# special case for linking to GTK
			LINKLIBS on $(<) += $(GTKCCLD) ;
		case * :
		    LinkLibraries $(<) : $($(l)) ; 
		    if $(VERSHB)
       		    {
		    LinkLibraries $(SUFHB)/$(<) : $($(l)HB) ; 
		    }
		    SEARCH on $($(l)) = $(INGLIB) ;	 
		    if $(VERSHB) { SEARCH on $($(l)HB) = $(INGLIB) ;	 }
	       }

	   }
	}

	if ! $(NT)
	{
		if $(<:S) != .o
		{
			LINKLIBS on $(<) += $(LDLIBMACH) ;
			#if this is not ingbuild, and WITH_GEO is defined AND
			#we're linking in either ADFLIB or INGRESLIB
			#we must also link to libgeos, libgeos_c and libproj			
			if ! ingbuild in $(<) && $(WITH_GEO) && ( ADFLIB in $(>) || LIBINGRES in $(>) || INGRESLIB in $(>) )
			{
				LINKLIBS on $(<) += -L$(GEOS_LOC) -L$(PROJ_LOC) -lgeos -lgeos_c -lproj ;
			}
			if $(VERSHB)
			{
				#same as above but for the hybrid versions
				LINKLIBS on $(SUFHB)/$(<) += $(LDLIBMACH) ;
				if ! ingbuild in $(<) && $(WITH_GEO) && ( ADFLIB in $(>) || LIBINGRES in $(>) || INGRESLIB in $(>) )
				{
					LINKLIBS on $(SUFHB)/$(<) += -L$(GEOSHB_LOC) -L$(PROJHB_LOC) -lgeos -lgeos_c -lproj ;
				}
			}
		}
	}


	for _l in $(>)
	{
	    switch $(_l)
	    {
	     case PT_*LIB :
		 SEARCH on $($(_l)) = $(PTOOLSLIB) ; 
	     case * :		
		 SEARCH on $($(_l)) = $(INGLIB) ; 
		 if $(VERSHB) { SEARCH on $($(>)HB) = $(INGLIB) ; }
	    }
	}
	
}

rule IICppNeedLibs
{
        local _g _libs ;
        if $(VERS) = usl_us5
        {
            if $(<:S) != $(SUFOBJ)
            {
                LINKLIBS on $(<) = $(LINKLIBS) -L$(INGLIB) ;
            }

            for l in $(>)
            {
                _g = [ FGristFiles $(l:S=$(SUFOBJ)) ] ;
                if ! $(l) { ECHO $(l) "UNDEFINED" ; }


                   switch $(l)
                   {
                    case SHEMBEDLIB :
                        LINKLIBS on $(<) += $($($(l))_LINKFLAG) ;
                        Depends $(<) : $($($(l))) ;
                        SEARCH on $($($(l))) = $(INGLIB) ;
                    case SH*LIB :
                        LINKLIBS on $(<) += $($(l)_LINKFLAG) ;
                        Depends $(<) : $($(l)) ;
                        SEARCH on $($(l)) = $(INGLIB) ;
                    case ICELIB :
                        for j in $(ICELIB)
                        {
                            LIBS $(<) : $(j) ;
                        }
                        SEARCH on $($(l)) = $(INGLIB) ;
                    case * :
                        LinkLibraries $(<) : $($(l)) ;
                        SEARCH on $($(l)) = $(INGLIB) ;
                   }
            }
            if $(<:S) != .o
                  {
                    LINKLIBS on $(<) += $(C++LDLIBMACH) ;
                  }
            SEARCH on $($(>)) = $(INGLIB) ;
        }
        else
        {
            IINEEDLIBS $(<) : $(>) ;
        }
}

rule IINEEDLIBSW
{

	if $(NT)
	{
	    for l in $(>)
	    {
 	    	_g = [ FGristFiles $(l:S=$(SUFOBJ)) ] ;
	    	if ! $(l) { ECHO $(l) "UNDEFINED" ; }
	
		switch $(l)
		{
			case SHCUFLIB* :
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
                             SEARCH on $($(l)) = $(INGBIN) ;
                             SEARCH on $($(l):S=.$(LIBSFX)) = $(INGLIB) ;
			case SH*LIB* : 
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l)DATA:S=.$(SLSFX)) ;
			     INCLUDES $(<:S=.$(EXESFX)) : $($(l):S=.$(SLSFX)) ;
			     LIBS $(<) : $($(l)) ;
			     LIBS $(<) : $($(l)DATA) ;
                             SEARCH on $($(l)) = $(INGBIN) ;
                             SEARCH on $($(l)DATA) = $(INGBIN) ;
                             SEARCH on $($(l):S=.$(LIBSFX)) = $(INGLIB) ;
                             SEARCH on $($(l)DATA:S=.$(LIBSFX)) = $(INGLIB) ;
			case * :
			     LIBS $(<) : $($(l)) ;
                             SEARCH on $($(l)) = $(INGLIB) ;

		} #switch $(l)


		if $(VERSHB)
		{
 	    		_g = [ FGristFiles $(SUFHB)$(DFS)$(l:S=$(SUFOBJ)) ] ;
	    		if ! $(l) { ECHO $(l) "UNDEFINED" ; }
	
			switch $(l)
			{
			case SHCUFLIB* :
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l)DATA:S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			case SH*LIB* : 
			     local SUFLIB  = .$(LIBSFX) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l)DATA:S=.$(SLSFX)) ;
			     INCLUDES $(SUFHB)$(DFS)$(<:S=.$(EXESFX)) : $(SUFHB)$(DFS)$($(l):S=.$(SLSFX)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)DATA) ;
			case * :
			     LIBS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$($(l)) ;

			} #switch $(l)
		} #if $(VERSHB)

	    }  #for l in $(>) 

	} #if $(NT)
}


rule IINEEDOBJ 
{
     if $(NT) || $(VMS)
     {

	local _t _m ;
	for _t in $(>)
	{
		switch $(<)
		{
			case *dll : _m = $(<:S=.$(SLSFX)) ;
			case * 	  : _m = $(<:S=.$(EXESFX)) ;
		}
		DEPENDS $(_m) : $(_t:S=$(SUFOBJ)) ;
		NEEDOBJ on $(_m) += $(_t:S=$(SUFOBJ):G=) ;
		SEARCH on $(_t:S=$(SUFOBJ):G=) = $(INGLIB) ;
		if $(VERSHB)
		{
		DEPENDS $(SUFHB)$(DFS)$(_m) : $(SUFHB)$(DFS)$(_t:S=$(SUFOBJ)) ;
		NEEDOBJ on $(SUFHB)$(DFS)$(_m) += $(SUFHB)$(DFS)$(_t:S=$(SUFOBJ):G=) ;
		SEARCH on $(SUFHB)$(DFS)$(_t:S=$(SUFOBJ):G=) = $(INGLIB) ;
		DEPENDS obj : $(SUFHB)$(DFS)$(_t:S=$(SUFOBJ)) ;
		
		CC on $(SUFHB)$(DFS)$(_t:S=$(SUFOBJ)) = $(CC32) ;
		CCFLAGS on $(SUFHB)$(DFS)$(_t:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		}
	}

     }
}

rule IINEEDRES
{
	if  $(NT)
	{
	local _t _m ;
	for _t in $(>) 
	{
		switch $(<)
		{
			case *dll : _m = $(<:S=.$(SLSFX)) ;
			case * 	  : _m = $(<:S=.$(EXESFX)) ;
		}
		DEPENDS $(_m) : $(_t:D=) ;
		NEEDRES on $(_m) = $(_t:D=) ;
		SEARCH on $(_t) = $(SEARCH_SOURCE) $(INGLIB) $(INGBIN) $(_t:D) ;				
		LINKFLAGS on $(_m) = $(DLLFLAGSNV) ;
	}
	}

}

rule IIAdminManifest
{
	if $(NT)
	{
		local _file ;
		
		switch $(<)
		{
			case *dll : _file = $(<:S=.$(SLSFX)) ;
			case * : _file = $(<:S=.$(EXESFX)) ;
		}
		#DEPENDS $(_file) : $(_file).manifest ;		
		LINKFLAGS on $(_file) = $(LINKFLAGS) $(ADMIN_MANIFEST) ;
		SEARCH on $(_file).manifest = $(INGBIN) $(INGUTIL) ;
	}
}

rule IITOOLSNEEDLIBS
{
    LIBS $(<) : $($(>)) ;
    SEARCH on $($(>)) = $(INGTOOLSLIB) ;
}

rule IIExeShell
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = [ FAppendSuffix $(<) : $(SUFXSH) ] ;

    if $(_t) != $(<)
    {
	Depends $(<) : $(_t) ;
	NotFile $(<) ;
    }
    if $(_t) = "clean"
    {
        _t = $(<:S=.sh) ;
	IICOPY $(PTOOLSBIN)$(DFS)$(<) : $(_t) ;
    }

    Depends shell : $(_t) ;
    Depends $(_t) : $(_s) ;
    MakeLocate $(_t) : $(LOCATE_TARGET) ;

    Clean clean : $(_t) ;

    Shell $(_t) : $(_s) ;
}

rule IIExeTPU
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = [ FAppendSuffix $(<) : .TPU ] ;

    if $(_t) != $(<)
    {
      Depends $(<) : $(_t) ;
      NotFile $(<) ;
    }            
 
    Depends shell : $(_t) ;
    Depends $(_t) : $(_s) ;
    MakeLocate $(_t) : $(LOCATE_TARGET) ;  

    Clean clean : $(_t) ;

    Shell $(_t) : $(_s) ;
}

rule IIShellVMS
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = [ FAppendSuffix $(<) : "." ] ;
        
    if $(_t) != $(<)
    {
        Depends $(<) : $(_t) ;
        NotFile $(<) ;
    }
    
    Depends shell : $(_t) ;
    Depends $(_t) : $(_s) ;
    MakeLocate $(_t) : $(PTOOLSBIN) ;
    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
 
    Clean clean : $(_t) ;

    IISedShellVMS $(_t) : $(_s) ;
}
 
rule IIExeSedShell
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = [ FAppendSuffix $(<) : $(SUFXSH) ] ;

    if $(_t) != $(<)
    {
	Depends $(<) : $(_t) ;
	NotFile $(<) ;
    }

    Depends shell : $(_t) ;
    Depends $(_t) : $(_s) ;
    MakeLocate $(_t) : $(LOCATE_TARGET) ;

    Clean clean : $(_t) ;

    IISedShell $(_t) : $(_s) ;
}


rule IISedShell
{
    Depends shell : $(<) ;
    Depends $(<) : $(>) ;
    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    MODE on $(<) = $(SHELLMODE) ;
    Clean clean : $(<) ;
    Chmod $(<) ;
}

rule IITOOLSDcl 		
{ 
    if $(VMS)
    {
        DEPENDS boot : $(<) ;
	IIExeShell $(<) : $(>) ; 
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	MakeLocate $(<:S=$(SUFXSH)) : $(INGTOOLSBIN) ;
    }
}

rule IIRemRCComments
{
    local _s = $(>) ;
    local _t = $(<) ;
    local _d = $(<:D) ;

    Depends shell : $(_t) ;
    Depends $(_t) : $(_s) ;
    Depends $(_t) : $(_d) ;

    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
    MODE on $(_t) ?= $(SHELLMODE) ;

    MkDir $(_d) ;
    Chmod $(_t) ;

    Clean clean : $(_t) ;
}

rule IITOOLSSH 		
{ 
    if ! $(NT)
    {
	DEPENDS boot : $(<) ;
	IIExeShell $(<) : $(>) ; 
        switch $(<)
        {
                case mkgv :
                    _USETOOL $(<) : readvers$(SUFXSH) genrelid$(SUFXSH) ccpp$(SUFXSH) ;
        }
    }
    else
    {
        ShellNT $(<) : $(>) ;
    }

	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	MakeLocate $(<:S=$(SUFXSH)) : $(INGTOOLSBIN) ;
}

rule IIBINSH 		
{ 
    if ! $(NT)
    {
	IIExeSedShell $(<) : $(>) ; 
    }
    else
    {
	if $(<) != accessdb && $(<) != catalogdb
	{
	LEAVES $(<) ;
	SEDSHW $(>:S=.sh_) : $(>) ;
        ShellNT $(<) : $(>:S=.sh_) ;
	}
	DEPENDS $(>:S=.sh_) : $(>) ;
    }

	SEARCH on $(>) = $(SEARCH_SOURCE) ;
    if $(UNIX)
    {
	LOCATE on $(<) = $(INGBIN) ;
    }
    else
    {
	LOCATE on $(<:S=$(SUFXSH)) = $(INGBIN) ;
    }
}

rule IISCHABINSH 		
{ 
    if ! $(NT) && ! $(VMS)
    {
	IIExeSedShell $(<) : $(>) ; 
    }

    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    MakeLocate $(<:S=$(SUFXSH)) : $(SCHABIN) ;
}

rule IISCHABINEXE
{
    if ! $(NT) && ! $(VMS)
    {
	Main $(<) : $(>) ; 
	MakeLocate $(<) : $(SCHABIN) ; 
    }
}

rule IIPtoolsBinTPU
{
    {
        IIExeTPU $(<) : $(>) ;
    }
    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    MakeLocate $(<) : $(PTOOLSBIN) ;
      
    Clean clean : $(<) ;
}


rule IIPtoolsBinSh
{    
    if $(NT)
    {
        ShellNT $(<) : $(>) ;
    }
    else
    {
       if ! $(VMS)
       {       
          IIExeShell $(<) : $(>) ;
       }
       else
       {
          IIShellVMS $(<) : $(>) ;
       }
   }

    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    MakeLocate $(<) : $(PTOOLSBIN) ;
}

rule IISCHAFILES
{
    if ! $(NT) && ! $(VMS)
    {
	Depends $(<) : $(SCHAETC:G=dir) ;
	MkDir $(SCHAETC:G=dir) ;
        BULK $(SCHAETC) 		: $(<) ;
        Clean clean : $(SCHAETC)(DFS)$(<) ;
    }
}

        
rule IIPtoolsBinDCL
{
    {
        IIExeShell $(<) : $(>) ;
    }
    
    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    MakeLocate $(<) : $(PTOOLSBIN) ;
}

rule IIUTILSH 		
{ 
    if ! $(NT)
    {
	IIExeSedShell $(<) : $(>) ; 
    }
    else
    {
	SEDSHW $(>:S=.sh_) : $(>) ;
        ShellNT $(<) : $(>:S=.sh_) ;
	DEPENDS $(>:S=.sh_) : $(>) ; 
    }


	SEARCH on $(>) = $(SEARCH_SOURCE) ;
    if $(UNIX)
    {
	MakeLocate $(<) : $(INGUTIL) ;
    }
    else
    {
	MakeLocate $(<:S=$(SUFXSH)) : $(INGUTIL) ;
    }
}

rule IIBinPy
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = $(<) ;

    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
    LOCATE on $(_t) = $(INGBIN) ;

    ExePy $(_t) : $(_s) ;
}

rule IIUtilPy
{
    local _s = [ FGristFiles $(>) ] ;
    local _t = $(<) ;

    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
    LOCATE on $(_t) = $(INGUTIL) ;

    ExePy $(_t) : $(_s) ;
}

rule ExePy
{
    Depends shell : $(<) ;
    Depends $(<) : $(>) ;

    MODE on $(<) = $(SHELLMODE) ;

    Chmod $(<) ;
    Clean clean : $(<) ;
}

rule  IILibSh
{
    if ! $(NT)
    {
	IIExeSedShell $(<) : $(>) ;
    }
    else
    {
	SEDSHW $(>:S=.sh_) : $(>) ;
	ShellNT $(<) : $(>:S=.sh_) ;
	Depends $(>:S=.sh_) : $(>) ;
    }

    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    MakeLocate $(<:S=$(SUFXSH)) : $(INGLIB) ;
}

rule IIHDRCCPP
{
	local _s = $(>:G=$(SOURCE_GRIST)) ;
	local _t = $(<:G=$(SOURCE_GRIST)) ;
	SEDCCPP $(_t) : $(_s) ;
	if $(VMS)
	{
	    Depends $(_t) : $(INGTOOLSLIB)sedccpp.sed ;
	}

	DEPENDS hdrs : $(_t) ;
	DEPENDS $(_t) : $(_s) ;
	SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	LOCATE on $(_t) = $(SEARCH_SOURCE) ;
}

rule IILIBRARY
{
	local _o ;
	if ! $($(<)) { ECHO $(<) "UNDEFINED" ; }
	if $(NT)
	{
		local _o _g ;
		for _o in $(>)	
		{
			_g = [ FGristFiles $(_o:S=$(SUFOBJ)) ] ;
			if $($(_g)) != TRUE
			{
			switch $(_g:G)
			{
			case *front*st*enterprise_dll_win*	: CMPORTS = $(PORTIMP) ;
			case *cl*clf*		   : CMPORTS = $(PORTREF) ;
			case *gl*glf*		   : CMPORTS = $(PORTREF) ;
			case *dbutil*duf*duc* 	   : CMPORTS = $(PORTIMP) ;

			case *common*aif*ait*	   : CMPORTS = $(PORTIMP) ;
 			case *common*aif*demo*     : CMPORTS = $(PORTIMP) ;
			case *common*odbc*driver*  : CMPORTS = $(PORTIMP) ;
			case *common*odbc*manager*  : CMPORTS = $(PORTIMP) ;
			case *common*gcf*gcn*gcnsreg*		: CMPORTS = $(PORTREF) ;
			case *common*gcf*gcn* 	   : CMPORTS = $(PORTIMP) ;
			case *common*gcf*gcd* 	   : CMPORTS = $(PORTIMP) ;
			case *common*gcf*gcc* 	   : CMPORTS = $(PORTIMP) ;
			case *common*ddf*	   : CMPORTS = $(PORTIMP) ;
			case *common*		   : CMPORTS = $(PORTREF) ;

			case *back*psf*yacc*	   : CMPORTS = $(PORTIMP) ;	
			case *back*		   : CMPORTS = $(PORTREF) ;
		
			case *front*embed*equel*   : CMPORTS = $(PORTREF) ;
			case *front*embed*libq*	   : CMPORTS = $(PORTREF) ;
			case *front*embed*ada*	   : CMPORTS = $(PORTIMP) ;
			case *front*embed*fortran* : CMPORTS = $(PORTIMP) ;
			case *front*abf*quel*	   : CMPORTS = $(PORTREF) ;
			case *front*abf*impexp*	   : CMPORTS = $(PORTIMP) ;
			case *front*abf*osl*	   : CMPORTS = $(PORTREF) ;
			case *front*embed*copy*	   : CMPORTS = $(PORTREF) ;
			case *front*embed*c*	   : CMPORTS = $(PORTIMP) ; 
			case *front*embed* 	   : CMPORTS = $(PORTREF) ; 
			case *front*frontcl*	   : CMPORTS = $(PORTREF) ;
			case *front*tm*qr*	   : CMPORTS = $(PORTREF) ;
			case *front*utils*	   : CMPORTS = $(PORTREF) ;
			case *front*frame*compfrm* : CMPORTS = $(PORTIMP) ;
			case *front*frame*	   : CMPORTS = $(PORTREF) ;
			case *gateway*  : CMPORTS = $(PORTIMP) ;
			case *			   : CMPORTS = $(PORTIMP) ;
				
			}
			}
			switch $(_o:S)
			{
			case *cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) $(WCHART) ;
			case * : CCFLAGS on $(_g) += $(CMPORTS) ;
			}
			CMPORTS = "" ;
		}


		switch $(<)
		{
				case IMP*DATA : 
						DEPENDS $($(<)) : $($(<)L) ;
						IMPLIBRARY $($(<)) : $(>) ;
						REGLIBRARY $($(<)L) : $(>) ; 
                		                Clean clean : $($(<)) $($(<)L) ;
						LOCATE on $($(<)L) = $(INGLIB) ;
						SEARCH on $($(<)L) = $(INGLIB) ;
						SEARCH on $($(<)) = $(INGLIB) ;
				
				case ODBC* : 
						LINKLIBS on $(<) = $(DLLFLAGSNV) ;
						LIBRARY $($(<)) : $(>) ;
						Clean clean : $($(<)) ;		

				case * : 
						LIBRARY $($(<)) : $(>) ;
                                    		Clean clean : $($(<)) ;
		}

	LOCATE on $($(<)) = $(INGLIB) ;
	MODE on $($(<)) = $(LIBMODE) ;
	Chmod $($(<)) ;


	if $(VERSHB) && $(<) != "COMMONMMLIB"
	{
		local _o _g ;
		

	    	if ! $($(<)HB) { ECHO $(<)HB "UNDEFINED" ; }

		switch $(<)
		{
				case IMP*DATA : 
						DEPENDS $(SUFHB)$(DFS)$($(<)) : $(SUFHB)$(DFS)$($(<)L) ;
						ImpLibraryHB $(SUFHB)$(DFS)$($(<)) : $(SUFHB)$(DFS)$(>) ;
						RegLibraryHB $(SUFHB)$(DFS)$($(<)L) : $(SUFHB)$(DFS)$(>) ; 
                		                Clean clean : $(SUFHB)$(DFS)$($(<)) $(SUFHB)$(DFS)$($(<)L) ;
						LOCATE on $(SUFHB)$(DFS)$($(<)L) = $(INGLIB) ;
						SEARCH on $(SUFHB)$(DFS)$($(<)L) = $(INGLIB) ;
						SEARCH on $(SUFHB)$(DFS)$($(<)) = $(INGLIB) ;
				
				case ODBC* : 
						LINKLIBS on $($(<)HB) = $(DLLFLAGSNV) ;
						LibraryHB $(<) : $(>) ;
						Clean clean : $(SUFHB)$(DFS)$($(<)) ;		

				case * : 
						LibraryHB $(<) : $(>) ;
                                    		Clean clean : $(<) ;
		}


		for _o in $(>)	
		{
			_g = [ FGristFiles $(SUFHB)$(DFS)$(_o:S=$(SUFOBJ)) ] ;
			if $($(_g)) != TRUE
			{
			switch $(_g)
			{
			case *front*st*enterprise_dll_win*	: CMPORTS = $(PORTIMP) ;
			case *cl*clf*		   : CMPORTS = $(PORTREF) ;
			case *gl*glf*		   : CMPORTS = $(PORTREF) ;
			case *dbutil*duf*duc* 	   : CMPORTS = $(PORTIMP) ;

			case *common*aif*ait*	   : CMPORTS = $(PORTIMP) ;
 			case *common*aif*demo*     : CMPORTS = $(PORTIMP) ;	
			case *common*odbc*driver*  : CMPORTS = $(PORTIMP) ;
			case *common*odbc*manager*  : CMPORTS = $(PORTIMP) ;
			case *common*gcf*gcn*gcnsreg*		: CMPORTS = $(PORTREF) ; 
			case *common*gcf*gcn* 	   : CMPORTS = $(PORTIMP) ; 
			case *common*gcf*gcd* 	   : CMPORTS = $(PORTIMP) ; 
			case *common*gcf*gcc* 	   : CMPORTS = $(PORTIMP) ; 
			case *common*ddf*	   : CMPORTS = $(PORTIMP) ; 
			case *common*		   : CMPORTS = $(PORTREF) ;

			case *back*psf*yacc*	   : CMPORTS = $(PORTIMP) ;		
			case *back*		   : CMPORTS = $(PORTREF) ;
		
			case *front*embed*equel*   : CMPORTS = $(PORTREF) ;
			case *front*embed*libq*	   : CMPORTS = $(PORTREF) ;
			case *front*embed*ada*	   : CMPORTS = $(PORTIMP) ;
			case *front*embed*fortran* : CMPORTS = $(PORTIMP) ;
			case *front*abf*quel*	   : CMPORTS = $(PORTREF) ;
			case *front*abf*impexp*	   : CMPORTS = $(PORTIMP) ;
			case *front*abf*osl*	   : CMPORTS = $(PORTREF) ;
			case *front*abf*abfrt*util* : CMPORTS = $(PORTIMP) ;
			case *front*abf*sql*sql*   : CMPORTS = $(PORTREF) ;
			case *front*embed*copy*	   : CMPORTS = $(PORTREF) ;
			case *front*embed*c*	   : CMPORTS = $(PORTIMP) ; 
			case *front*embed* 	   : CMPORTS = $(PORTREF) ; 
			case *front*frontcl*	   : CMPORTS = $(PORTREF) ;
			case *front*tm*qr*	   : CMPORTS = $(PORTREF) ;
			case *front*utils*	   : CMPORTS = $(PORTREF) ; 
			case *front*frame*compfrm* : CMPORTS = $(PORTIMP) ;
			case *front*frame*	   : CMPORTS = $(PORTREF) ;
			case *gateway*  : CMPORTS = $(PORTIMP) ;
			case *front*st*install*			: CMPORTS = $(PORTIMP) ;
								  HDRS on $(_g) += $(SEARCH_SOURCE) ;
			case *			   : CMPORTS = $(PORTIMP) ;
				
			}
			}
			switch $(_o:S)
			{
			case *cpp : C++FLAGS on $(_g) += $(CMPORTS) $(EHFLAG) ;
			case * : CCFLAGS on $(_g) += $(CMPORTS) ;

			}
			CMPORTS = "" ;
		}

	LOCATE on $($(<)HB) = $(INGLIB) ;
	SEARCH on $($(<)HB) = $(INGLIB) ;
	MODE on $($(<)HB) = $(LIBMODE) ;
	Chmod $($(<)) ;
	}
	
	}
	else
	{

		if ! $(NT) 
		{
			switch $(<)
			{
				case IMP*LIBDATA :
					_g = [ FGristFiles $(>[1]:S=$(SUFOBJ)) ] ;
					switch $(_g:G)
					{
						case *front*embed*equel* : LIBRARY $(EQUELLIB) : $(>) ;
						case *front*embed*libqgca* : LIBRARY $(LIBQGCALIB) : $(>) ;
						case *front*embed*libq* : LIBRARY $(LIBQLIB) : $(>) ;
						case *front*frame*copyform* : LIBRARY $(COPYFORMLIB) : $(>) ;
						case *front*frame*frame* : LIBRARY $(FDLIB) : $(>) ;
						case *front*frame*runtime* : LIBRARY $(RUNTIMELIB) : $(>) ;
						case *front*frame*tbacc* : LIBRARY $(RUNTIMELIB) : $(>) ;
						case *front*frame*valid* : LIBRARY $(FDLIB) : $(>) ;
						case *front*frontcl*termdr* : LIBRARY $(FTLIB) : $(>) ;
						case *front*frontcl*ft*	: LIBRARY $(FTLIB) : $(>) ;
						case *front*frontcl*gt*	: LIBRARY $(GTLIB) : $(>) ;
						case *front*frontcl*mt*	: LIBRARY $(MTLIB) : $(>) ;
						case *front*frontcl*vt* : LIBRARY $(VTLIB) : $(>) ;
						case *front*utils*afe*	: LIBRARY $(AFELIB) : $(>) ;
						case *front*utils*copyutil* : LIBRARY $(COPYUTILLIB) : $(>) ;
						case *front*utils*feds*	: LIBRARY $(FEDSLIB) : $(>) ;
						case *front*utils*fmt*	: LIBRARY $(FMTLIB) : $(>) ;
						case *front*utils*tblutil* : LIBRARY $(TBLUTILLIB) : $(>) ;
						case *front*utils*uf*	: LIBRARY $(UFLIB) : $(>) ;
						case *front*utils*ug*	: LIBRARY $(UGLIB) : $(>) ;
						case *front*utils*ui*	: LIBRARY $(UILIB) : $(>) ;
						case *front*utils*oo*	: LIBRARY $(OOLIB) : $(>) ;
						case *front*abf*iaom*	: LIBRARY $(IAOMLIB) : $(>) ;

						case *back*psf*		: LIBRARY $(PSFLIB) : $(>) ;
						case *back*ascf*	: LIBRARY $(ASCFLIB) : $(>) ;
						case *back*awsf*	: LIBRARY $(AWSFLIB) : $(>) ;

						case *common*gcf*gcc*	: LIBRARY $(GCCLIB) : $(>) ;
						case *common*gcf*gcd*	: LIBRARY $(GCDLIB) : $(>) ;
						case *			: LIBRARY $($(<)) : $(>) ;
					}

				case * : LIBRARY $($(<)) : $(>) ;
			}

		}
	}

	if ! $(NT)
	{
	    for _p in $(>)
	    {
		local _s = [ FGristFiles $(_p) ] ;
		OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;	
	    }
            IICCFLAGS $(>:S=$(SUFOBJ)) : CCPICFLAG ;
	}

	if ! $(NT)
	{
	if $(VERSHB) 
	{
#	    LibraryHB $(<) : $(>) ;
	    switch $(<)
	    {
		    case IMP*LIBDATA :
			    _g = [ FGristFiles $(>:S=$(SUFOBJ)) ] ;
			    switch $(_g:G)
			    {
				    case *front*embed*equel*	: LibraryHB EQUELLIB : $(>) ;
				    case *front*embed*libqgca*	: LibraryHB LIBQGCALIB : $(>) ;
				    case *front*embed*libq*	: LibraryHB LIBQLIB : $(>) ;
				    case *front*frame*copyform* : LibraryHB COPYFORMLIB : $(>) ;
				    case *front*frame*frame*	: LibraryHB FDLIB : $(>) ;
				    case *front*frame*runtime*	: LibraryHB RUNTIMELIB : $(>) ;
				    case *front*frame*tbacc*	: LibraryHB RUNTIMELIB : $(>) ;
				    case *front*frame*valid*	: LibraryHB FDLIB : $(>) ;
				    case *front*frontcl*termdr* : LibraryHB FTLIB : $(>) ;
				    case *front*frontcl*ft*	: LibraryHB FTLIB : $(>) ;
				    case *front*frontcl*gt*	: LibraryHB GTLIB : $(>) ;
				    case *front*frontcl*mt*	: LibraryHB MTLIB : $(>) ;
				    case *front*frontcl*vt*	: LibraryHB VTLIB : $(>) ;
				    case *front*utils*afe*	: LibraryHB AFELIB : $(>) ;
				    case *front*utils*copyutil* : LibraryHB COPYUTILLIB : $(>) ;
				    case *front*utils*feds*	: LibraryHB FEDSLIB : $(>) ;
				    case *front*utils*fmt*	: LibraryHB FMTLIB : $(>) ;
				    case *front*utils*tblutil*	: LibraryHB TBLUTILLIB : $(>) ;
				    case *front*utils*uf*	: LibraryHB UFLIB : $(>) ;
				    case *front*utils*ug*	: LibraryHB UGLIB : $(>) ;
				    case *front*utils*ui*	: LibraryHB UILIB : $(>) ;
				    case *front*utils*oo*	: LibraryHB OOLIB : $(>) ;
				    case *front*abf*iaom*	: LibraryHB IAOMLIB : $(>) ;

	                            case *back*psf*		: LibraryHB PSFLIB : $(>) ;
				    case *back*ascf*		: LibraryHB ASCFLIB : $(>) ;
				    case *back*awsf*		: LibraryHB AWSFLIB : $(>) ;

				    case *common*gcf*gcc*	: LibraryHB GCCLIB : $(>) ;
				    case *common*gcf*gcd*	: LibraryHB GCDLIB : $(>) ;
				    case *			: LibraryHB $(<) : $(>) ;
			    }

		    case * : LibraryHB $(<) : $(>) ;
	    }
	    if ! $($(<)HB) { ECHO $(<)HB "UNDEFINED" ; }

	    for _p in $(>)
	    {
		local _s = [ FGristFiles $(SUFHB)/$(_p) ] ;
		OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;	
	    }
		IICCFLAGS $(SUFHB)/$(>:S=$(SUFOBJ)) : CCPICFLAG ;
	}
	}

}

rule LibraryHB
{
	if $(NT)
	{
		LibraryFromObjects $($(<)HB) : $(SUFHB)$(DFS)$(>:S=$(SUFOBJ)) ;
		if $(VERS32) = int_w32
		{
			AR on $($(<)HB) = $(AR32) ;
		}
		ObjectsHB $(SUFHB)$(DFS)$(>) ;
		Depends $($(<)HB) : $(INGLIBHB) ;
		MkDir $(INGLIBHB) ;
	}
	else
	{
		LibraryFromObjects $($(<)HB) : $(SUFHB)$(DFS)$(>:S=$(SUFOBJ)) ;
        	if $(config_string) = r64_us5
        	{
          	  AR on $($(<)HB) = ar -X64 ru ;
          	  RANLIB on $($(<)HB) = ranlib -X64 ;
        	}
		ObjectsHB $(SUFHB)$(DFS)$(>) ;
		Depends $($(<)HB) : $($(<)HB:D) ;
		MkDir $($(<)HB:D) ;
	}
}

rule ObjectsHB
{
        local _i ;

        for _i in [ FGristFiles $(<) ]
        {
                Object $(_i:S=$(SUFOBJ)) : <$(SOURCE_GRIST)!$(SUFHB)>$(_i:BS) ;
		if $(VERS32) = int_w32
		{
	  	  CC on $(_i:S=$(SUFOBJ)) = $(CC32) ;
		  C++ on $(_i:S=$(SUFOBJ)) = $(CC32) ;
		}
                Depends obj : $(_i:S=$(SUFOBJ)) ;
		switch $(_i:S)
		{
		case .qsc :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .sc :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .qc :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .st :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .sy :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .yf :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .yi :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .lex :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .lfm :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .s :
		    ASFLAGS on $(_i:S=$(SUFOBJ)) = $(ASFLAGSHB) ;
		    if $(ASHB)
		    {
		        AS on $(_i:S=$(SUFOBJ)) = $(ASHB) ;
		    }
		    ASCPPFLAGS on $(_i:S=$(SUFOBJ)) = $(ASCPPFLAGSHB) ;
		    ASM4FLAGS on $(_i:S=$(SUFOBJ)) = $(ASM4FLAGSHB) ;
		case .c :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .y :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .roc :
		    CCFLAGS on $(_i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
		case .cpp :
		    C++FLAGS on $(_i:S=$(SUFOBJ)) = $(C++FLAGSHB) ;
		}
		Depends $(_i:S=$(SUFOBJ)) : $(SEARCH_SOURCE)$(DFS)$(SUFHB) ;
		MkDir $(SEARCH_SOURCE)$(DFS)$(SUFHB) ;
        }
}

rule IINOOPTIM
{
        if ! $(NT)
        {

          local _o = [ FGristFiles $(<) ] ;
          local i ;
          local j ;
          local debug = "n" ;


          for i in $(>)
          {
            if "$(i)" = "$(VERS)" || "$(i)" = "all"
            {
             for j in $(IIOPTIM)
             {
               if "$(j)" = $(CCDEBUG)
               {
                debug = "y" ;
                break ;
               }
             }
             if "$(debug)" = "n"
             {
              OPTIM on $(_o:S=$(SUFOBJ)) = $(NOOPTIM) ;
             }
            }
          }
         if $(VERSHB)
           {
            local _o64 = [ FGristFiles $(SUFHB)/$(<) ] ;
            local i64 ;
            for i64 in $(>)
             {
              if "$(i64)" = "$(VERSHB)" || "$(i64)" = "all"
               {
                for j in $(IIOPTIM)
                {
                 if "$(j)" = $(CCDEBUG)
                 {
                   debug = "y" ;
                   break ;
                 }
                }
                if "$(debug)" = "n"
                {
                 OPTIM on $(_o64:S=$(SUFOBJ)) = $(NOOPTIM) ;
                }
               }
             }
           }
        }
	if $(NT)
	{
		local _o = [ FGristFiles $(<) ] ;		
		for i in $(>)
		{
			if "$(i)" = "$(VERS)"
			{
				OPTIM on $(_o:S=$(SUFOBJ)) = $(NOOPTIM) ;	
			}
		}
	}
}

rule IIL1OPTIM
{
       if ! $(NT)
       {
         local _o = [ FGristFiles $(<) ] ;
         local i ;
         for i in $(>)
         {
           if "$(i)" = "$(VERS)" || "$(i)" = "all"
           {
            OPTIM on $(_o:S=$(SUFOBJ)) = $(LEVEL1_OPTIM) ;
           }
         }
          if $(VERSHB)
            {
             local _o64 = [ FGristFiles $(SUFHB)/$(<) ] ;
             local i64 ;
             for i64 in $(>)
              {
               if "$(i64)" = "$(VERSHB)" || "$(i64)" = "all"
                {
                 OPTIM on $(_o64:S=$(SUFOBJ)) = $(LEVEL1_OPTIM) ;
                }
              }
            }
       }
}

rule IISetCMPORTS
{ 
     if $(NT)
     {
	local _o = [ FGristFiles $(<) ] ;
	for i in $(_o:S=$(SUFOBJ))
	{
	     CCFLAGS on $(i:S=$(SUFOBJ)) += $($(>)) ;
	     $(i:S=$(SUFOBJ)) = TRUE  ;
			
	}
	if $(VERSHB)
	{
	     local _o64 = [ FGristFiles $(SUFHB)$(DFS)$(<) ] ;
	     for i in $(o64:S=$(SUFOBJ)
	     {
	        CCFLAGS on $(i:S=$(SUFOBJ)) += $($(>)) ;
		$(i:S=$(SUFOBJ)) = TRUE  ;
	     }
	}
     }
}

rule IICCFLAGS
{
	local _o = [ FGristFiles $(<) ] ;
	for i in $(_o:S=$(SUFOBJ))
	{
	  CCFLAGS on $(i) += $($(>)) ;
	  C++FLAGS on $(i) += $($(>)) ;
	}
if $(VERSHB)
{
	local _o64 = [ FGristFiles $(SUFHB)/$(<) ] ;
	for i64 in $(_o64:S=$(SUFOBJ))
	{
	  CCFLAGS on $(i64) += $($(>)) ;
	  C++FLAGS on $(i64) += $($(>)) ;
	}
}
}

rule IILINKFLAGS
{
	local _o = [ FGristFiles $(<) ] ;
	for i in $(_o)
	{
	  LINKFLAGS on $(i) = $(LINKFLAGS) $($(>)) ;
	}
}

rule IILDFLAGS
{
        local _o = [ FGristFiles $(<) ] ;
        for i in $(_o)
        {
          LINKFLAGS on $(i:G=) += $($(>)) ;
          if $(VERSHB)
          {
              LINKFLAGS on $(SUFHB)$(DFS)$(i:G=) += $($(>)HB) ;
          }
        }
}

rule IIABFDEMO
{
    if $(NT)
    {
        IIBULKBAT $(INGFILES)/abfdemo : $(<) ;
    }
    else
    {
	BULK $(INGFILES)/abfdemo : $(<) ;
    }
}

rule IIABFCFG		
{ 
	_ABFCFG $(<) ;
	_USETOOL $(<) : iisuabf$(SUFXSH) ingprenv ingsetenv iigetres$(SUFEXE) ingunset
			iiechonn iipmhost$(SUFEXE) ;

	DEPENDS files : $(<) ;
	LOCATE on $(<) = $(INGTIMESTAMP) ;
}

rule IIBZARCH
{
    if ! $(NT)
    {
	  _MKHDR $(<) ;

          if  $(VMS)
          {
	      _USETOOL  $(<) : inglink$(SUFXSH) ;

	      Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
              Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                             $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
          }
	  _USETOOL $(<) : mkbzarch$(SUFXSH) readvers$(SUFXSH) machine$(SUFEXE)
			  whatunix$(SUFXSH) align$(SUFEXE) salign$(SUFEXE)
			  endian$(SUFEXE) tidswap$(SUFEXE) unschar$(SUFEXE)
			  bitsin$(SUFEXE) mathsigs$(SUFEXE) ;

	  if $(VERSHB)
	  {
	  _USETOOL $(<) : mkbzarch$(SUFXSH) readvers$(SUFXSH) machine$(SUFEXE)
			  whatunix$(SUFXSH) align$(SUFEXE) salign$(SUFEXE)
			  $(SUFHB)/salign$(SUFEXE) endian$(SUFEXE)
			  tidswap$(SUFEXE) unschar$(SUFEXE) bitsin$(SUFEXE)
			  $(SUFHB)/bitsin$(SUFEXE) mathsigs$(SUFEXE) ;
	  }
	  DEPENDS boot : $(<) ;
	  LOCATE on $(<) = $(HDRCL) ;

	  Clean clean : $(<) ;
    }
    else
    {
        _CALLBZARCHBAT $(<) ;
	_USETOOL $(<) : mkbzarch.bat ;

        DEPENDS boot : $(<) ;
	Clean clean : $(<) ;
        LOCATE on $(<) = $(HDRCL) ;
    }


}

rule IICHARSET
{
	for i in $(<)
	{
	  TDir = [ FDirName $(INGCHARSETS) $(i:S=) ] ;
	  T = $(TDir)$(DFS)desc.chx ; S = $(i) ;

	  if ! $(NT)
	  {
	  _CHARSET $(T) : $(S) ;
	  _USETOOL $(T) : chset_install$(SUFEXE) ;
	  }
	  else
	  {
	  _CHARSETW $(T) : $(S) ;
	  _USETOOL $(T) : chset_install.exe ;
	  }

	  DEPENDS hdrs : $(T) ;
	  DEPENDS $(T) : $(S) ;
	  Clean clean : $(T) ;
	}
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
}

rule IICOPY
{
		DEPENDS hdrs : $(<) ;
		DEPENDS exe : $(<) ;
		DEPENDS shlibs : $(<) ;
		DEPENDS $(<) : $(>) ;
		SEARCH on $(>) = $(INGLIB) ;
		COPY $(<) : $(>) ;	
}

rule IICPDLL
{
	local _t = $(INGBIN)$(DFS)$(<) ;
	if "$(<:D)" != "" && $(<:D) != $(SUFHB)
	{
		_t = $(<) ;
		_IICPDLL $(<) : $(>) ;
	}
	else
	{
		if "$(<:D)" != "" && $(<:D) = $(SUFHB)
		{
		_IICPDLLBINHB $(<) : $(>) ;
		}
		else
		{
		_IICPDLLBIN $(<) : $(>) ;
		}
		DEPENDS $(_t) : $(>) ;
		DEPENDS $(_t) : $(_t:D) ;
		MkDir $(_t:D) ;
	}
	DEPENDS shlibs : $(<) ;
	SEARCH on $(>) = $(INGLIB) ;
	#LOCATE on $(<) = $(INGBIN) ;

	Clean clean : $(_t) ;
}

rule IICPEXE
{
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	DEPENDS $(<) : $(<:D) ;
	MkDir $(<:D) ;
	LOCATE on $(<) = $(<:D) ;
	#
	# for now if NOREBUILD is ON do not copy exes around
	#
	if $(NOREBUILD) { NOUPDATE $(<) ; }

	MODE on $(<) = $(EXEMODE) ;
	Chmod $(<) ;

	Clean clean : $(<) ;
}


rule IICLSECRET
{
    if ! $(NT)
    {
	_MKHDR $(<) ;

	DEPENDS boot : $(<) ;
        if  $(VMS)
        {
            _USETOOL $(<) : inglink$(SUFXSH) ;

	    Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
            Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                           $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
        }
	_USETOOL $(<) : mksecret$(SUFXSH) readvers$(SUFXSH) machine$(SUFEXE) whatunix$(SUFXSH)
			mathsigs$(SUFEXE) stdlim$(SUFEXE) ;

	LOCATE on $(<) = $(HDRCLF) ;
	Clean clean : $(<) ;
    }
    else
    {
        FILE $(<) : $(INGBAT)/$(<) ;
        DEPENDS boot : $(<) ;
	Clean clean : $(<) ;
        LOCATE on $(<) = $(HDRCLF) ;
    }


}

rule IICOLDATA
{
	local _uflag = -u ;
	_COLDATA $(<) : $(>) ;
	_USETOOL $(<) : aducompile$(SUFEXE) ;

	switch $(>) 
	{
	    case *uce : ADUCOMPFLAGS on $(<:D=) = $(_uflag) ;
	}
	DEPENDS $(<) : aducompile ;  #?
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	LOCATE on $(<) = $(INGCOL) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

if $(VERSHB)
{
	if $(NT)
	{
	_COLDATAHBW $(SUFHB)/$(<) : $(>) ;
	}
	else
	{
	_COLDATAHB $(SUFHB)/$(<) : $(>) ;
	}
	_USETOOL $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)aducompile$(SUFEXE) ;
	switch $(>) 
	{
	    case *uce : ADUCOMPFLAGS on $(SUFHB)$(DFS)$(<:D=) = $(_uflag) ;
	}
	DEPENDS files : $(SUFHB)$(DFS)$(<) ;
	DEPENDS $(SUFHB)$(DFS)$(<) : $(>) ;
	LOCATE on $(SUFHB)$(DFS)$(<) = $(INGCOL) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	Depends $(SUFHB)$(DFS)$(<) : $(INGCOL)$(DFS)$(SUFHB) ;
	MkDir $(INGCOL)$(DFS)$(SUFHB) ;
}
}

rule IICRS
{
	for i in $(<)
	{
	  T = $(INGFILES)$(DFS)$(i) ; S = $(i) ;

	  IICCPPFILE $(T) : $(S) ;

	  DEPENDS files : $(T) ;
	  DEPENDS $(T) : $(S) ;
	}
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
}


rule IICRSW
{
	for i in $(<)
	{
 	  T = $(INGFILES)/$(i) ; S = $(i) ;
 
 	  IICCPPFILE $(S:S=.ccpp) : $(S) ;
 	  _IICOPYFILE $(T) : $(S:S=.ccpp) ;
 	  
 	  DEPENDS files : $(T) ;
                  DEPENDS $(T) : $(S) ;
 
	  LOCATE on $(S:S=.ccpp) = $(SEARCH_SOURCE) ;
	  LOCATE on $(S:S=.sed) = $(SEARCH_SOURCE) ;
	  Clean clean : $(S:S=.sed) $(S:S=.ccpp) ;

 	}
 	SEARCH on $(<) = $(SEARCH_SOURCE) ;

	Clean clean : $(INGFILES)/$(<:D=) ;
}

rule IIDEF
{
	for i in $(<)
	{
	  T = $(INGFILES)/$(i:S=.def) ; S = $(i) ;

	  _YYPP $(T) : $(S) ;

	  _USETOOL $(<) : yypp$(SUFXSH) yapp$(SUFEXE) ;
	  DEPENDS files : $(T) ;
	  DEPENDS $(T) : $(S) ;

	}
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	
}

rule IIEQDEF
{
	for i in $(<)
	{
	  T = $(INGFILES)$(DFS)$(i:S=.h) ; S = $(i) ;

          if ! $(NT)
          {
	      _YYPP $(T) : $(S) ;
	      _USETOOL $(T) : yypp$(SUFXSH) yapp$(SUFEXE) ;
          }
          else
          {
              _CCPP $(T) : $(S) ;
              _USETOOL $(T) : readvers.bat ccpp.bat ;
          }

	  DEPENDS files : $(T) ;
	  DEPENDS $(T) : $(S) ;
	  SEARCH on $(S) = $(SEARCH_SOURCE) ;

	  Clean clean : $(T) ;
	}
}

rule IIEQDEFCC
{
	T = $(INGFILES)$(DFS)$(<:S=.h) ; S = $(<) ;

	if ! $(NT)
	{
	   _YYPP $(T) : $(S) ;
   	   _USETOOL $(T) : yypp$(SUFXSH) yapp$(SUFEXE) ;
	}
	else
	{
	   IICCPPW $(T) : $(S) ;
	   _USETOOL $(T) : ccpp.bat ;
	}
	DEPENDS files : $(T) ;
	DEPENDS $(T) : $(<) $(>) ;
	SEARCH on $(S) = $(SEARCH_SOURCE) ;
}

rule IIFORM
{
	local _f = [ FGristFiles $(<) ] ;
 	local _path, _lang ;
 	_lang = $(SEARCH_SOURCE:D=) ;
 	if $(_lang) = deu || $(_lang) = esn ||
 	   $(_lang) = fra || $(_lang) = ita ||
 	   $(_lang) = jpn || $(_lang) = ptb ||
 	   $(_lang) = sch
 	{
 	  _path = [ FDirName $(INGFILES) $(_lang) ] ;	  
 	}
 	else
 	{
 	  _path = $(INGMSG) ;
    	}
	if $(VMS)
	{
	    _USETOOL $(<) : formindex$(SUFEXE) ;
	}
 	R = $(_path)$(DFS)rtiforms.fnx ;
 	Depends forms : $(R) ;

	for i in $(_f)
	{
	  T = $(i:S=.efr) ; S = $(i) ;
	  Clean clean : $(T) ;
	  RTIFORM on $(T) = $(R) ;
	  if ! $(NT)
	  {
	  _FORM $(T) : $(S) ;
	  }
	  else
	  {
	  _FORMW $(T) : $(S) ;
	  }
	  if ! $(NT)
	  {
	  _USETOOL $(T) : formindex$(SUFEXE) ;
	  }
	  else
	  {
	  _USETOOL $(T) : formindex.$(EXESFX) ;
	  }

	  Depends $(R) : $(T) ;
	  DEPENDS $(T) : $(S) ;

if $(VERSHB)
{
	    if $(NT)
	    {
		_FORMHBW $(T) : $(S) ;
	    }
	    else
	    {
		_FORMHB $(T) : $(S) ;
	    }
 	    DEPENDS forms : $(_path)$(DFS)$(SUFHB)$(DFS)rtiforms.fnx ;
 	    DEPENDS $(T) : $(_path)$(DFS)$(SUFHB) ;
 	    Depends $(_path)$(DFS)$(SUFHB)$(DFS)rtiforms.fnx : $(_path)$(DFS)$(SUFHB) ;
 	    MkDir $(_path)$(DFS)$(SUFHB) ;
	    RTIFORMHB on $(T) = $(_path)$(DFS)$(SUFHB)$(DFS)rtiforms.fnx ;
}
	}
	LOCATE on $(_f:S=.efr) = $(LOCATE_TARGET) ;
	SEARCH on $(_f) = $(SEARCH_SOURCE) ;
}

rule IIGV
{
    if ! $(NT)
    {
	_MKHDR $(<) ;

        if $(VMS)
        {
            _USETOOL $(<) : inglink$(SUFXSH) ;

	    Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
            Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                           $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
        }
	_USETOOL $(<) : mkgv$(SUFXSH) readvers$(SUFXSH) ccpp$(SUFXSH) genrelid$(SUFXSH) ;

	if ! $(VMS)
	{
		# Unix specific tool dependency.

		_USETOOL $(<) : iisysdep$(SUFXSH) ;
	}

	DEPENDS boot : $(<) ;
	LOCATE on $(<) = $(HDRCL) ;
	Clean clean : $(<) ;
    }
    else
    {
        _CALLGVBAT $(<) ;
        _USETOOL $(<) : mkgv.bat readvers.bat ccpp.bat genrelid.bat ;
        DEPENDS boot : $(<) ;
	DEPENDS $(<:S=.rc) : $(<) ;
        Clean clean : $(<) $(II_SYSTEM)/ingres/version.rel 
			$(ING_SRC)/cl/clf/gv_win/gv.rc (ING_SRC)/cl/clf/gv_win/gv.res ;
        LOCATE on $(<) = $(HDRCL) ;
    }


}

rule IIDEFAULT
{
	_MKHDR $(<) ;
	_USETOOL $(<) : mkdefault$(SUFXSH) readvers$(SUFXSH) ;

	DEPENDS boot : $(<) ;
	LOCATE on $(<) = $(HDRTOOLS) ;

	Clean clean : $(<) ;
}

rule IIGENERIC
{
	_MKHDR $(<) ;
	_USETOOL $(<) : mkgeneric$(SUFXSH) readvers$(SUFXSH) ;

	DEPENDS boot : $(<) ;
	LOCATE on $(<) = $(HDRTOOLS) ;

	Clean clean : $(<) ;
}

rule IIIISYSDEP
{
	DEPENDS $(<) : $(>) ;
	_IISYSDEP $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : mksysdep genrelid$(SUFXSH) shlibinfo$(SUFXSH) ;
	}
	else
	{
	_USETOOL $(<) : genrelid.bat ;
	}
	DEPENDS $(<) : default.h $(MKIDIRDONE) ;
	SEARCH on default.h = $(HDRTOOLS) ;

	DEPENDS shell : $(<) ;
	LOCATE on $(<) = $(INGUTIL) ;
	Clean clean : $(<) ;
}

rule IIINGDIRS
{
    Depends boot : $(INGTOOLSLIB) ;
    MkDir $(INGTOOLSLIB) ;
	DEPENDS boot : $(MKIDIRDONE) ;
	DEPENDS boot : $($(<)) ;
	NOUPDATE $(MKIDIRDONE) ;


    if ! $(NT)
    {
	_INGDIRS $($(<)) ;
	_USETOOL $($(<)) : mkshlibs$(SUFXSH) shlibinfo$(SUFXSH) mkidir$(SUFXSH) readvers$(SUFXSH) yypp$(SUFXSH) ccpp$(SUFXSH) ;
    }
    else
    {
        _INGDIRSNT $($(<)) ;
        _USETOOL $($(<)) : mkidir.bat ;
    }
}

rule IIINSTALLHLP
{
    if $(NT)
    {
	BULK $(INGMSG) : $(<) ;
	Clean clean : $(INGMSG)/$(<) ;
    }
    else
    {
	for i in $(<)
	{
	local d = $(i:D=$(INGMANIFEST)) ;
	Depends files : $(d) ;
	Depends $(d) : $(i) ;
	SEDCCPP $(d) : $(i) ;
	if $(VMS)
	{
	    Depends $(d) : $(INGTOOLSLIB)sedccpp.sed ;
	}
	MODE on $(d) = $(FILEMODE) ;
	Chmod $(d) ;
	}
	Clean clean : $(INGMANIFEST)/$(<) ;
    }
    SEARCH on $(<) = $(SEARCH_SOURCE) ;
}

rule IIINSTALLDAT
{
    if ! $(VMS)
    {
	_LINK $(<) : $(>) ;
    }
	
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;

	LOCATE on $(<) = $(INGFILES) ;
	SEARCH on $(>) = $(INGMANIFEST) ;
}

rule IIINGBLDLINK
{
	T = $(INGINSTALL)/$(<) ;
	S = $(INGUTIL)/$(<) ;
	_LINK $(T) : $(S) ;

	DEPENDS files : $(T) ;
	DEPENDS $(T) : $(S:D=) ;
	LOCATE on $(T) = $(INGINGSTALL) ;
	SEARCH on $(S) = $(INGUTIL) ;
}

rule IILIBPRT
{
	_LIBPRT $(<) : $(>) ;

	_USETOOL $(<) : shlibinfo$(SUFXSH) yypp$(SUFXSH) yapp$(SUFEXE) ;
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	
	LOCATE on $(<) = $(INGMANIFEST) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule IIIMPLIBRARY
{
	DEPENDS $(<) : $(>) ;
	ImpArchive $(<) : $(>) ;
      	Clean clean : $(<) ;
	LOCATE on $(<) = $(INGLIB) ;
	SEARCH on $(>) = $(INGLIB) ;
	if $(VERSHB)
	{
		DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(>) ;
		ImpArchive $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(>) ;
		Clean clean : $(SUFHB)$(DFS)$(<) ;
		LOCATE on $(SUFHB)(DFS)$(<) = $(INGLIB) ;
		SEARCH on $(SUFHB)$(DFS)$(>) = $(INGLIB) ;


		AR on $(SUFHB)$(DFS)$(<) = $(AR32) ;
	}


}

rule IISHLIBRARY
{
    if $(NT)
    {
	local _o _list ;
	for _o in $(>)
	{
		_list += $(_o:S=.$(LIBSFX)) ;	
		switch $(_o)
		{
			case iilib*.dll : DEPENDS $(<) : $(_o:S=.$(LIBSFX)) ;
			case *.lib 	: DEPENDS $(<) : $(_o) ;
			case *		: DEPENDS $(<) : $(_o) ;
		}
	}
	switch $(<)
	{		
                case iilibgcskrb*       : SharedLibLinkNoImp $(<) : $(>) ;
                                        LOCATE on $(SHGSSAPILIB) = $(INGLIB) ;
                                        RmTemps $(<) : $(SHGSSAPILIB) ;
                                        RmTemps $(<) : $(IMPGSSAPILIB) ;

                case gssapi*            : DEPENDS $(<:S=.$(LIBSFX)) : $(<) ;
                                        SharedLibLink $(<) : $(_list) ;

		case *caii*		: SharedLibLinkNoImp $(<) : $(_list) ;

		case *odbc*	        : SharedLibLinkNoImp $(<) : $(_list) ;

		case iilibutil*		: DEPENDS $(<:S=.$(LIBSFX)) : $(<) ;
					LINKLIBS on $(<) = $(MSILIB) $(ADVAPILIB) $(C_LIB) ;
					SharedLibLink $(<) : $(_list) ;
		
		case iipfctrs*		: DEPENDS $(<:S=.$(LIBSFX)) : $(<) ;
					SharedLibLink $(<) : $(_list) ;

 		case *NewOrder* 	: DEPENDS $(<:S=.$(LIBSFX)) : $(<) ;
 				  	SharedLibLinkNoDef $(<) : $(_list) ;
 
 		case *data* 		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;

		case *libscf*		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;

		case *libdmf*		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;

		case *libqef*		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;

		case *librdf*		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;

		case *libgcf*		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;

		case *libulf*		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;

		case *libpsf*		: NOUPDATE $(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(<) : $(_list) ;
 
 		case * 			: DEPENDS $(<) : $(<:B)data.$(LIBSFX) ;
 			 		NOUPDATE $(<:S=.$(LIBSFX)) ;
 		         		DEPENDS $(<:S=.$(LIBSFX)) : $(<) ;
 					SharedLibLink $(<) : $(_list) ;
	}
	LOCATE on $(<) = $(INGLIB) ;
	LOCATE on $(<:B).lib = $(INGLIB) ;
	SEARCH on $(>) = $(INGLIB) ;

	DEPENDS shlibs : $(<) ;
	_USETOOL $(<) : binaddr.txt updcoffbf.exe ;

	if $(<:D=) != $(SHAPACHELIB) && $(<:D=) != $(SHICEMSLIB) && $(<:D=) != $(SHGSSAPILIB)
	{
	IICPDLL $(<) : $(<) ;
	}
	IIREBASE $(<) ;

        Clean clean : $(<) $(INGLIB)/$(<:S=.exp:D=) $(INGLIB)/$(<:S=.map:D=) 
                      $(INGLIB)/$(<:S=.$(LIBSFX):D=) $(INGBIN)/$(<:D=) 
		      $(INGLIB)/$(<:S=.ilk:D=) $(INGLIB)/$(<:S=.pdb:D=) 
		      $(INGLIB)/$(<).manifest ;
	MODE on $(<) = $(DLLMODE) ;
	Chmod $(<) ;


	if $(VERSHB) && $(<:D=) != $(SHAPACHELIB) && $(<:D=) != $(SHICEMSLIB)
	{
	local _o _list ;

	LINK on $(SUFHB)$(DFS)$(<) = $(LINK32) ;
	LINKFLAGS on $(SUFHB)$(DFS)$(<) = $(LINKFLAGS32) ;
	LIBP on $(SUFHB)$(DFS)$(<) = $(LIB32) $(SDK32) ;
	LINKLIBS on $(SUFHB)$(DFS)$(<) = $(LINKLIBS32) ;

	for _o in $(>)
	{
		switch $(_o)
		{
			case odbc*.lib : _list += $(_o:S=.$(LIBSFX)) ;	 
			case html*.lib : _list += $(_o:S=.$(LIBSFX)) ;	
			case *32.lib : _list += $(_o:S=.$(LIBSFX)) ;	
			case *	: _list += $(SUFHB)$(DFS)$(_o:S=.$(LIBSFX)) ;
		}
		
		switch $(_o)
		{
			case *iilib*.dll : DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(_o:S=.$(LIBSFX)) ;
			case odbc*.lib   : DEPENDS $(SUFHB)$(DFS)$(<) : $(_o) ;
			case gss*32.lib   : DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(_o) ;
			case *32.lib   : DEPENDS $(SUFHB)$(DFS)$(<) : $(_o) ;
			case html*.lib   : DEPENDS $(SUFHB)$(DFS)$(<) : $(_o) ;
			case *.lib 	: DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(_o) ;
			case *		: DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(_o) ;
		}
	}
	switch $(<)
	{		
                case iilibgcskrb*       : SharedLibLinkNoImp $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(>) ;
                                        LOCATE on $(SUFHB)$(DFS)$(SHGSSAPILIB) = $(INGLIB) ;
                                        RmTemps $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(SHGSSAPILIB) ;
                                        RmTemps $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(IMPGSSAPILIB) ;

                case gssapi*            : DEPENDS $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) : $(SUFHB)$(DFS)$(<) ;
                                        SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *caii*		: SharedLibLinkNoImp $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *odbc*	        : SharedLibLinkNoImp $(SUFHB)$(DFS)$(<) : $(_list) ;

		case iilibutil*		: DEPENDS $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) : $(SUFHB)$(DFS)$(<) ;
					LINKLIBS on $(SUFHB)$(DFS)$(<) = $(MSILIB) $(ADVAPILIB) $(C_LIB) ;
					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;
		
		case iipfctrs*		: DEPENDS $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) : $(SUFHB)$(DFS)$(<) ;
					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

 		case *NewOrder* 	: DEPENDS $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) : $(SUFHB)$(DFS)$(<) ;
 				  	SharedLibLinkNoDef $(SUFHB)$(DFS)$(<) : $(_list) ;
 
 		case *data* 		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *libscf*		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *libdmf*		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *libqef*		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *librdf*		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *libgcf*		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *libulf*		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;

		case *libpsf*		: NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;
 
 		case * 			: DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(<:B)data.$(LIBSFX) ;
 			 		NOUPDATE $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) ;
 		         		DEPENDS $(SUFHB)$(DFS)$(<:S=.$(LIBSFX)) : $(SUFHB)$(DFS)$(<) ;
 					SharedLibLink $(SUFHB)$(DFS)$(<) : $(_list) ;
	}
	LOCATE on $(SUFHB)$(DFS)$(<) = $(INGLIB) ;
	LOCATE on $(SUFHB)$(DFS)$(<:B).lib = $(INGLIB) ;
	#SEARCH on $(SUFHB)$(DFS)$(<:B).lib = $(INGLIB) ;
	SEARCH on $(SUFHB)$(DFS)$(>) = $(INGLIB) ;
	DEPENDS $(SUFHB)$(DFS)$(<) : $(INGBIN)$(DFS)$(SUFHB) ;
	MkDir $(INGBIN)$(DFS)$(SUFHB) ;


	DEPENDS shlibs : $(SUFHB)$(DFS)$(<) ;
	_USETOOL $(SUFHB)$(DFS)$(<) : binaddr.txt updcoffbf.exe ;

	if $(<:D=) != $(SHAPACHELIB) && $(<:D=) != $(SHICEMSLIB) && $(<:D=) != $(SHGSSAPILIB)
	{
	IICPDLL $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(<) ;
	}
	IIREBASE $(SUFHB)$(DFS)$(<) ;

        Clean clean : $(SUFHB)$(DFS)$(<) $(INGLIBHB)$(DFS)$(<:S=.exp:D=) $(INGLIBHB)$(DFS)$(<:S=.map:D=) 
                      $(INGLIBHB)$(DFS)$(<:S=.$(LIBSFX):D=) $(INGBINHB)$(DFS)$(<:D=) 
		      $(INGLIBHB)$(DFS)$(<:S=.ilk:D=) $(INGLIBHB)$(DFS)$(<:S=.pdb:D=) 
		      $(INGLIBHB)$(DFS)$(<).manifest ;
	MODE on $(SUFHB)$(DFS)$(<) = $(DLLMODE) ;
	Chmod $(SUFHB)$(DFS)$(<) ;

	}

    }
    else if $(VMS)
    {
	local shlib ;

	switch $(<)
	{
	    case cl* :
                shlib = compat ;
		Depends $(<) : $(COMPATLIB) $(COMPAT_LOT) ;
	    case libq* :
	        shlib = libq ;
		Depends $(<) : $(LIBQLIB) $(LIBQ_LOT) $(COMPAT_LOT) ;
	    case frame* :
	        shlib = frame ;
		Depends $(<) : $(FRAMELIB) $(FRAME_LOT) $(LIBQ_LOT) $(COMPAT_LOT) ;
	    case interp* :
	        shlib = interp ;
		Depends $(<) : $(INTERPLIB) $(INTERP_LOT) $(FRAME_LOT) $(LIBQ_LOT) $(COMPAT_LOT) ;
	    case api* :
	        shlib = api ;
		Depends $(<) : $(APILIB) $(API_LOT) $(LIBQ_LOT) $(COMPAT_LOT) ;
	    case *gcskrb* :
	        shlib = kerberos ;
                Depends $(<) : $(LIBGCSKRB_LOT) ;
	    case *odbcfe* :
		shlib = odbc ;
		Depends $(<) : $(ODBCDRIVERLIB) $(ODBC_LOT) $(API_LOT) $(COMPAT_LOT) ;
	    case *odbcrofe* :
		shlib = odbcro ;
		Depends $(<) : $(ODBCDRIVERLIB) $(ODBCRO_LOT) $(API_LOT) $(COMPAT_LOT) ;
	    case *odbcclife* :
		shlib = odbccli ;
		Depends $(<) : $(ODBCMGRLIB) $(ODBCCLI_LOT) $(API_LOT) $(COMPAT_LOT) ;
	    case iiuseradt* :
                shlib = iiuseradt ;
		Depends $(<) : $(IIUSERADT_LOT) ;
	}

	_MKSHLIBS $(<) ;

	Depends shlibs : $(<) ;
	SHLIB on $(<) = $(shlib) ;
	LOCATE on $(<) = $(INGLIB) ;
	NotFile $(shlib) ;
	_USETOOL $(<) : mkshlibs$(SUFXSH) shlibinfo$(SUFXSH) readvers$(SUFXSH) ;

        Clean clean :  $(SEARCH_SOURCE)$(<:BS=.map) ;
        Clean clean :  $(ING_BUILD)[DEBUG]$(<:S=.map) $(ING_BUILD)[DEBUG]$(<:S=.stb)
                       $(ING_BUILD)[DEBUG]$(<:S=.dsf) ;
    }
    else # UNIX
    {

   	local shlib exclude ;

	switch $(<)
	{
	
		case *compat.1*	: shlib = compat ;
			DEPENDS $(<) : $(COMPATLIB) ;	
   			LOCATE on $(<) = $(INGLIB) ;
		case *frame.1*	: shlib = frame ;
			DEPENDS $(<) : $(FRAME_LIBS) ;
			DEPENDS $(<) : $(SHQLIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *interp.1* : shlib = interp ;
			DEPENDS $(<) : $(INTERP_LIBS) ;
			DEPENDS $(<) : $(SHQLIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *libq.1* : shlib = libq ;
			DEPENDS $(<) : $(LIBQ_LIBS) ;
			DEPENDS $(<) : $(SHCOMPATLIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *api.1* : shlib = api ;
			DEPENDS $(<) : $(APILIB) ;
			DEPENDS $(<) : $(SHQLIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *ice.1* : shlib = oiiceap ;
			DEPENDS $(<) : $(OIICEAP_LIBS) ;
			LOCATE on $(<) = [ FDirName $(INGICE) bin apache ] ;
		case *icens.1* : shlib = oiicens ;
			DEPENDS $(<) : $(OIICENS_LIBS) ;
			LOCATE on $(<) = [ FDirName $(INGICE) bin netscape ] ;
		case *odbcdriver.1* : shlib = odbc ;
			DEPENDS $(<) : $(ODBCDRIVERLIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *odbc.1* : shlib = cli ;
			DEPENDS $(<) : $(ODBCMGRLIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *NewOrder* : shlib = neworder ;
			DEPENDS $(<) : $(NEWORDERLIB) ;
   			LOCATE on $(<) = [ FDirName $(INGFILES) dynamic ] ;
		case *oiddi* : shlib = oiddi ;
			DEPENDS $(<) : $(DDILIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *gcskrb* : shlib = kerberos ;
   			LOCATE on $(<) = $(INGLIB) ;
		case *oiutil* : shlib = oiutil ;
			DEPENDS $(<) : $(TNGAPILIB) ;
   			LOCATE on $(<) = $(INGLIB) ;
    	}

	_MKSHLIBS $(<) ;

   	DEPENDS shlibs : $(<) ;
   	SHLIB on $(<) = $(shlib) ;
   	NotFile $(shlib) ;
   	_USETOOL $(<) : mkshlibs$(SUFXSH) shlibinfo$(SUFXSH) readvers$(SUFXSH) iidsfree ensure iisysdep ;


	if $(VERSHB)
	{
    	switch $(<)
    	{
		case *compat.1*	: shlib = compat ;
			DEPENDS $(SUFHB)/$(<) : $(COMPATLIBHB) ;	
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *frame.1*	: shlib = frame ;
			DEPENDS $(SUFHB)/$(<) : $(FRAME_LIBSHB) ;
			DEPENDS $(SUFHB)/$(<) : $(SHLIBQLIBHB) ;	
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *interp.1* : shlib = interp ;
			DEPENDS $(SUFHB)/$(<) : $(INTERP_LIBSHB) ;
			DEPENDS $(SUFHB)/$(<) : $(SHLIBQLIBHB) ;	
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *libq.1* : shlib = libq ;
			DEPENDS $(SUFHB)/$(<) : $(LIBQ_LIBSHB) ;
			DEPENDS $(SUFHB)/$(<) : $(SHCOMPATLIB) ;	
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *api.1* : shlib = api ;
			DEPENDS $(SUFHB)/$(<) : $(APILIBHB) ;
			DEPENDS $(SUFHB)/$(<) : $(SHLIBQLIBHB) ;	
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case oiice.1* : shlib = oiiceap ;
			DEPENDS $(SUFHB)/$(<) : $(OIICEAP_LIBSHB) ;
   			LOCATE on $(SUFHB)/$(<) = [ FDirName $(INGICE) bin apache ] ;
		case *odbcdriver.1* : shlib = odbc ;
			DEPENDS $(SUFHB)/$(<) : $(ODBCDRIVERLIBHB) ;
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *odbc.1* : shlib = cli ;
			DEPENDS $(SUFHB)/$(<) : $(ODBCMGRLIBHB) ;
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *NewOrder* : shlib = neworder ;
			DEPENDS $(SUFHB)/$(<) : $(NEWORDERLIBHB) ;
   			LOCATE on $(SUFHB)/$(<) = [ FDirName $(INGFILES) dynamic ] ;
		case *oiddi* : shlib = oiddi ;
			DEPENDS $(SUFHB)/$(<) : $(DDILIBHB) ;
			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *gcskrb* : shlib = kerberos ;
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		case *oiutil* : shlib = oiutil ;
			DEPENDS $(SUFHB)/$(<) : $(TNGAPILIBHB) ;
   			LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
    	}
   	_MKSHLIBS $(SUFHB)/$(<) ;
   	DEPENDS shlibs : $(SUFHB)/$(<) ;
   	SHLIB on $(SUFHB)/$(<) = $(shlib) ;
   	PARMLPHB on $(SUFHB)/$(<) = "-$(SUFHB)" ;
	}
	
   }
}


rule IISHLIBRARYLCL
{
	local _g = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;
	Objects $(<:S=.c) ;
	DEPENDS $(<:S=$(SUFOBJ)) : $(<:S=.c) ;
	DEPENDS $(<) : $(_g) ;

	switch $(<)
	{	
		case setupmm* : NODEFAULTLIB on $(<) = "/NODEFAULTLIB:$(INGLIB)/$(CLIB)" ;
				CCFLAGS on $(_g) = $(CCFLAGS) $(WINNT) ;
	}

	DEPENDS shlibs : $(<) ;
	SharedLibLinkLcl $(<) ;

	LINKLIBS on $(<) = $(LINKLIBS) $(MORELIB2) ;
	CCFLAGS on $(_g) += $(PORTIMP) ;

	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	LOCATE on $(<:S=.$(LIBSFX)) = $(SEARCH_SOURCE) ;
	LOCATE on $(<:S=.$(SLSFX)) = $(SEARCH_SOURCE) ;
	LOCATE on $(<:S=.map) = $(SEARCH_SOURCE) ;
	LOCATE on $(<:S=.ilk) = $(SEARCH_SOURCE) ;
	LOCATE on $(<:S=.pdb) = $(SEARCH_SOURCE) ;
	LOCATE on $(<:S=.exp) = $(SEARCH_SOURCE) ;
	LOCATE on $(<).manifest = $(SEARCH_SOURCE) ;
	SEARCH on $(_g) = $(SEARCH_SOURCE) ;

	Clean clean : $(_g) $(<:S=.$(LIBSFX)) $(<:S=.$(SLSFX)) 
	$(<:S=.map) $(<:S=.ilk) $(<:S=.pdb) $(<:S=.exp) $(<).manifest ;
	

}

rule IIREBASE
{
	if $(<:D) = "lp32"
	{
	DEPENDS shlibs : $(<) ;
	RebaseHB $(<) ;
	}
	else
	{
	DEPENDS shlibs : $(<) ;
	Rebase $(<) ;
	}

}

rule IISVRSHLIBRARY
{
    local shlib ;

    DEPENDS shlibs : $(<) ;	

    switch $(<)
    {
	case *adf.1* : shlib = adf ;
	case *becompat.1* : shlib = becompat ;
	case *cuf.1* : shlib = cuf ;
	case *dbutil.1* : shlib = dbutil ;
	case *dmf.1* : shlib = dmf ;
	case *gcf.1* : shlib = gcf ;
	case *gwf.1* : shlib = gwf ;
	case *opf.1* : shlib = opf ;
	case *psf.1* : shlib = psf ;
	case *qef.1* : shlib = qef ;
	case *qsf.1* : shlib = qsf ;
	case *rdf.1* : shlib = rdf ;
	case *rqf.1* : shlib = rqf ;
	case *scf.1* : shlib = scf ;
	case *sxf.1* : shlib = sxf ;
	case *tpf.1* : shlib = tpf ;
	case *ulf.1* : shlib = ulf ;
    }

   _MKSVRSHLIBS $(<) ;

   SHLIB on $(<) = $(shlib) ;
   LOCATE on $(<) = $(INGBIN) ;
   NotFile $(shlib) ;
   _USETOOL $(<) : mksvrshlibs mkshlibs$(SUFXSH) shlibinfo$(SUFXSH) readvers$(SUFXSH) iidsfree ensure 
			iisysdep ;

   Clean clean : $(<) ;

    if $(VERSHB)
    {
	_MKSVRSHLIBS $(SUFHB)$(DFS)$(<) ;

	DEPENDS shlibs : $(SUFHB)/$(<) ;
	PARMLPHB on $(SUFHB)/$(<) = -$(SUFHB) ;
	SHLIB on $(SUFHB)/$(<) = $(shlib) ;
	LOCATE on $(SUFHB)/$(<) = $(INGBIN) ;

	_USETOOL $(SUFHB)$(DFS)$(<) : mksvrshlibs mkshlibs$(SUFXSH) shlibinfo$(SUFXSH) readvers$(SUFXSH) 
			iidsfree ensure iisysdep ;
    }

}

rule IISvrArLibrary
{
  DEPENDS files : $($(<)) ;
  DEPENDS $($(<)) : $(ADFLIB) $(COMPATLIB) $(DMFLIB) $(SCFLIB) $(QEFLIB)
                    $(PSFLIB) $(OPFLIB) $(RDFLIB) $(QSFLIB) $(TPFLIB)
                    $(RQFLIB) $(GCFLIB) $(GWFLIB) $(SXFLIB) $(CUFLIB)
                    $(DBUTILLIB) $(ULFLIB) ;
  _USETOOL $($(<)) : mksvrarlib mkshlibs$(SUFXSH) shlibinfo$(SUFXSH) readvers$(SUFXSH) iidsfree ensure 
                     iisysdep ;

  _MkSvrArLib $($(<)) ;


  if $(VERSHB)
  {
  	DEPENDS files : $($(<)HB) ;
   	DEPENDS $($(<)HB) : $(ADFLIBHB) $(COMPATLIBHB) $(DMFLIBHB) $(SCFLIBHB)
                            $(QEFLIBHB) $(PSFLIBHB) $(OPFLIBHB) $(RDFLIBHB)
                            $(QSFLIBHB) $(TPFLIBHB) $(RQFLIBHB) $(GCFLIBHB)
                            $(GWFLIBHB) $(SXFLIBHB) $(CUFLIBHB) $(DBUTILLIBHB)
                            $(ULFLIBHB) ;

	  _USETOOL $($(<)HB) : mksvrarlib mkshlibs$(SUFXSH) shlibinfo$(SUFXSH) readvers$(SUFXSH) iidsfree 
                            ensure iisysdep ;

  	  _MkSvrArLib64 $($(<)HB) ;
  	  Clean clean : $($(<)HB) ;
  }

}

rule IIMSGHDR
{
	local _f = [ FGristFiles $(<) ] ;
	for i in $(_f)
	{
	  T = $(i:S=.h) ; S = $(i) ;
	  if $(NT)
	  {
	  _MSGHDRW $(T) : $(S) ;
	  }
	  else
	  {
	  _MSGHDR $(T) : $(S) ;
	  }

	  _USETOOL $(T) : ercompile$(SUFEXE) ;

	  DEPENDS hdrs : msghdrs ;
	  DEPENDS msghdrs : $(T) ;
	  DEPENDS $(T) : $(S) ;
	  switch $(_f)
	  {
		case *front!* : DEPENDS $(FECATMSG) : $(T) ;
	  }

	  LOCATE on $(T) = $(SEARCH_SOURCE) ;
	  SEARCH on $(S) = $(SEARCH_SOURCE) ;

	  Clean clean : $(T) ;
	}
}

rule IIMNX
{
	if $(II_MSG_TEST)
	{
          local _s = [ FGristFiles $(>) ] ;
	  local _path, _lang ;
	  for i in $(<)
	  {
	    _lang = $(SEARCH_SOURCE:D=) ;
	    if $(_lang) = deu || $(_lang) = esn ||
	     $(_lang) = fra || $(_lang) = ita ||
	     $(_lang) = jpn || $(_lang) = ptb ||
	     $(_lang) = sch
	    {
	      _path = [ FDirName $(INGFILES) $(_lang) ] ;	  
	    }
	    else
	    {
	      _path = $(INGMSG) ;
   	    }
	    T = $(_path)$(DFS)$(i) ;

	    if $(NT)
	    {
		_MNXW $(T) : $(_s) ;
                  	_USETOOL $(T) : ercompile.exe ;
	    }
	    else
	    {
	    	_MNX $(T) : $(_s) ;
	       	_USETOOL $(T) : ercompile$(SUFEXE) ;
	    }

	    DEPENDS files : $(T) ;
	    DEPENDS $(T) : $(_s) ;

	    ERCOMPILE on $(T) = ercompile ;
	    ERCOMPFLAGS on $(T) = $(ERCOMPFLAGS) ;
	    SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	  }
	}
}

rule IIFSMNX
{
	local _s ;
	local _path, _lang ;
	for i in $(>)
	{
		if $(i:G=) != $(FECATMSG)
		{	
			_s += [ FGristFiles $(i) ] ;
		} 
		else 
		{
			_s += $(i) ;
		}
	}
	for i in $(<)
	{
	  _lang = $(SEARCH_SOURCE:D=) ;
	  if $(_lang) = deu || $(_lang) = esn ||
	     $(_lang) = fra || $(_lang) = ita ||
	     $(_lang) = jpn || $(_lang) = ptb ||
	     $(_lang) = sch
	  {
	  _path = [ FDirName $(INGFILES) $(_lang) ] ;	  
	  }
	  else
	  {
	  _path = $(INGMSG) ;
   	  }
	  T = $(_path)$(DFS)$(i) ;

	  if $(NT)
	  {
		_MNXW $(T) : $(_s) ;
	  }
	  else
	  {
	  	_MNX $(T) : $(_s) ;
	  }
	  if ! $(NT)
	  {
	  _USETOOL $(T) : ercompile$(SUFEXE) ;
	  }
	  else
	  {
	  _USETOOL $(T) : ercompile.exe ;
	  }

	  DEPENDS files : $(T) ;
	  if $(_lang) != deu &&
		$(_lang) != esn && $(_lang) != fra &&
		$(_lang) != ita && $(_lang) != jpn &&
		$(_lang) != ptb && $(_lang) != sch
	  {
	  Depends $(T) : $(FECATMSG) ;
	  SEARCH on $(FECATMSG) = $(SEARCH_SOURCE) ;
	  }
	  DEPENDS $(T) : $(_s) ;

	  ERCOMPILE on $(T) = ercompile ;
	  ERCOMPFLAGS on $(T) = $(ERCOMPFLAGS) ;
	  SEARCH on $(_s) = $(SEARCH_SOURCE) ;

	  Clean clean : $(T) ;
	}
}

rule IIIntCat
{
	local _s = [ FGristFiles $(>) ] ;
	local _t = [ FGristFiles $(<) ] ;
	for i in $(_s)
	{
		if $(_s[1]) = $(i)
		{
		_IntCatStart $(_t) : $(i) ;
		}
		else
		{
		_IntCat $(_t) : $(i) ;
		}
	}
	DEPENDS $(_t) : $(_s) ;
	SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	LOCATE on $(_t) = $(SEARCH_SOURCE) ;

}

rule IIMNX_v3
{
	local _s = [ FGristFiles $(>) ] ;
	local _path, _lang ;
	for i in $(<)
	{
	  _lang = $(SEARCH_SOURCE:D=) ;
	  if $(_lang) = deu || $(_lang) = esn ||
	     $(_lang) = fra || $(_lang) = ita ||
	     $(_lang) = jpn || $(_lang) = ptb ||
	     $(_lang) = sch
	  {
	  _path = [ FDirName $(INGFILES) $(_lang) ] ;	  
	  }
	  else
	  {
	  _path = $(INGMSG) ;
   	  }
	  T = $(_path)$(DFS)$(i) ;

	  if $(NT)
	  {
		_MNXW $(T) : $(_s) ;
	  }
	  else if $(VMS)
	  {
	  	_MNXO $(T) : $(_s) ;
	  }
          	  else
	  {
	  	_MNX $(T) : $(_s) ;
	  }
	  _USETOOL $(T) : ercompile_v3$(SUFEXE) ;

	  DEPENDS files : $(T) ;
	  DEPENDS $(T) : $(_s) ;

	  ERCOMPILE on $(T) = ercompile_v3 ;
	  ERCOMPFLAGS on $(T) = $(ERCOMPFLAGS_v2) ;
	  SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	  Clean clean : $(T) ;
	}
}

rule IIMNX_v2
{
	local _s = [ FGristFiles $(>) ] ;
	local _lang, _path ;
	for i in $(<)
	{
	  _lang = $(SEARCH_SOURCE:D=) ;
	  if $(_lang) = deu || $(_lang) = esn ||
	     $(_lang) = fra || $(_lang) = ita ||
	     $(_lang) = jpn || $(_lang) = ptb ||
	     $(_lang) = sch
	  {
	  _path = [ FDirName $(INGFILES) $(_lang) ] ;	  
	  }
	  else
	  {
	  _path = $(INGMSG) ;
   	  }
	  T = $(_path)$(DFS)$(i) ;

	  if $(NT)
	  {
		_MNXW $(T) : $(_s) ;
	  }
	  else if $(VMS)
	  {
	  	_MNXO $(T) : $(_s) ;
	  }
	  else
	  {
	  	_MNX $(T) : $(_s) ;
	  }
	  _USETOOL $(T) : ercompile_v2$(SUFEXE) ;

	  DEPENDS files : $(T) ;
	  DEPENDS $(T) : $(_s) ;

	  ERCOMPILE on $(T) = ercompile_v2 ;
	  ERCOMPFLAGS on $(T) = $(ERCOMPFLAGS_v2) ;
	  SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	  Clean clean : $(T) ;
	}
}

rule IIMNX_v1
{
	local _s = [ FGristFiles $(>) ] ;
	local _path, _lang ;
	for i in $(<)
	{
	  _lang = $(SEARCH_SOURCE:D=) ;
	  if $(_lang) = deu || $(_lang) = esn ||
	     $(_lang) = fra || $(_lang) = ita ||
	     $(_lang) = jpn || $(_lang) = ptb ||
	     $(_lang) = sch
	  {
	  _path = [ FDirName $(INGFILES) $(_lang) ] ;	  
	  }
	  else
	  {
	  _path = $(INGMSG) ;
   	  }
	  T = $(_path)$(DFS)$(i) ;

	  if $(NT)
	  {
		_MNXW $(T) : $(_s) ;
	  }
	  else if $(VMS)
	  {
	  	_MNXO $(T) : $(_s) ;
	  }
	  else
	  {
	  	_MNX $(T) : $(_s) ;
	  }
	  _USETOOL $(T) : ercompile_v1$(SUFEXE) ;

	  DEPENDS files : $(T) ;
	  DEPENDS $(T) : $(_s) ;

	  ERCOMPILE on $(T) = ercompile_v1 ;
	  ERCOMPFLAGS on $(T) = $(ERCOMPFLAGS_v1) ;
	  SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	  Clean clean : $(T) ;
	}
}

rule IIMNX_v0
{
	local _s = [ FGristFiles $(>) ] ;
	local _path, _lang ;
	for i in $(<)
	{
	  _lang = $(SEARCH_SOURCE:D=) ;
	  if $(_lang) = deu || $(_lang) = esn ||
	     $(_lang) = fra || $(_lang) = ita ||
	     $(_lang) = jpn || $(_lang) = ptb ||
	     $(_lang) = sch
	  {
	  _path = [ FDirName $(INGFILES) $(_lang) ] ;	  
	  }
	  else
	  {
	  _path = $(INGMSG) ;
   	  }
	  T = $(_path)$(DFS)$(i) ;

	  if $(NT)
	  {
		_MNXW $(T) : $(_s) ;
	  }
	  else if $(VMS)
	  {
	  	_MNXO $(T) : $(_s) ;
	  }
	  else
	  {
	  	_MNX $(T) : $(_s) ;
	  }
	  _USETOOL $(T) : ercompile_v1$(SUFEXE) ;

	  DEPENDS files : $(T) ;
	  DEPENDS $(T) : $(_s) ;

	  ERCOMPILE on $(T) = ercompile_v1 ;
	  ERCOMPFLAGS on $(T) = $(ERCOMPFLAGS_v1) ;
	  SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	  Clean clean : $(T) ;
	}
}

rule IIFECAT
{

	_MKFECAT $(<) ;
	if $(NT)
	{
	_USETOOL $(<) : mkfecat.bat ;
	}
	else
	{
	_USETOOL $(<) : mkfecat$(SUFXSH) ;
	}

	LOCATE on $(<) = $(SEARCH_SOURCE) ;
}

	
rule IIMSGDOC
{
	T = $(INGMESSAGE)$(DFS)$(<) ; S = $(<) ;

	_YAPPFILE $(T) : $(S) ;
    if $(VMS)
    {
	YAPPFLAGS on $(T) = \"-DVMS\" \"-H##\" ;
    }
    else
    {
	YAPPFLAGS on $(T) = "-H##" ;
    }

	DEPENDS files : $(T) ;
	DEPENDS $(T) : $(S) ;
	SEARCH on $(S) = $(SEARCH_SOURCE) ;
	LOCATE on $(T) = $(INGMESSAGE) ;
}

rule IIMSGTXT
{
    if ! $(NT)
    {
	_MSGTXT $(<) : $(>) ;
    }
    else
    {
        _MSGTXTW $(<) : $(>) ;
    }

	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;

	SEARCH on $(>) = $(HDRCOMMON) $(MSGDIRS:R=$(ING_CODE)) ;
	LOCATE on $(<) = $(INGMESSAGE) ;
	Clean clean : $(<) ;
}

rule IIOSLHDR
{
	_OSLHDR $(<) : $(>) ;
	_USETOOL $(<) : yypp$(SUFXSH) yapp$(SUFEXE) ;

	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) bzarch.h ;
	SEARCH on bzarch.h = $(HDRCL) ;
	LOCATE on $(<) = $(INGFILES) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule IIPRT 
{
	for i in $(<)
	{
	  T = $(i:S=.prt) ; S = $(i) ;

	  IICCPPFILE $(T) : $(S) ;

	  DEPENDS files : $(T) ;
	  LOCATE on $(T) = $(INGMANIFEST) ;
   	  SEARCH on $(S) = $(SEARCH_SOURCE) ;
	}
}

rule IIPWD
{
	T = $(INGFILES)/iipwd/pwconfig.h $(<:S=.c) ;

	_BPWD $(T) ;
	_MKPWD $(<) ;

	_USETOOL $(T) : bvalidpw ;
	_USETOOL $(<) : mkvalidpw ;

	DEPENDS exe : $(<) ;
	DEPENDS $(<) : $(T) ;
	DEPENDS $(T) : $(<:S=.x) ;
	DEPENDS files : $(T) ;

	LOCATE on $(<:S=.x) = $(SEARCH_SOURCE) ;
	LOCATE on $(<:S=.c) = $(INGFILES)/iipwd ;
	LOCATE on $(<) = $(INGBIN) ;
}

rule IIQSHHDR
{
	LEAVES $(<) ;
	Eqh $(<:S=.sh) : $(>) ;
	Esqh $(<) : $(<:S=.sh) ;

	DEPENDS $(<) : $(>) ;
	DEPENDS hdrs : $(<) ;
        Clean clean : $(<) $(<:S=.sh) ;

	EQCFLAGS on $(<:S=.sh) = $(QSHTOSHFLAGS) ;
	LOCATE on $(<) $(<:S=.sh) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(<) $(<:S=.sh) ;
if $(VERSHB)
{
	Eqh $(SUFHB)$(DFS)$(<:S=.sh) : $(>) ;
	Esqh $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(<:S=.sh) ;

	DEPENDS $(SUFHB)$(DFS)$(<) : $(>) ;
	DEPENDS hdrs : $(SUFHB)$(DFS)$(<) ;

	EQCFLAGS on $(SUFHB)$(DFS)$(<:S=.sh) = $(QSHTOSHFLAGS) ;
	LOCATE on $(SUFHB)$(DFS)$(<) $(<:S=.sh) = $(SEARCH_SOURCE) ;
	SEARCH on $(SUFHB)$(DFS)$(>) = $(SEARCH_SOURCE) ;
	Depends $(SUFHB)$(DFS)$(<:S=.sh) : $(SEARCH_SOURCE)$(DFS)$(SUFHB) ;
	MkDir $(SEARCH_SOURCE)$(DFS)$(SUFHB) ;

	Clean clean : $(SUFHB)$(DFS)$(<) $(<:S=.sh)$(DFS)$(SUFHB) ;
}
}

rule IISHHDR
{
	#if ! $(NT)
	#{
	Esqh $(<) : $(>) ;
	#}
	#else
	#{
		#for _o in $(>)	
		#{
		#	_g = [ FGristFiles $(_o:S=$(SUFOBJ)) ] ;
		#	switch $(_g)
		#	{
		#	case *dbutil*duf*hdr*   : CCSHW $(<) : $(>) ;
		#	case *	: CCSC $(<) : $(>) ;	
		#	}
		#}
	
	#}

	DEPENDS $(<) : $(>) ;
	DEPENDS hdrs : $(<) ;
        Clean clean : $(<) ;

	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(<) ;
}

rule IIQHHDR
{
	Eqh $(<) : $(>) ;

	DEPENDS $(<) : $(>) ;
	DEPENDS hdrs : $(<) ;
        Clean clean : $(<) ;

	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(<) ;
}

rule IIDUFSHHDR
{
	if ! $(NT)
	{
	CCDUFSH $(<) : $(>) ;
	}
	else
	{
	CCDUFSHW $(<) : $(>) ;
	}

	DEPENDS $(<) : $(>) ;
	DEPENDS hdrs : $(<) ;
        Clean clean : $(<) ;

	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(<) ;
}

rule IIAIFHDR
{
	AIFHDR $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : readvers$(SUFXSH) ccpp$(SUFXSH) ;
	}
	else
	{
	_USETOOL $(<) : ccpp.bat ;
	}
	DEPENDS $(<) : $(>) ;
	DEPENDS hdrs : $(<) ;
	
	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(<) ;
}

rule IIRELDAT
{
     if $(UNIX)
     {
        _SEDREL $(<) : $(>) ;
     }
     else
     {
	_YYPP $(<) : $(>) ;
     }
     if $(VMS)
     {
	YAPPFLAGS on $(<) = -DVMS ;
     }
     else
     {
	YAPPFLAGS on $(<) = -DUNIX ;
     }

	_USETOOL $(<) : yypp$(SUFXSH) yapp$(SUFEXE) ;
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;

	LOCATE on $(<) = $(INGMANIFEST) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	Clean clean : $(<) ;
}

rule IITIMEZONE
{
	T = $(INGZONE)$(DFS)tz.stamp ; S = $(<) ;

	_TIMEZONE $(T) : $(S) ;
	_USETOOL $(T) : iizic$(SUFEXE) ; 

	DEPENDS files : $(T) ;
	DEPENDS $(T) : $(S) ;

	SEARCH on $(S) = $(SEARCH_SOURCE) ;

if $(VERSHB)
{
	T = $(INGZONE)$(DFS)$(SUFHB)$(DFS)tz.stamp ; S = $(<) ;
	_TIMEZONEHB $(T) : $(S) ;
	_USETOOL $(T) : $(SUFHB)$(DFS)iizic$(SUFEXE) ; 
	DEPENDS files : $(T) ;
	DEPENDS $(T) : $(S) ;
	SEARCH on $(S) = $(SEARCH_SOURCE) ;
	Depends $(T) : $(INGZONE)$(DFS)$(SUFHB) ;
	MkDir $(INGZONE)$(DFS)$(SUFHB) ;
}
}

rule IIUDTDEF
{
    DEPENDS files : $(<) ;
    FILE $(<:D=$(SEARCH_SOURCE)) : $(>) ;
    FILE $(UDTDEMO)/$(<) : $(>) ;

    SEARCH on $(>) = $(INGDEFS) ;
}

rule IIUDTOBJECT
{
	for i in $(<)
	{
          if ! $(NT)
          {
	      Depends files : $(i:S=$(SUFOBJ)) ;
	      UDTOBJECT $(i:S=$(SUFOBJ)) : $(i) ;
	      Depends $(i:S=$(SUFOBJ)) : $(INGFILES)$(DFS)iiadd.h
					 $(UDTDEMO)$(DFS)udt.h ;
	      LOCATE on $(i:S=$(SUFOBJ)) = $(UDTDEMO) ;
          }
          else
          {
	      DEPENDS files : $(i:S=$(SUFOBJ)) ;
	      UDTOBJECT $(i:S=$(SUFOBJ)) : $(i) ;
	      DEPENDS $(i:S=$(SUFOBJ)) : $(UDTDEMO)/iiadd.h <common!adf!admin>udt.h ;
	      SEARCH on udt.h = $(UDTDEMO) ;
	      LOCATE on $(i:S=$(SUFOBJ)) = $(UDTDEMO) ;
          }
	}

if $(VERSHB)
{
	for i in $(<)
	{
	    DEPENDS files : $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) ;
	    UDTOBJECT $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) : $(i) ;
	    if ! $(NT)
	    {
	    	DEPENDS $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) : $(INGFILES)$(DFS)iiadd.h $(UDTDEMO)$(DFS)udt.h ;
	    }
	    else
	    {
		DEPENDS $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) : $(UDTDEMO)/iiadd.h <common!adf!admin>udt.h ;		
	    }
	    LOCATE on $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) = $(UDTDEMO) ;
	    CCFLAGS on $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) = $(CCFLAGSHB) ;
	    Depends $(SUFHB)$(DFS)$(i:S=$(SUFOBJ)) : $(UDTDEMO)$(DFS)$(SUFHB) ;
	    MkDir $(UDTDEMO)$(DFS)$(SUFHB) ;
	}
}
}

rule IILIBOBJECT
{
     if $(NT) || $(VMS)
     {
	for i in $(<)
	{
		local _t = $(i:S=$(SUFOBJ)) ;
		switch $(i)
		{
			case oosymbol* : i = [ FGristFiles $(i) ] ;
		}
		
		DEPENDS files : $(_t) ;
		LIBOBJECT $(_t) : $(i) ;
		LOCATE on $(_t) = $(INGLIB) ;
		Clean clean : $(_t) ;

		if $(VERSHB)
		{
			_t = $(SUFHB)$(DFS)$(i:S=$(SUFOBJ):G=) ;
			switch $(i)
			{
				case $(SUFHB)$(DFS)oosymbol* : i = [ FGristFile $(SUFHB)$(DFS)$(i) ] ;
			}
			DEPENDS files : $(_t) ;
			LIBOBJECT $(_t) : $(i) ;
			LOCATE on $(_t) = $(INGLIB) ;
			CC on $(_t) = $(CC32) ;
			CCFLAGS on $(_t) = $(CCFLAGSHB) ;

			Clean clean : $(_t) ;
		}	
	}
     }

}

rule IIAbfObj
{
    if $(UNIX)
    {
        for i in $(<)
        {
		local _tmp = $(i:S=$(SUFOBJ)) ;
                local _t = $(i:S=.obj) ;

                LIBOBJECT $(_tmp) : $(i) ;
		FILE $(_t) : $(_tmp) ;

		DEPENDS $(_t) : $(_tmp) ;
                DEPENDS files : $(_t) ;
		LOCATE on $(_tmp) = $(SEARCH_SOURCE) ;
                LOCATE on $(_t) = $(INGLIB) ;
		RmTemps $(_t) : $(_tmp) ;
                Clean clean : $(_t) ;
        }
    }
    else
    {
        IILIBOBJECT $(<) ;
    }
}

rule IILIBBOOTOBJECT
{
	for i in $(<)
	{
		local _t = $(i:S=$(SUFOBJ)) ;
		DEPENDS boot : $(_t) ;
		LIBOBJECT $(_t) : $(i) ;
		LOCATE on $(_t) = $(INGLIB) ;	
	}
}

rule IIUdtShLib
{
    local _t = $($(<)) ;
    local _s = [ FGristFiles $(>) ] ;
    Main $(_t) : $(>) ;

    IICCFLAGS $(>) : OPTIM ;
    IICCFLAGS $(>) : CCPICFLAG ;
    IICCFLAGS $(>) : CCVERSFLAG ;

    LINKFLAGS on $(_t) = $(CCSHLDMACH) ;
    LINK on $(_t) = $(SHLIBLD) ;
    if ( $(<) = SHSPATLIB ) && $(VERS64) = r64_us5
    {
      LINKLIBS on $(_t) = $(LDLIBMACH) ;
    }

    switch $(<)
    {
	case *SPAT* : LOCATE on $(_t) = $(INGLIB) ;
        case * : LOCATE on $(_t) = $(UDTDEMO) ;
    }

    if $(VERSHB)
    {
    local _o = $(>:S=$(SUFOBJ)) ;

    MainHB $(_t) : $(>) ;

    IICCFLAGS $(SUFHB)$(DFS)$(_o) : OPTIM ;
    IICCFLAGS $(SUFHB)$(DFS)$(_o) : CCPICFLAG ;
    IICCFLAGS $(SUFHB)$(DFS)$(_o) : CCVERSFLAGHB ;

    if $(CCSHLDMACHHB) = ""
    {
	echo "CCSHLDMACHHB is not set, please set CCSHLDMACH64 or" ;
	echo "CCSHLDMACH32 in Jamdefs.$(PLATFORM_JAMDEFS)" ;
    }
    LINKFLAGS on $(SUFHB)$(DFS)$(_t) = $(CCSHLDMACHHB) ;

    LINK on $(SUFHB)$(DFS)$(_t) = $(SHLIBLD) ;

    if ( $(<) = SHSPATLIB ) && $(VERS64) = r64_us5
    {
      LINKLIBS on $(SUFHB)$(DFS)$(_t) = $(LDLIBMACHHB) ;
    }

    DEPENDS $(SUFHB)$(DFS)$(_o) : $(UDTDEMO)$(DFS)$(SUFHB) ;
    MkDir $(UDTDEMO)$(DFS)$(SUFHB) ;

    switch $(<)
    {
	case *SPAT* : LOCATE on $(SUFHB)$(DFS)$(_t) = $(INGLIB) ;
        case * : LOCATE on $(SUFHB)$(DFS)$(_t) = $(UDTDEMO) ;
    }

    }

}

rule IIUdtArLib
{
    local _t = $($(<)) ;
    local _s = [ FGristFiles $(>) ] ;
    LIBRARY $(_t) : $(>) ;
    for _p in $(>)
      {
        local _s = [ FGristFiles $(_p) ] ;
        OPTIM on $(_s:S=$(SUFOBJ)) ?= $(IIOPTIM) ;
      }

    IICCFLAGS $(>) : OPTIM ;
    IICCFLAGS $(>) : CCPICFLAG ;
    IICCFLAGS $(>) : CCVERSFLAG ;

    switch $(<)
    {
	case *SPAT* : LOCATE on $(_t) = $(INGLIB) ;
        case * : LOCATE on $(_t) = $(UDTDEMO) ;
    }
    MODE on $(_t) = $(FILEMODE) ;
    Chmod $(_t) ;

}

rule IIUDTIIADD
{
    if ! $(NT)
    {
	T = $(INGFILES)$(DFS)$(<) ;

	DEPENDS files : $(T) ;
	DEPENDS $(T) : $(<) bzarch.h ;
	SEARCH on bzarch.h = $(HDRCL) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	
        _UDTIIADD $(T) : $(<) ;
    }
    else
    {
        T = $(UDTDEMO)/$(<) ;

        DEPENDS files : $(T) ;
        DEPENDS $(T) : $(<) ;
        SEARCH on $(<) = $(SEARCH_SOURCE) ;

        _UDTIIADDW $(T) : $(<) ;
    }
}

rule IIUDTPPFILE
{
	local _t = [ FGristFiles $(>) ] ;
	_YYPP $(<) : $(_t) ;

	_USETOOL $(<) : yypp$(SUFXSH) yapp$(SUFEXE) ;
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(_t) ;

	LOCATE on $(<) = $(UDTDEMO) ;
	LOCATE on $(_t) = $(SEARCH_SOURCE) ;
}

rule IIUSERADT
{
	local _t = $(<:S=$(SUFOBJ)) ;
	local _s = $(<) ;

	Object $(_t) : $(_s) ;

	if ! $(NT)
	{
	DEPENDS iimerge : $(_t) ;
	}
	else
	{
	DEPENDS $(SHUDTLIB) : $(_t) ;
	}
	LOCATE on $(_t) = $(INGLIB) ; # override LOCATE done by Object
	MODE on $(_t) = $(LIBMODE) ;
	Chmod $(_t) ;

	if $(VERSHB)
	{
	Object $(SUFHB)$(DFS)$(_t) : $(_s) ;
	if ! $(NT)
	{
	DEPENDS $(SUFHB)/iimerge : $(SUFHB)/$(_t) ;
	}
	else
	{
	DEPENDS $(SHUDTLIBHB) : $(SUFHB)$(DFS)$(_t) ;
	}
	CCFLAGS on $(SUFHB)$(DFS)$(_t) = $(CCFLAGSHB) ;
	LOCATE on $(SUFHB)$(DFS)$(_t) = $(INGLIB) ; # override LOCATE done by Object
	MODE on $(SUFHB)$(DFS)$(_t) = $(LIBMODE) ;

	Chmod $(SUFHB)$(DFS)$(_t) ;
	Depends $(SUFHB)$(DFS)$(_t) : $(INGLIB)$(DFS)$(SUFHB) ;
	MkDir $(INGLIB)$(DFS)$(SUFHB) ;
	}
}

rule IICLSADT
{
	local _t = $(<:S=$(SUFOBJ)) ;
	local _s = $(<) ;

	Object $(_t) : $(_s) ;
	if ! $(NT)
	{
	DEPENDS iimerge : $(_t) ;
	}
	else
	{
	DEPENDS $(SHUDTLIB) : $(_t) ;
	}
	LOCATE on $(_t) = $(INGLIB) ; # override LOCATE done by Object
	MODE on $(_t) = $(LIBMODE) ;
	Chmod $(_t) ;

	if $(VERSHB)
	{
	Object $(SUFHB)$(DFS)$(_t) : $(_s) ;
	if ! $(NT)
	{
	DEPENDS $(SUFHB)/iimerge : $(SUFHB)/$(_t) ;
	}
	else
	{
	DEPENDS $(SHUDTLIBHB) : $(SUFHB)$(DFS)$(_t) ;
	}
	CCFLAGS on $(SUFHB)$(DFS)$(_t) = $(CCFLAGSHB) ;
	LOCATE on $(SUFHB)$(DFS)$(_t) = $(INGLIB) ; # override LOCATE done by Object
	MODE on $(SUFHB)$(DFS)$(_t) = $(LIBMODE) ;

	Chmod $(SUFHB)$(DFS)$(_t) ;
	Depends $(SUFHB)$(DFS)$(_t) : $(INGLIB)$(DFS)$(SUFHB) ;
	MkDir $(INGLIB)$(DFS)$(SUFHB) ;
	}
}

rule IIUTLD
{
	_UTLD $(<) : $(>) ;

	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;

	_USETOOL $(<) : yypp$(SUFXSH) yapp$(SUFEXE) ;
	LOCATE on $(<) = $(INGFILES) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule IIUUENCODELIB
{
	if $($(<))
	{
	  _UUENCODELIB $($(<)) : $(>) ;

	  DEPENDS lib : $($(<)) ;
	  DEPENDS $($(<)) : $(>) ;

	  SEARCH on $(>) = $(SEARCH_SOURCE) ;
	  LOCATE on $($(<)) = $(INGLIB) ;
	}
}

rule _HDRSQSC
{
	switch $(<:S)
	{
	  case .qsh : EQCFILE = $(<:S=.sh) ; ESQLCFILE = $(<:S=.h) ; 
	  case .qsc : EQCFILE = $(<:S=.sc) ; ESQLCFILE = $(<:S=.c) ; 
	  case .sh  : ESQLCFILE = $(<:S=.h) ; 
	  case .sc  : ESQLCFILE = $(<:S=.c) ; 
	  case .qh  : EQCFILE = $(<:S=.h) ; 
	  case .qc  : EQCFILE = $(<:S=.c) ;
	}

        if $(NOREBUILD) { NOUPDATE $(EQCFILE) $(ESQLCFILE) ; }

	for i in $(>)
	{
	  switch $(i:S) 
	  {
	    case .qsh : HDRRULE $(<) : $(i) ;
	                HDRRULE $(EQCFILE) : $(i:S=.sh) ;
	                HDRRULE $(ESQLCFILE) : $(i:S=.h) ;
	    case .sh  : HDRRULE $(<) : $(i) ;
	                HDRRULE $(ESQLCFILE) : $(i:S=.h) ;
	    case .qh  : HDRRULE $(<) : $(i) ;
	                HDRRULE $(EQCFILE) : $(i:S=.h) ;
	    case .h   : HDRRULE $(<) : $(i) ;
	  }

	  switch $(i)
	  {
       	    case SQLDA : INCLUDES $(<) : $(EQSQLDA) ;
    	    case sqlda : INCLUDES $(<) : $(EQSQLDA) ;
	    case SQLCA : INCLUDES $(<) : $(EQSQLCA) ;
	    case sqlca : INCLUDES $(<) : $(EQSQLCA) ;
	  }
       }

	# Make sure we can find them
	LOCATE on $(EQSQLCA) = $(INGFILES) ;
	LOCATE on $(EQSQLDA) = $(INGFILES) ;

}

rule _YAPPFILE
{
	_USETOOL $(<) : yapp$(SUFEXE) ;
}

rule _USETOOL
{
  DEPENDS tools : $(>) ;

  if $(USETOOL) != "false"
  {
    DEPENDS $(<) : $(>) ;

    SEARCH on $(>) = $(INGTOOLSBIN) $(INGBIN) $(INGUTIL) $(VECBIN) ;
    SEARCH on $(VERSFILE) = $(CONFDIR) ;
    SEARCH on CONFIG = $(CONFDIR) ;
    if $(NOREBUILD) { NOUPDATE $(<) ; }

    # some tools require other tools and files
    # eqc actually generates files that include eqdef.h
    for t in $(>)
    {
      switch $(t)
      {
	case align*    : DEPENDS align : generic.h ;
	case mksecret* : DEPENDS $(<) : $(VERSFILE) ;
	case mkgeneric* : DEPENDS $(<) : $(VERSFILE) ;
	case readvers* : DEPENDS $(<) : $(VERSFILE) ;
        case inglink* : DEPENDS $(<) : $(VERSFILE) ;
        case eqmerge* : DEPENDS $(<) : $(IYACCPAR) ;
        case byacc*   : DEPENDS $(<) : $(BYACCPAR) ;
        case iyacc*   : DEPENDS $(<) : $(IYACCPAR) ;
        case esqlc*   : DEPENDS $(<) : $(SLOWMNX) $(FASTMNX) msghdrs ;
        case eqc*     : DEPENDS $(<) : $(SLOWMNX) $(FASTMNX) msghdrs ;
                       INCLUDES $(<) : $(EQDEF) ; 
        case ccpp*   : if $(NT) { DEPENDS $(<) : readvers.bat CONFIG ; }
		       else { DEPENDS $(<) : readvers$(SUFXSH) CONFIG ; }
		       DEPENDS $(t) : $(VERSFILE) ;
      }
    }
  }

  if $(NT) && $(VERSHB) && $(>:S) = $(SUFEXE)
  {
  DEPENDS tools : $(SUFHB)$(DFS)$(>) ;

  if $(USETOOL) != "false"
  {
    DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(>) ;

    SEARCH on $(SUFHB)$(DFS)$(>) = $(INGTOOLSBIN) $(INGBIN) $(INGUTIL) $(VECBIN) ;
    #SEARCH on VERS = $(CONFDIR) ;
    #SEARCH on CONFIG = $(CONFDIR) ;
    if $(NOREBUILD) { NOUPDATE $(SUFHB)$(DFS)$(<) ; }
    #NOUPDATE VERS ;

    # some tools require other tools and files
    # eqc actually generates files that include eqdef.h
    for t in $(>)
    {
      switch $(t)
      {
	case align*    : DEPENDS align : generic.h ;
	case mksecret* : DEPENDS $(SUFHB)$(DFS)$(<) : VERS ;
	case mkgeneric* : DEPENDS $(SUFHB)$(DFS)$(<) : VERS ;
	case readvers* : DEPENDS $(SUFHB)$(DFS)$(<) : VERS ;
        case inglink* : DEPENDS $(SUFHB)$(DFS)$(<) : VERS ;
        case eqmerge* : DEPENDS $(SUFHB)$(DFS)$(<) : $(IYACCPAR) ;
        case byacc*   : DEPENDS $(SUFHB)$(DFS)$(<) : $(BYACCPAR) ;
        case iyacc*   : DEPENDS $(SUFHB)$(DFS)$(<) : $(IYACCPAR) ;
        case esqlc*   : DEPENDS $(SUFHB)$(DFS)$(<) : $(SLOWMNX) $(FASTMNX) msghdrs ;
        case eqc*     : DEPENDS $(SUFHB)$(DFS)$(<) : $(SLOWMNX) $(FASTMNX) msghdrs ;
                       INCLUDES $(SUFHB)$(DFS)$(<) : $(EQDEF) ; 
        case ccpp*   : if $(NT) { DEPENDS $(SUFHB)$(DFS)$(<) : readvers.bat CONFIG ; }
		       else { DEPENDS $(SUFHB)$(DFS)$(<) : readvers$(SUFXSH) CONFIG ; }
		       DEPENDS $(SUFHB)$(DFS)$(t) : VERS ;
      }
    }
  }
  }
}


# 
# UserObject x.o : x.suf - do user's special .o generation
#

rule UserObject
{
    switch $(>) 
    {
	  case *.roc : CCROC $(<) : $(>) ;
	  case *.qsc : CC $(<) : $(<:S=.c) ; CCQSC $(<:S=.c) : $(>) ; DEPENDS $(<) : $(>) ;
	  case *.sc : CC $(<) : $(<:S=.c) ; if $(NT) { CCSCW $(<:S=.c) : $(>) ; } else { CCSC $(<:S=.c) : $(>) ; } 
	  case *.qc : CC $(<) : $(<:S=.c) ; CCQC $(<:S=.c) : $(>) ;
	  case *.st : CC $(<) : $(<:S=.c) ; CCST $(<:S=.c) : $(>) ;
	  case *.sy : CC $(<) : $(<:S=.c) ; CCSY $(<:S=.c) : $(>) ;
	  case *.yf : CC $(<) : $(<:S=.c) ; CCIYACC $(<:S=.c) : $(>) ;
	  case *.yi : CC $(<) : $(<:S=.c) ; CCBYACC $(<:S=.c) : $(>) ;
	  #case *.lex : CC $(<) : $(<:S=.c) ; if $(NT) { if "$(<:D)" != "" && $(<:D) = $(SUFHB) { CCLEXWHB $(<:S=.c) : $(>) ; } else { CCLEXW $(<:S=.c) : $(>) ; } } else { Lex $(<:S=.c) : $(>) ; }
	  case *.lex : CC $(<) : $(<:S=.c) ; if $(NT) { CCLEXW $(<:S=.c) : $(>) ; } else { Lex $(<:S=.c) : $(>) ; }
	  #case *.lex : CC $(<) : $(<:S=.c) ; if $(NT) { CCLEXW $(<:S=.c) : $(>) ; } else { CCLEX $(<:S=.c) : $(>) ; }
	  case *.lfm : Clean clean : $(<:S=.c) ; CC $(<) : $(<:S=.c) ; CCLFM $(<:S=.c) : $(>) ;
	  case *.s : As $(<) : $(>) ;
	case *.m64 : As $(<) : $(>) ;
	case *.mar : AsMigr $(<) : $(>) ;
	case *.msg : VMSMsg $(<) : $(>) ;
	case * : Exit "Unknown suffix on " $(>) ;
    }
}

rule CCROC
{
	CCROFIX $(>:S=.c) : $(>) ;
	CC $(<) : $(>:S=.c) ;

	CCFLAGS on $(<) += $(CMPORTS) $(RROC) ;
	Clean clean : $(>:S=.c) ;
	if $(VERSHB) 
	{
	    if ! $(NT) { RmTemps $(<) : $(>:S=.c) ; }
	}

}

rule CCROFIX 
{
	DEPENDS $(<) : $(>) ;

	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
 	    
}


rule CCQSC
{
	LEAVES $(<) ;
	CCQC $(<:S=.sc) : $(>) ;
	CCSC $(<) : $(<:S=.sc) ;
	
	DEPENDS $(<) : $(>) ;

	EQCFLAGS on $(<:S=.sc) = $(QSHTOSHFLAGS) ;
	HDRSCAN on $(>) = $(EQLPATTERN) $(ESQLPATTERN) ;
}

rule CCSCW
{
	if $(NT)
	{
		local _o _g ;
		for _o in $(>)	
		{
			_g = [ FGristFiles $(_o:S=$(SUFOBJ)) ] ;
			switch $(_g:G)
			{
			case *front*abf*copyapp*   : CCSCO $(<) : $(>) ;
			case *	: CCSC $(<) : $(>) ;	
			}
		}
	}
	DEPENDS $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : esqlc$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) : esqlc.exe ;
	}
	HDRSCAN on $(>) = $(HDRPATTERN) $(ESQLPATTERN) ;
	HDRRULE on $(>) = _HDRSQSC ;
	HDRSEARCH on $(>) = $(HDRS) $(SEARCH_SOURCE) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	# esqlc limits us to 7 include directories:
	EQHDRS on $(<) = $(HDR1) $(HDR2) $(HDR3) $(HDRFRONT) ;

}
rule CCSHW 
{

	DEPENDS $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : esqlc$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) : esqlc.exe ;
	}
	HDRSCAN on $(>) = $(HDRPATTERN) $(ESQLPATTERN) ;
	HDRRULE on $(>) = _HDRSQSC ;
	HDRSEARCH on $(>) = $(HDRS) $(SEARCH_SOURCE) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	# esqlc limits us to 7 include directories:
	EQHDRS on $(<) = $(HDR1) $(HDR2) $(HDR3) $(HDRFRONT) ;


}

rule CCSC
{
	DEPENDS $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : esqlc$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) : esqlc.exe ;
	}
	HDRSCAN on $(>) = $(HDRPATTERN) $(ESQLPATTERN) ;
	HDRRULE on $(>) = _HDRSQSC ;
	HDRSEARCH on $(>) = $(HDRS) $(SEARCH_SOURCE) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	# esqlc limits us to 7 include directories:
	EQHDRS on $(<) = $(HDR1) $(HDR2) $(HDR3) $(HDRFRONT) ;
	Clean clean : $(<) ;
}

rule Esqh
{
	DEPENDS $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : esqlc$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) : esqlc.exe ;
	}
	HDRSCAN on $(>) = $(HDRPATTERN) $(ESQLPATTERN) ;
	HDRRULE on $(>) = _HDRSQSC ;
	HDRSEARCH on $(>) = $(HDRS) $(SEARCH_SOURCE) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	# esqlc limits us to 7 include directories:
	EQHDRS on $(<) = $(HDR1) $(HDR2) $(HDR3) $(HDRFRONT) ;
	Clean clean : $(<) ;
}

rule CcScToInc
{
	DEPENDS $(<) : $(>) ;
	_USETOOL $(<) : esqlc$(SUFEXE) ;
	ESQLCFLAGS on $(<) = $(ESQLCFLAGSMULTI) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	Clean clean : $(<) ;

}

rule CCQC
{
	DEPENDS $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : eqc$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) : eqc.exe ;
	}
	HDRSCAN on $(>) = $(EQLPATTERN) ;
	HDRRULE on $(>) = _HDRSQSC  ;
	HDRSEARCH on $(>) = $(HDRS) $(SEARCH_SOURCE) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	Clean clean : $(<) ;
	# eqc limits us to 7 include directories:
	EQHDRS on $(<) = $(HDR1) $(HDR2) $(HDR3) $(HDRFRONT) ;
}

rule Eqh
{
	DEPENDS $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : eqc$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) : eqc.exe ;
	}
	HDRSCAN on $(>) = $(EQLPATTERN) ;
	HDRRULE on $(>) = _HDRSQSC  ;
	HDRSEARCH on $(>) = $(HDRS) $(SEARCH_SOURCE) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	Clean clean : $(<) ;
	# eqc limits us to 7 include directories:
	EQHDRS on $(<) = $(HDR1) $(HDR2) $(HDR3) $(HDRFRONT) ;
}

rule CCBYACC
{
	switch $(>:B)
	{
	  case pslgram : YTAB = $(>:B=pslytab:S=.roc) ;
	  case pslsgram : YTAB = $(>:B=pslsytab:S=.roc) ;
	}

	h = $(<:BS=.h) ;

	if ! $(NT)
	{
	_USETOOL $(<) $(h) $(YTAB) : byacc$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) $(h) $(YTAB) : byacc.exe ;
	}
	if $(NT)
	{
	switch $(>:B)
	{
		case pslgram : CCBYACC1W $(<) $(h) $(YTAB) : $(>) ;
		case pslsgram : CCBYACC1WS $(<) $(h) $(YTAB) : $(>) ;
		case * : CCBYACC1W $(<) $(h) $(YTAB) : $(>) ;
	}
	}
	else
	{
	CCBYACC1 $(<) $(h) $(YTAB) : $(>) ;
	}
	DEPENDS $(<) $(h) $(YTAB) : $(>) ;

	# We don't want to include hdrs in the local directory
	HDRSCAN on $(>) = $(BYACCPATTERN) ;

	INCLUDES $(<) : $(h) ;
	LOCATE on $(h) = $(LOCATE_TARGET) ;
	LOCATE on $(<) $(YTAB) = $(LOCATE_TARGET) ;
	Clean clean : $(<) $(h) $(YTAB) ;
}

rule CCIYACC
{
	h = $(<:BS=.h) ;
	local _t ;
	if $(NT)
	{
		_USETOOL $(<) $(h) : iyacc.exe yycase.exe ;
		if "$(<:D)" != "" && $(<:D) = $(SUFHB)
		{
		CCIYACC1WHB $(<) $(h) : $(>) ;
		}
		else
		{
		CCIYACC1W $(<) $(h) : $(>) ;
		}
	}
	else
	{
		_USETOOL $(<) $(h) : iyacc$(SUFEXE) yycase$(SUFEXE) ;
		CCIYACC1 $(<) $(h) : $(>) ;
	}

	DEPENDS $(<) $(h) : $(>) ;

	INCLUDES $(<) : $(h) ;
	LOCATE on $(h) = $(LOCATE_TARGET) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	LOCATE on $(>) = $(LOCATE_TARGET) ;
	Clean clean : $(<) $(h) ;


}



rule CCLEXW
{
	DEPENDS $(<) : $(>) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	if "$(<:D)" != "" && $(<:D) = $(SUFHB)
	{
		CCLEXWHB $(<) : $(>) ;
	}
}

rule CCLFM
{
	DEPENDS $(<) : $(>) ;
	_USETOOL $(<) : compform$(SUFEXE) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;

	if $(VERSHB)
	{
	    DEPENDS $(<) : [ FDirName $(LOCATE_TARGET) $(SUFHB) ] ;
	    MkDir [ FDirName $(LOCATE_TARGET) $(SUFHB) ] ;
	}

	Clean clean : $(<) ;
}

rule CCSY
{
	local _s = $(>:G=$(SOURCE_GRIST)) ;
	CCSY2YF $(<:S=.yf) : $(_s) ;
	CCIYACC $(<) : $(<:S=.yf) ;
	HDRM on $(<) = $(HDRM) ;
}

rule CCSY2YF
{
	EQMRGTYPE on $(<) = grammar ;

	if $(NT)
	{
                CCEQMRGW $(<) : $(>) ;
	}
	else
	{
		CCEQMRG $(<) : $(>) ;	
	}
}

rule CCST
{
	EQMRGTYPE on $(<) = tokens ;

	if $(NT)
	{
		CCEQMRGW $(<) : $(>) ;
	}
	else
	{
		CCEQMRG $(<) : $(>) ;
	}
}

rule CCEQMRG
{
        local _files = [ GLOB $(HDRM) : *.my *.mt ] ;

	DEPENDS $(<) : $(>) $(_files) ;
	if ! $(NT)
	{
	_USETOOL $(<) : eqmerge$(SUFEXE) ;
	}
	else 
	{
	_USETOOL $(<) : eqmerge.exe ;
	}
	HDRM on $(<) = $(HDRM) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	Clean clean : $(<) ;
}

rule CCEQMRGW
{
	DEPENDS $(<) : $(>) ;
	if ! $(NT)
	{
	_USETOOL $(<) : eqmerge$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(<) : eqmerge.exe ;
	}
	HDRM on $(<) = $(HDRM) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	Clean clean : $(<) ;
}

rule VMSMsg
{
    if ! $(VMS)
    {
	Echo "Unknown suffix on " $(>) ;
    }
    Depends $(<) : $(>) ;
    Clean clean : $(<) ;
}

rule IILINKS
{
	for i in $(<)
	{
	  _LINK $(i) : $(>) ;

	  DEPENDS files : $(i) ;
	  DEPENDS $(i) : $(>) ;

	  SEARCH on $(>) = $(INGBIN) ;
	  LOCATE on $(i) = $(INGBIN) ;
	}
}

rule IILIBEXE
{
    MAIN $(<) : $(>) ; 
    LOCATE on $(<) = $(INGLIB) ; 
    EXEMODE on $(<) = $(FILEMODE) ;
    LINKFLAGS on $(<) = $(CLNTTCP) $(CLNTUDP) $(PMAPRMT) $(SVC)
			$(SVCRUN) $(SVCTCP) ;

    LINKLIBS on $(<) = ;
    LINK on $(<) = ld -r $(CCLDSERVER) ;
    IICCFLAGS $(>:S=$(SUFOBJ)) : IIOPTIM ;
    IICCFLAGS $(>:S=$(SUFOBJ)) : CCPICFLAG ;

if $(VERSHB)
{
    MainHB $(<) : $(>) ;
    LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
    EXEMODE on $(SUFHB)/$(<) = $(FILEMODE) ;
    LINKFLAGS on $(SUFHB)/$(<) = $(CLNTTCP) $(CLNTUDP) $(PMAPRMT) 
				$(SVC) $(SVCRUN) $(SVCTCP) ;

    LINKLIBS on $(SUFHB)/$(<) = ;
    LINK on $(SUFHB)/$(<) = ld -r $(CCLDSERVERHB) ;
    IICCFLAGS $(SUFHB)/$(>:S=$(SUFOBJ)) : IIOPTIM ;
    IICCFLAGS $(SUFHB)/$(>:S=$(SUFOBJ)) : CCPICFLAG ;
    Depends $(<) : $(INGBIN)/$(SUFHB) ;
    MkDir $(INGBIN)/$(SUFHB) ;
}
}
    
rule IILIBINGRES
{
  DEPENDS files : $($(<)) ;
  if ! $(NT)
  {
	# ULFLIB (libulf.a) is needed because mergelibs extracts ultrace.o
	# from it -- the rest of libulf is backend stuff.
	DEPENDS $($(<)) : $(ABFRTLIB) $(ADFLIB) $(AFELIB) $(COMPATLIB)
                    $(CUFLIB) $(FDLIB) $(FEDSLIB) $(FMTLIB) $(FTLIB) $(GCFLIB)
                    $(GENERATELIB) $(IAOMLIB) $(ILRFLIB) $(MTLIB) $(APILIB)
                    $(IOILIB) $(INTERPLIB) $(RAATLIB) $(LIBQLIB) $(LIBQGCALIB)
                    $(LIBQSYSLIB) $(LIBQXALIB) $(RUNSYSLIB) $(RUNTIMELIB)
                    $(SQLCALIB) $(UFLIB) $(UGLIB) $(UILIB) $(OOLIB) $(ULFLIB) ;
	if $(BUILD_ICE)
	{
	    DEPENDS $($(<)) : $(DDFLIB) $(ICECLILIB) ;
	}
  }
  else
  {
  DEPENDS $($(<)) : $(INGRES_LIBS) ;
  }
  if ! $(NT)
  {
  _USETOOL $($(<)) : mergelibs ;

  _LIBINGRES $($(<)) ;
  }
  else
  {
  _LIBINGRESW $($(<)) : $(INGRES_LIBS) $(TERMDR) ;
  LOCATE on $($(<)) = $(INGLIB) ;
  Clean clean : $($(<)) ;
  }
  
  if $(NT)
  {
  if $(VERSHB)
  {
	DEPENDS files : $($(<)HB) ;
	DEPENDS $($(<)HB) : $(SUFHB)$(DFS)$(INGRES_LIBS) ;

	_LIBINGRESW $($(<)HB) : $(SUFHB)$(DFS)$(INGRES_LIBS) $(SUFHB)$(DFS)$(TERMDR) ;
	LOCATE on $($(<)HB) = $(INGLIB) ;
	Clean clean : $($(<)HB) ;
  }
  }
  if $(VERSHB) && ! $(NT)
  {
  	DEPENDS files : $($(<)HB) ;
	DEPENDS $($(<)HB) : $(ABFRTLIBHB) $(ADFLIBHB) $(AFELIBHB) $(COMPATLIBHB)
		$(CUFLIBHB) $(FDLIBHB) $(FEDSLIBHB) $(FMTLIBHB) $(FTLIBHB) $(GCFLIBHB)
		$(GENERATELIBHB) $(IAOMLIBHB) $(ILRFLIBHB) $(MTLIBHB) $(APILIBHB)
		$(IOILIBHB) $(INTERPLIBHB) $(RAATLIBHB) $(LIBQLIBHB) $(LIBQGCALIBHB)
		$(LIBQSYSLIBHB) $(LIBQXALIBHB) $(RUNSYSLIBHB) $(RUNTIMELIBHB)
		$(SQLCALIBHB) $(UFLIBHB) $(UGLIBHB) $(UILIBHB) $(OOLIBHB) $(ULFLIBHB) ;
	if $(BUILD_ICE)
	{
	    DEPENDS $($(<)HB) : $(DDFLIBHB) $(ICECLILIBHB) ;
	}

	  _USETOOL $($(<)HB) : mergelibs ;

  	  _LIBINGRES64 $($(<)HB) ;
  	  Clean clean : $($(<)HB) ;
  }
}

rule IIMERGELIB
{
	DEPENDS files : $($(<)) ;
	DEPENDS $($(<)) : $($(>)) ;
	_IIMERGELIB $($(<)) : $($(>)) ;
	if $(RANLIB) { RANLIB $($(<)) ; }

	Clean clean : $($(<)) ;
}

rule IICCPPFILE
{

     local _t = [ FGristFiles $(>) ] ;
     local _tmp = $(_t:D=)_ ;
     #Replace PROGLOC etc.
     SEDCCPP $(_tmp) : $(_t) ;

     if ! $(NT)
     {
	if $(VMS)
	{
	    Depends $(_tmp) : $(INGTOOLSLIB)sedccpp.sed ;
	}

	# Run ccpp
	IICCPP $(<) : $(_tmp) ;

	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(_tmp) ;
	DEPENDS $(_tmp) : $(_t) ;

	_USETOOL $(_tmp) : shlibinfo$(SUFXSH) readvers$(SUFXSH) ccpp$(SUFXSH) ;

	SEARCH on $(_t)  = $(SEARCH_SOURCE) ;
	SEARCH on $(_tmp)  = $(SEARCH_SOURCE) ;
	LOCATE on $(_tmp)  = $(SEARCH_SOURCE) ;
	RmTemps $(<) : $(_tmp) ;
	Clean clean : $(<) ;
     }
     else
     {

	# Run ccpp
	IICCPPW $(<) : $(_tmp) ;

	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(_tmp) ;
	DEPENDS $(_tmp) : $(_t) ;
	DEPENDS $(_tmp) : ccpp.bat ;

	_USETOOL $(<) : readvers.bat ccpp.bat ;

	SEARCH on $(_t) = $(SEARCH_SOURCE) ;
	SEARCH on $(_tmp) = $(SEARCH_SOURCE) ;
	LOCATE on $(_tmp) = $(SEARCH_SOURCE) ;
	#SEARCH on $(>)  = $(SEARCH_SOURCE) ;


	RmTemps $(<) : $(_tmp) ;
	Clean clean : $(INGFILES)/$(<:D=) $(_tmp) ;
     }


}
rule IIDEFHDR
{
	DEFHDRW $(<) : $(>) ;
	DEPENDS files : $(<) ;
	DEPENDS hdrs : $(<) ;
        Clean clean : $(<) ;
	DEPENDS $(<) : $(>) ;

	LOCATE on $(<) = $(SEARCH_SOURCE) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;	
}

rule IIMAKEFILE
{
	DEPENDS $(<) : $(<S=.c) ;
	_USETOOL $(<) : $(MAKE) ;
}

rule UDTHDRRULE
{
	INCLUDES $(<) : $(>) ;
	SEARCH on $(>) = $(HDRSEARCH) ;

	# Propagate on $(<) to $(>)
	HDRSEARCH on $(>) = $(HDRSEARCH) ;
	HDRSCAN on $(>) = $(HDRSCAN) ;
	HDRRULE on $(>) = $(HDRRULE) ;
}

rule UDTOBJECT
{
	# locate object and search for source, if wanted
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	HDRS on $(<) = $(HDRS) ;

	UDTHDRRULE on $(>) = UDTHDRRULE ;
	HDRSCAN on $(>) = $(HDRPATTERN) ;
	HDRSEARCH on $(>) = $(HDRS) $(STDHDRS) ;
	MODE on $(<) = $(LIBMODE) ;

	CC $(<) : $(>) ;
	#Chmod $(<) ;
}

rule LIBOBJECT
{
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	HDRS on $(<) = $(HDRS) ;

	HDRSCAN on $(>) = $(HDRPATTERN) ;
	HDRSEARCH on $(>) = $(HDRS) $(STDHDRS) ;
	MODE on $(<) = $(LIBMODE) ;

	switch $(>) 
	{
		case *.c : 	CC $(<) : $(>) ;
		case *.roc :	UserObject $(<) : $(>) ;
	}
}

rule IIUCHARFILES
{
	Bulk $(INGUCHARMAPS) : $(<) ;
	Clean clean : $(INGUCHARMAPS)$(DFS)$(<) ;

if $(VERSHB)
{
	BULK $(INGFILES)$(DFS)ucharmaps$(DFS)$(SUFHB) : $(<) ;
    	Depends $(<) : $(INGFILES)$(DFS)ucharmaps$(DFS)$(SUFHB) ;
    	MkDir $(INGFILES)$(DFS)ucharmaps$(DFS)$(SUFHB) ;
	Clean clean : $(INGFILES)$(DFS)ucharmaps$(DFS)$(SUFHB)$(DFS)$(<) ;
}
}

rule IIUCHARMAP
{
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;

	LOCATE on $(<) = $(INGUCHARMAPS) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	_USETOOL $(<) : unimapcompile ;

	Clean clean : $(<) ;

if $(VERSHB)
{
	local _t64 = $(SUFHB)$(DFS)$(<:B) ;
	DEPENDS files : $(_t64) ;
	DEPENDS $(_t64) : $(>) ;

	Depends $(_t64) : $(<:D)$(DFS)$(SUFHB) ;
	MkDir $(<:D)$(DFS)$(SUFHB) ;

	LOCATE on $(_t64) = $(INGFILES)$(DFS)ucharmaps ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	if $(NT)
	{
	_USETOOL $(_t64) : $(SUFHB)$(DFS)unimapcompile$(SUFEXE) ;
	}
	else
	{
	_USETOOL $(_t64) : $(SUFHB)$(DFS)unimapcompile ;
	}

	_IIUCHARMAPHB $(_t64) : $(>) ;

	Clean clean : $(_t64) ;
}
}

rule IIUCHARALIAS
{
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	_USETOOL $(<) : unialscompile ;

	Clean clean : $(<) ;
if $(VERSHB)
{
	local _t64 = $(SUFHB)$(DFS)$(<:B) ;
	DEPENDS files : $(_t64) ;
	DEPENDS $(_t64) : $(>) ;

	Depends $(_t64) : $(<:D)$(DFS)$(SUFHB) ;
	MkDir $(<:D)$(DFS)$(SUFHB) ;

	LOCATE on $(_t64) = $(INGFILES)$(DFS)ucharmaps ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	_USETOOL $(_t64) : $(SUFHB)$(DFS)unialscompile$(SUFEXE) ;

	_IIUCHARALIASHB $(_t64) : $(>) ;

	Clean clean : $(_t64) ;
}
}

rule IIXERCLIB
{
	if ! $(NT)
	{
	    local _t1 = $(<) ;
	    local _t2 = $(INGLIB)/$(XERCESCLIB) ;
	    if $(VERS) = ppc_osx || $(VERS) = int_osx
	    {
		switch $(XERCVERS)
		{
		    case 3*	: _t3 = $(<:S=.$(SLSFX)-$(XERCVERS))  ;
		    case *	: _t3 = $(<:S=.$(SLSFX).$(XERCVERS).0)  ;
		}
	    }
	    else
	    {
		_t3 = $(<:S=.$(SLSFX).$(XERCVERS)) ;
	    }

	    FILE $(_t2) : $(XERCESLOC)/$(XERCESCLIB) ;
	    IISYMLINK $(_t1) : $(XERCESCLIB) ;
	    DEPENDS shlibs : $(_t1) ;
	    IISYMLINK $(_t3) : $(XERCESCLIB) ;

	    DEPENDS $(_t3) : $(XERCESCLIB) ;
	    DEPENDS $(_t1) : $(_t3) ;
	    LOCATE on $(_t3) = $(INGLIB) ;

	    LOCATE on $(_t1) = $(INGLIB) ;
	    SEARCH on $(XERCESCLIB) = $(XERCESLOC) ;
	}
	else
	{

	    # Following 3 statements may be removed if the files 
	    # are not required in these locations.
	    _IICOPYFILE $(XERCESCLIB:BS) : $(XERCESCROOT)/bin/$(XERCESCLIB:BS) ;
	    _IICOPYFILE $(SHXERCESLIB:BS) : $(XERCESLOC)/$(SHXERCESLIB:BS) ;

		DEPENDS $(<) : $(XERCESCLIB) ;
		LOCATE on $(<) = $(INGLIB) ;
		LOCATE on $(XERCESCLIB) = $(INGBIN) ;

		NOUPDATE $(XERCESCLIB) ;
		NOUPDATE $(SHXERCESLIB) ;

	    Clean clean : $(XERCESCLIB) $(SHXERCESLIB) ;
			  #$(INGBIN)/$(SHXERCESLIB) $(INGLIB)/$(XERCESCLIB) ;		


	    if $(VERSHB)
	    {

	    # Following 3 statements may be removed if the files 
	    # are not required in these locations.
	    _IICOPYFILE $(SUFHB)$(DFS)$(XERCESCLIB:BS) : $(XERCESCROOT32)$(DFS)bin$(DFS)$(XERCESCLIB:BS) ;
	    _IICOPYFILE $(SUFHB)$(DFS)$(SHXERCESLIB:BS) : $(XERCESLOC32)$(DFS)$(SHXERCESLIB:BS) ;

		DEPENDS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(XERCESCLIB) ;
		LOCATE on $(SUFHB)$(DFS)$(<) = $(INGLIB) ;
		LOCATE on $(SUFHB)$(DFS)$(XERCESCLIB) = $(INGBIN) ;

		NOUPDATE $(SUFHB)$(DFS)$(XERCESCLIB) ;
		NOUPDATE $(SUFHB)$(DFS)$(SHXERCESLIB) ;

	    Clean clean : $(SUFHB)$(DFS)$(XERCESCLIB) $(SUFHB)$(DFS)$(SHXERCESLIB) ;
			  #$(INGBIN)$(DFS)$(SHXERCESLIB) $(INGLIB)$(DFS)$(XERCESCLIB) ;		

		
	    }
	}	

	if ! $(NT)
	{
	MODE on $(INGLIB)/$(XERCESCLIB) = $(EXEMODE) ; 
	Chmod $(INGLIB)/$(XERCESCLIB) ;
	}

	Clean clean : $(<) $(<:S=.$(SLSFX).$(XERCVERS) $(INGLIB)/$(XERCESCLIB) ;

	if $(VERSHB) && ! $(NT)
	{
		# Jamdefs should have figured out a xerceslochb.
		XERCESCHBLIB = $(XERCESCLIB:G=hb) ;
		FILE $(INGLIB)/$(SUFHB)/$(XERCESCLIB) : $(XERCESCHBLIB) ;
		IISYMLINK $(SUFHB)/$(<) : $(INGLIB)/$(SUFHB)/$(XERCESCLIB) ;
		IISYMLINK $(SUFHB)/$(<:S=.$(SLSFX).$(XERCVERS)) : $(INGLIB)/$(SUFHB)/$(XERCESCLIB) ;

		DEPENDS $(SUFHB)/$(<:S=.$(SLSFX).$(XERCVERS)) : $(XERCESCHBLIB) ;
		DEPENDS $(SUFHB)/$(<) : $(SUFHB)/$(<:S=.$(SLSFX).$(XERCVERS)) ;
		DEPENDS shlibs : $(SUFHB)/$(<) ;
		LOCATE on $(SUFHB)/$(<) = $(INGLIB) ;
		LOCATE on $(SUFHB)/$(<:S=.$(SLSFX).$(XERCVERS)) = $(INGLIB) ;
		SEARCH on $(XERCESCHBLIB) = $(XERCESLOCHB) ;

		MODE on $(INGLIB)/$(SUFHB)/$(XERCESCLIB) = $(EXEMODE) ; 
		Chmod $(INGLIB)/$(SUFHB)/$(XERCESCLIB) ;

		Clean clean : $(SUFHB)/$(<) $(SUFHB)/$(<:S=.$(SLSFX).$(XERCVERS) $(INGLIB)/$(SUFHB)/$(XERCESCLIB) ;
	}
}

rule IIGeoLibs
{
    if $(NT)
    {
        geodeps_destination = $(INGBIN) ;
        geodeps_search_location = $(GEOSROOT)$(DFS)lib $(PROJROOT)$(DFS)lib ;
    }
    else if $(UNIX)
    {
        geodeps_destination = $(INGLIB) ;
        geodeps_search_location = $(GEOS_LOC) $(PROJ_LOC) ;
    }
    #not supported yet
    else
    {
        return ;
    }
    for f in $(<)
    {
        local _t1 = EMPTY ;
        if $(f:B) = libgeos
        {
	        _t1 = $(f:B)-$(GEOS_VERS).$(SLSFX) ;
        }
        else if $(f:B) = libgeos_c
        {
        	_t1 = $(f).$(GEOSC_VERS) ;
        }
        else if $(f:B) = libproj
        {
        	_t1 = $(f).$(PROJ_VERS) ;
        }
        if $(NT)
        {
        	_t1 = $(f) ;
        }
        local _t2 = $(f) ;
        local _s1 = [ FGristFiles $(_t1) ] ;

        FILE $(_t1) : $(_s1) ;
        
        #The libs must be copied before any utility that is linked with them
        #is run, otherwise it might not be able to find the .so files it needs
        #to function properly.
        DEPENDS $(ADFLIB) : $(_t1) ;
        
        LOCATE on $(_t1) = $(geodeps_destination) ;
        SEARCH on $(_s1) = $(geodeps_search_location) ;
        
        MODE on $(_t1) = $(EXEMODE) ;
        Chmod $(_t1) ;
        
        if ! $(NT)
        {
		    IISYMLINK $(_t2) : $(_t1) ;
	        DEPENDS $(_t1) : $(_t2) ;
	        LOCATE on $(_t2) = $(geodeps_destination) ;
	        Clean clean : $(_t1) $(_t2) ;
        }
        else
        {
        	Clean clean : $(_t1) ;
        }
        
        
        #deal with hybrid builds
        if $(VERSHB)
        {
            local _hbt1 = $(SUFHB)$(DFS)$(f) ;
            if $(f:B) = libgeos
            {
                _hbt1 = $(SUFHB)$(DFS)$(f:B)-$(GEOS_VERS).$(SLSFX) ;
            }
            else if $(f:B) = libgeos_c
            {
                _hbt1 = $(SUFHB)$(DFS)$(f).$(GEOSC_VERS) ;
	        }
            else if $(f:B) = libproj
            {
                _hbt1 = $(SUFHB)$(DFS)$(f).$(PROJ_VERS) ;
            }
            local _hbt2 = $(SUFHB)$(DFS)$(f) ;
            local _hbs1 = $(_t1:G=hb) ;

            FILE $(_hbt1) : $(_hbs1) ;
            IISYMLINK $(_hbt2) : $(_hbt1) ;

            DEPENDS $(ADFLIB) : $(_hbt1) ;
            DEPENDS $(_hbt1) : $(_hbt2) ;

            LOCATE on $(_hbt1) = $(INGLIB) ;
            LOCATE on $(_hbt2) = $(INGLIB) ;
            SEARCH on $(_hbs1) = $(GEOSHB_LOC) $(PROJHB_LOC) ;

            MODE on $(_hbt1) = $(EXEMODE) ;
            Chmod $(_hbt1) ;

            Clean clean : $(_hbt1) $(_hbt2) ;
        }
    }
}

rule IMPLIBRARY
{
    IMPLIBRARYFROMOBJECTS $(<) : $(>:S=$(SUFOBJ)) ;
    Objects $(>) ;
    Clean clean : $(<) ;

    #if $(VERSHB)
    #{
    #	IMPLIBRARYFROMOBJECTS $(SUFHB)$(DFS)$(<) : $(>:S=$(SUFOBJ)) ;
    #	ObjectsHB $(SUFOBJ)$(DFS)$(>) ;
    #	Clean clean : $(SUFOBJ)$(DFS)$(<) ;
    #}
}

rule ImpLibraryHB
{
    IMPLIBRARYFROMOBJECTS $(<) : $(>:S=$(SUFOBJ)) ;
    AR on $(<) = $(AR32) ;
    ObjectsHB $(>) ;
    Clean clean : $(<) ;

}

rule REGLIBRARY
{
    REGLIBRARYFROMOBJECTS $(<) : $(>:S=$(SUFOBJ)) ;
    #if $(VERSHB)
    #{
    #	AR on $(<) = $(AR32) ;
    #	REGLIBRARYFROMOBJECTS $(SUFHB)$(DFS)$(<) : $(SUFHB)$(DFS)$(>:S=$(SUFOBJ)) ;
    #}
}

rule RegLibraryHB
{
    REGLIBRARYFROMOBJECTS $(<) : $(>:S=$(SUFOBJ)) ;
    AR on $(<) = $(AR32) ;
}

rule IMPLIBRARYFROMOBJECTS 
{
    local _i _l _s ;

    # Add grist to file names

    _s = [ FGristFiles $(>) ] ;
    _l = $(<:S=$(SUFLIB)) ;

    # library depends on its member objects

    if $(KEEPOBJS)
    {
        DEPENDS obj : $(_s) ;
    }
    else
    {
        DEPENDS lib : $(_l) ;
    }

    # Set LOCATE for the library and its contents.  The bound
    # value shows up as $(NEEDLIBS) on the Link actions.
    # For compatibility, we only do this if the library doesn't
    # already have a path.

    if ! $(_l:D)
    {
        MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
    }

    if $(NOARSCAN) 
    { 
        # If we can't scan the library to timestamp its contents,
        # we have to just make the library depend directly on the
        # on-disk object files.  

        DEPENDS $(_l) : $(_s) ;
    }
    else
    {
        # If we can scan the library, we make the library depend
        # on its members and each member depend on the on-disk
        # object file.

        DEPENDS $(_l) : $(_l)($(_s:BS)) ;

        for _i in $(_s)
        {
        DEPENDS $(_l)($(_i:BS)) : $(_i) ;
        }
    }

    Clean clean : $(_l) ;

    if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

    ImpArchive $(_l) : $(_s) ;

    if $(RANLIB) { Ranlib $(_l) ; }

    # If we can't scan the library, we have to leave the .o's around.

    #if ! ( $(NOARSCAN) || $(KEEPOBJS) ) { RmTemps $(_l) : $(_s) ; }
}

rule REGLIBRARYFROMOBJECTS 
{
    local _i _l _s ;

    # Add grist to file names

    _s = [ FGristFiles $(>) ] ;
    _l = $(<:S=$(SUFLIB)) ;

    # library depends on its member objects

    if $(KEEPOBJS)
    {
        DEPENDS obj : $(_s) ;
    }
    else
    {
        DEPENDS lib : $(_l) ;
    }

    # Set LOCATE for the library and its contents.  The bound
    # value shows up as $(NEEDLIBS) on the Link actions.
    # For compatibility, we only do this if the library doesn't
    # already have a path.

    if ! $(_l:D)
    {
        MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
    }

    if $(NOARSCAN) 
    { 
        # If we can't scan the library to timestamp its contents,
        # we have to just make the library depend directly on the
        # on-disk object files.  

        DEPENDS $(_l) : $(_s) ;
    }
    else
    {
        # If we can scan the library, we make the library depend
        # on its members and each member depend on the on-disk
        # object file.

        DEPENDS $(_l) : $(_l)($(_s:BS)) ;

        for _i in $(_s)
        {
        DEPENDS $(_l)($(_i:BS)) : $(_i) ;
        }
    }

    Clean clean : $(_l) ;

    if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

    Archive $(_l) : $(_s) ;

    if $(RANLIB) { Ranlib $(_l) ; }

    # If we can't scan the library, we have to leave the .o's around.

    #if ! ( $(NOARSCAN) || $(KEEPOBJS) ) { RmTemps $(_l) : $(_s) ; }
}

if $(NT)
{
    rule IICHECKKEYPAIR
    {
        DEPENDS boot : $(<) ;
        LOCATE on $(<) = $(ING_SRC)/common/dotnet/specials ;
    }
}

# Jambase extensions for building shared libraries

rule IISHLIBFROMARCHIVE
{
	local i ;
	for i in $(>)
	{
	   local lib = $(i:S=$(SUFLIB)) ;
	   local objs = *$(SUFOBJ) ;
	   Depends $(<) : $(lib) ;
	   NotFile $(i)dummy ;
	   MakeLocate $(i)dummy : $(INGLIB)/shared/$(i) ;
	   SEARCH on $(lib) += $(INGLIB) ;
	   IIDUMPOBJECTS $(i)dummy : $(lib) ;
	   LINKLIBS on $(<) += $(TP_OBJ_PATH)/*$(SUFOBJ) ;
	}
}

rule IIVERSREL
{
	if $(NT)
	{
	_IIVERSRELW $($(<)) ;
	}
	else
	{
	_IIVERSREL $($(<)) ;
	}
                if $(NT)
	{
	_USETOOL $($(<)) : readvers.bat ;
	}
	else
	{
	_USETOOL $($(<)) : readvers$(SUFXSH) ;
	}
	Depends files : $($(<)) ;
	LOCATE on $($(<)) = $(ING_BUILDROOT) ;

	Depends $($(<)) : $(VERSFILE) ;

	MODE on $($(<)) = $(FILEMODE) ;
	Chmod $($(<)) ;

}


rule IIFASTI
{
    if ! $(II_INSTALLATION)
    {
        _NOIIINST $(<) ;
    }
    else
    {
        _IIFASTI $(<) ;
    }
 
    DEPENDS install : $(<) ;
    LOCATE on $(<) = $(ING_BUILD) ;
}


rule ShellNT
{
    DEPENDS shell : $(<) ;
    DEPENDS $(<) : $(>) ;
    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    MODE on $(<) = $(SHELLMODE) ;
    Clean clean : $(<) ;
    Chmod $(<) ;
}

rule IIMCTOH
{
	local _s ;
	_s = [ FGristFiles $(>) ] ;
	switch $(_s:G)
	{
		case *cl*clf*cs* 	: MCFLAG on $(<) = "-h" ;
					  _IIMCTOH $(<) : $(>) ;
		case *front*rep*repserv* :
					  MCFLAG on $(<:S=.rc) = "-r" ;
					  MCFLAG on $(<:S=.res) = "-r" ;
					  MCFLAG on $(<:S=.h) = "-r" ;
					  MCFLAG on $(<) = "-r" ;
					  MCFLAG = "-r" ;
					  DEPENDS $(<) : $(<:S=.rc) ;
					  _IIMCTOH $(<:S=.rc) : $(>) ;
					  IIRCTORESW $(<) : $(<:S=.rc) ;
					  LOCATE on $(<:S=.rc) = $(INGIBN) ;
					  Clean clean : $(<:S=.rc) ;
		case *front*st* 	 : 
					  MCFLAG on $(<:S=.h) = "-h" ;
					  _IIMCTOH $(<:S=.h) : $(>) ;
					  #DEPENDS $(<) : $(>:S=.rc) ;
					  IIRCTORES $(>:S=.rc) ;
					  DEPENDS $(>:S=.rc) : $(<:S=.h) ;
					  #LOCATE on $(<:S=.h) = $(SEARCH_SOURCE) ;


		case *			: 
					  MCFLAG on $(<:S=.rc) = "" ;
					  MCFLAG =  "" ;
					  DEPENDS $(<) : $(<:S=.rc) ;
					  _IIMCTOH $(<:S=.rc:D=) : $(>) ;
					  IIRCTORES $(<:S=.rc) ;

					   
					
	}
	DEPENDS $(<) : $(>) ;
	DEPENDS hdrs : $(<) ;

	DEPENDS $(<:S=.rc:D=) : $(>) ;

        Clean clean : $(<) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	SEARCH on $(<:S=.rc:D=) = $(INGBIN) $(SEARCH_SOURCE) ;
}

rule IIRCTORESW
{
	DEPENDS hdrs : $(<) ;
	DEPENDS $(<) : $(<:S=.rc) ;
	_IIRCTORESW $(<) : $(>) ;
	SEARCH on $(>) = $(INGBIN) ;
        Clean clean : $(<) ;
}

rule IIRCTORES
{
    local _s ;
    _s = [ FGristFiles $(<) ] ;
    switch $(_s:G)
    {
	case *common*odbc*winspecials*	: RCFLAGS on $(<:S=.res) = /i ;
					  RCHDR	on $(<:S=.res) = $(HDRDRV) ;
    }

    DEPENDS hdrs : $(<:S=.res) ;
    DEPENDS $(<) : $(VERSINFORC:B).rc ;
    DEPENDS $(<:S=.res) : $(<) ;
    _IIRCTORES $(<:S=.res) : $(<:S=.rc) ;
    LOCATE on $(<:S=.res) = $(SEARCH_SOURCE) ;
    SEARCH on $(<) = $(SEARCH_SOURCE) ;
    SEARCH on $(<:S=rc) = $(SEARCH_SOURCE) ;
    SEARCH on $(VERSINFORC:B).rc = $(INGGV) ;

}


rule IIREMDIRS
{
    Clean clean : $($(<)) ;
}

rule IITOOLSDIR
{
    _IITOOLSDIR $($(<)) ;
    DEPENDS boot : $($(<)) ;
}

rule IIPPTOF
{
        for i in $(<)
        {
          T = $(INGFILES)/$(i:S=.f) ; S = $(i) ;

          _CCPP $(T) : $(S) ;
          _USETOOL $(T) : ccpp.bat ;

          DEPENDS files : $(T) ;
          DEPENDS $(T) : $(S) ;
          SEARCH on $(S) = $(SEARCH_SOURCE) ;
	
	  Clean clean : $(T) ;
        }
}

rule IIPPTOCBL
{
        for i in $(<)
        {
          T = $(INGFILES)/$(i:S=.cbl) ; S = $(i) ;

          _CCPP $(T) : $(S) ;
          _USETOOL $(T) : ccpp.bat ;

          DEPENDS files : $(T) ;
          DEPENDS $(T) : $(S) ;
          SEARCH on $(S) = $(SEARCH_SOURCE) ;
        }
}


rule IIPPTOCBL2
{
          T = $(INGFILES)/$(<) ; S = $(>) ;

          _CCPP $(T) : $(S) ;
          _USETOOL $(T) : readvers.bat ccpp.bat ;

          DEPENDS files : $(T) ;
          DEPENDS $(T) : $(S) ;
          SEARCH on $(S) = $(SEARCH_SOURCE) ;

	  Clean clean : $(T) ;
}


rule IISLN
{
	if $(VSREBUILD) = ON
	{
		ALWAYS $(<) ;

	}
	#if $(MSDEV_CONFIG) = "DebugAMD64" || $(MSDEV_CONFIG) = "ReleaseAMD64"
	#{
	#	C++ on $(<) = $(CC32) ;
	#}
        local _temp_suf = $(<:S) ;
        switch $(_temp_suf:L)
        {
            case *.lib : LOCATE on $(<) = $(INGLIB) ;
			 DEPENDS lib : $(<) ;
            case *.dll : 
                local _lib = $(<:BS=.lib) ;
                DEPENDS $(_lib) : $(<) ;
		DEPENDS shlibs : $(<) ;
		NOUPDATE $(_lib) ;	
                #DUMMY $(_lib) : $(<) ; # .lib is made by devenv
                LOCATE on $(_lib) = $(INGLIB) ;
                LOCATE on $(<) = $(INGLIB) ;
		SEARCH on $(<) = $(INGLIB) ;

		Clean clean : $(_lib) ;

        }

        local _dotnetsln ;
	local _dotnetsln2 ;
	local _csharpdemo ;
        local _s = [ FGristFiles $(>) ] ;

	if $(_temp_suf:L) != ".lib" && $(_temp_suf:L) != ".dll" 
	{
	switch $(_s:G)
	{
	    case *front*vdba*adbtofst* : LOCATE on $(<) = $(INGBIN) ;
	    case *front*vdba*rmcmd* : LOCATE on $(<) = $(INGBIN) ;
	    case *front*vdba*dataldr* : LOCATE on $(<) = $(INGBIN) ;
	    case *front*vdba* : LOCATE on $(<) = $(INGBIN) ;
	    case *front*st* : LOCATE on $(<) = $(INGBIN) ;
	    case *common*dotnet_* : LOCATE on $(INGCLIENTDLL) = $(INGDOTNET) ;
				   LOCATE on $(INGCLIENTXML) = $(INGDOTNET) ;
				   LOCATE on $(INGVSDESIGN) = $(INGDOTNET) ;
				   LOCATE on $(INGSUPPORT) = $(INGDOTNET) ;
	    case *common*dotnet2_* : LOCATE on $(INGCLIENTDLL2) = $(INGDOTNET2) ;
				   LOCATE on $(INGCLIENTXML2) = $(INGDOTNET2) ;
				   LOCATE on $(INGVSDESIGN2) = $(INGDOTNET2) ;
				   LOCATE on $(INGSUPPORT2) = $(INGDOTNET2) ;
				   LOCATE on $(INGINSTALL2) = $(INGDOTNET2) ;
				   if $(MSDEV_CONFIG) = "ReleaseAMD64" 
				   {
					MSDEV_CONFIG on $(<) = "Release" ;
				   }
				   if $(MSDEV_CONFIG) = "DebugAMD64"
				   {
					MSDEV_CONFIG on $(<) = "Debug" ;
				   }
	    case *front*IngresDemoApp* : LOCATE on $(<) = $(INGCSHDEMO) ;
            case * : LOCATE on $(<) = $(INGBIN) ;
	}
	}

        switch $(_s)
        {
            case *common*dotnet2_* :
                _dotnetsln2 = TRUE ;

	    case *common*dotnet_* :
		_dotnetsln = TRUE ;
		
	    case *front*IngresDemoApp* :
		_csharpdemo = TRUE ;
		DEPENDS $(<) : $(INGCLIENTDLL2) ;
		SEARCH on $(INGCLIENTDLL2) = $(INGDOTNET2) ;
   	        if $(MSDEV_CONFIG) = "ReleaseAMD64" 
		{
			MSDEV_CONFIG on $(<) = "Release" ;
		}
		if $(MSDEV_CONFIG) = "DebugAMD64"
		{
			MSDEV_CONFIG on $(<) = "Debug" ;
		}

            case *front*st*iilink* :
                DEPENDS $(<) : $(IMPCOMPATLIB) $(IMPCOMPATLIBDATA) $(IMPGCFLIB)
                    $(IMPGCFLIBDATA) ;
                SEARCH on $(IMPCOMPATLIB) $(IMPCOMPATLIBDATA) $(IMPGCFLIB)
                    $(IMPGCFLIBDATA) = $(INGLIB) ;

            case *front*st*perfwiz* :
                DEPENDS $(<) : $(PERFMONLIB) $(IMPAPILIB) ;
                SEARCH on $(PERFMONLIB) $(IMPAPILIB) = $(INGLIB) ;

            case *front*st*wincluster* :
                DEPENDS $(<) : $(CONFIGLIB) ;
		DEPENDS $(<) : $(SHTNGAPILIB) ;
                SEARCH on $(SHTNGAPILIB) $(CONFIGLIB) = $(INGLIB) ;

            case *front*vdba*dataldr* :
                _USETOOL $(<) : esqlc.exe ;

            case *front*vdba*ijactrl* :
                DEPENDS $(<) : $(LIBINGLLLIB) $(LIBWCTRLLIB) ;
                SEARCH on $(LIBINGLLLIB) $(LIBWCTRLLIB) = $(INGLIB) ;
               
                _USETOOL $(<) : esqlcc.exe ;
            case *front*vdba*ija* :
                DEPENDS $(<) : $(SHTKANIMATLIB) $(LIBGUIDSLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) ;
                SEARCH on $(SHTKANIMATLIB) $(LIBGUIDSLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) = $(INGLIB) ;

            case *front*vdba*libmon* :
                _USETOOL $(<) : esqlc.exe ;

            case *front*vdba*svrsqlas* :
                DEPENDS $(<) : $(SHTKANIMATLIB) $(LIBGUIDSLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) ;
                SEARCH on $(SHTKANIMATLIB) $(LIBGUIDSLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) = $(INGLIB) ;

		LOCATE on $(SQLASSIS) = $(INGBIN) ;
 		Clean clean : $(SQLASSIS) ;

            case *front*vdba*ipm* :
                DEPENDS $(<) : $(SHTKANIMATLIB) $(LIBMONLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) ;
                SEARCH on $(SHTKANIMATLIB) $(LIBMONLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) = $(INGLIB) ;
            case *front*vdba*ivm* :
                DEPENDS $(<) : $(UTILLIB) $(CONFIGLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) ;
                SEARCH on $(UTILLIB) $(CONFIGLIB) $(LIBINGLLLIB) $(LIBWCTRLLIB)
                    = $(INGLIB) ;
            case *front*vdba*libingll* :
                _USETOOL $(<) : esqlcc.exe ;

            case *front*vdba*mainmfc* :
               DEPENDS $(<) : $(INGRSWINLIB) $(SHCATO3CNTLIB)
                    $(SHCATO3SPNLIB) $(SHCATOLBOXLIB) $(DBADLG1LIB) $(INGRSWINLIB) 
                    $(LIBEXTNCLIB) $(LIBGUIDSLIB) $(LIBWCTRLLIB) $(MAINLIBLIB) ;
               SEARCH on $(INGRSWINLIB) $(SHCATO3CNTLIB)
                    $(SHCATO3SPNLIB) $(DBADLG1LIB) $(INGRSWINLIB) 
                    $(LIBEXTNCLIB) $(LIBGUIDSLIB) $(LIBWCTRLLIB) $(MAINLIBLIB) 
                    = $(INGLIB) ;
		SEARCH on $(SHCATOLBOXLIB) = $(INGLIB) ;
                _USETOOL $(<) : esqlcc.exe ;
            case *front*vdba*sqlquery* :
                DEPENDS $(<) : $(LIBGUIDSLIB) $(LIBINGLLLIB) $(LIBTREELIB) 
                    $(LIBWCTRLLIB) $(SHTKANIMATLIB) ;
                SEARCH on $(LIBGUIDSLIB) $(LIBINGLLLIB) $(LIBTREELIB) 
                    $(LIBWCTRLLIB) $(SHTKANIMATLIB) = $(INGLIB) ;

            case *front*vdba*svriia* :
                DEPENDS $(<) : $(LIBGUIDSLIB) $(LIBINGLLLIB) $(LIBTREELIB) 
                    $(LIBWCTRLLIB) $(SHTKANIMATLIB) ;
                SEARCH on $(LIBGUIDSLIB) $(LIBINGLLLIB) $(LIBTREELIB) 
                    $(LIBWCTRLLIB) $(SHTKANIMATLIB) = $(INGLIB) ;

            case *front*vdba*tksplash* :
                DEPENDS $(<) : $(LIBWCTRLLIB) $(LIBINGLLLIB) ;
                SEARCH on $(LIBWCTRLLIB) $(LIBINGLLLIB) = $(INGLIB) ;

            case *front*vdba*treedll* :
                DEPENDS $(<) : $(LBTREELPLIB) ;
                SEARCH on $(LBTREELPLIB) = $(INGLIB) ;

            case *front*vdba*vcbf* :
                DEPENDS $(<) : $(UTILLIB) $(CONFIGLIB) ;
                SEARCH on $(UTILLIB) $(CONFIGLIB) = $(INGLIB) ;
            case *front*vdba*vcda* :
                DEPENDS $(<) : $(SHTKANIMATLIB) $(LIBINGLLLIB) $(LIBWCTRLLIB) ;
                SEARCH on $(SHTKANIMATLIB) $(LIBINGLLLIB) 
                    $(LIBWCTRLLIB) = $(INGLIB) ;
            case *front*vdba*vnodemgr* :
                DEPENDS $(<) : $(LIBINGLLLIB) ;
                SEARCH on $(LIBINGLLLIB) = $(INGLIB) ;

            case *front*vdba*vsda* :
                DEPENDS $(<) : $(LIBINGLLLIB) $(LIBTREELIB) $(LIBWCTRLLIB) 
                    $(SHTKANIMATLIB) ;
                SEARCH on $(LIBINGLLLIB) $(LIBTREELIB) $(LIBWCTRLLIB)
                    $(SHTKANIMATLIB) = $(INGLIB) ;

            case *front*vdba*vsda* :
                _USETOOL $(<) : esqlc.exe ;

            case *front*vdba*xiea* :
                DEPENDS $(<) : $(LIBGUIDSLIB) $(LIBINGLLLIB) ;
                SEARCH on $(LIBGUIDSLIB) $(LIBINGLLLIB) = $(INGLIB) ;

            case *front*vdba*xiia* :
                DEPENDS $(<) : $(LIBGUIDSLIB) $(LIBINGLLLIB) ;
                SEARCH on $(LIBGUIDSLIB) $(LIBINGLLLIB) = $(INGLIB) ;

            case *front*vdba*xsql* :
                DEPENDS $(<) : $(LIBGUIDSLIB) $(LIBINGLLLIB) ;
                SEARCH on $(LIBGUIDSLIB) $(LIBINGLLLIB) = $(INGLIB) ;

            case *front*vdba*xvcda* :
                DEPENDS $(<) : $(LIBGUIDSLIB) $(LIBINGLLLIB) ;
                SEARCH on $(LIBGUIDSLIB) $(LIBINGLLLIB) = $(INGLIB) ;

            case *front*vdba*xipm* :
                DEPENDS $(<) : $(SHTKANIMATLIB) $(LIBMONLIB) $(LIBINGLLLIB) 
                    $(LIBGUIDSLIB) ;
                SEARCH on $(SHTKANIMATLIB) $(LIBMONLIB) $(LIBINGLLLIB) 
                    $(LIBGUIDSLIB) = $(INGLIB) ;

            case *front*vdba*xvdda* :
                DEPENDS $(<) : $(LIBGUIDSLIB) $(LIBINGLLLIB) $(LIBWCTRLLIB) 
                    $(SHTKANIMATLIB) ;
                SEARCH on $(LIBGUIDSLIB) $(LIBINGLLLIB) $(LIBWCTRLLIB)
                    $(SHTKANIMATLIB) = $(INGLIB) ;
        }

        if $(_dotnetsln) || $(_dotnetsln2) 
        {
            	_SLNDOTNET $(<) : $(_s) ;
        }
        else
        {
            	_SLN $(<) : $(_s) ;
        }
        SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	if ! $(_dotnetsln2) && ! $(_dotnetsln) 
	{
        SEARCH on $(_s:S=.vcproj) = $(SEARCH_SOURCE) ;
	}
	if $(_csharpdemo)
	{
	     SEARCH on $(_s:S=.csproj) = $(SEARCH_SOURCE) ;
	}	


        if $(_dotnetsln) || $(_dotnetsln2) 
	{ 
		NOTFILE $(<) ;
		if $(_dotnetsln)
		{

		DEPENDS $(<) : $(INGCLIENTDLL) ;
		DEPENDS $(<) : $(INGCLIENTXML) ;
		DEPENDS $(<) : $(INGVSDESIGN) ;
		DEPENDS $(<) : $(INGSUPPORT) ;

		DEPENDS  $(INGCLIENTDLL) : $(_s) ;
		DEPENDS  $(INGCLIENTXML) : $(_s) ;
		DEPENDS  $(INGVSDESIGN) : $(_s) ;
		DEPENDS  $(INGSUPPORT) : $(_s) ;
		}
		else
		{

		DEPENDS $(<) : $(INGCLIENTDLL2) ;
		DEPENDS $(<) : $(INGCLIENTXML2) ;
		DEPENDS $(<) : $(INGVSDESIGN2) ;
		DEPENDS $(<) : $(INGSUPPORT2) ;
		DEPENDS $(<) : $(INGINSTALL2) ;

		DEPENDS $(INGCLIENTDLL2) : $(_s) ;
		DEPENDS $(INGCLIENTXML2) : $(_s) ;
		DEPENDS $(INGVSDESIGN2) : $(_s) ;
		DEPENDS $(INGSUPPORT2) : $(_s) ;
		DEPENDS $(INGINSTALL2) : $(_s) ;
		}
	}
	else
	{
	     if $(_csharpdemo)
	     {
		DEPENDS $(<) : $(_s:S=.csproj) ;
		DEPENDS $(<) : $(_s:S=.sln) ;
	     }
	     else
	     {
		DEPENDS $(<) : $(_s:S=.vcproj) ;
	     }
	
	}

        DEPENDS files : $(<) ;
        DEPENDS $(<) : $(_s) ;
        DEPENDS $(<) : $(INGRESLIB) ;

        SEARCH on $(INGRESLIB) = $(INGLIB) ;

	if $(<:SL) = .dll
	{
	    IIREBASE $(<) ;
	}

	if $(_dotnetsln)
	{
		Clean clean :  $(INGDOTNET)/$(INGCLIENTDLL) $(INGDOTNET)/$(INGCLIENTXML) 
				$(INGDOTNET)/$(INGVSDESIGN) $(INGDOTNET)/$(INGSUPPORT) ;
	}
	if $(_dotnetsln2)
	{
		Clean clean : $(INGDOTNET2)/$(INGCLIENTDLL2) $(INGDOTNET2)/$(INGCLIENTXML2) 
				$(INGDOTNET2)/$(INGVSDESIGN2) $(INGDOTNET2)/$(INGSUPPORT2) 
				$(INGDOTNET2)/$(INGINSTALL2) ;
	}
	if $(_csharpdemo)
	{
		Clean clean : $(INGCSHDEMO)/$(<:D=) ;	
	}
	if ! $(_csharpdemo) && ! $(_dotnetsln) && ! $(_dotnetsln2)
	{
		SEARCH on $(<:S=.chm) = $(INGBIN) ;
 		Clean clean : $(<) $(<:S=.chm) $(INGBIN)/$(<:D=) $(INGLIB)/$(<:D=) $(INGVDBA)/$(<:D=) ;
	}
}

rule IISLNDLL
{
	local _lt = $(SEARCH_SOURCE)/$(<) ;
	local _cp = $(INGBIN)/$(<) ;

	_SLN $(_lt) : $(>) ;
	DEPENDS $(_lt) : $(>) ;
	DEPENDS $(_cp) : $(SEARCH_TARGET)/$(<) ;
	DEPENDS $(<) : $(_cp) ;

	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	SEARCH on $(INGRESLIB) = $(INGLIB) ;
	LOCATE on $(<) = $(INGBIN) ;
	
}

rule IISHICEAPACHE 
{
	local _lt = $(INGLIB)/$(SHAPACHELIB) ;
	local _lv = $(INGAPACHEICE)/$(SHGENICE) ;
	local _src = $(>) $(APACHECORE) ;

	IISHLIBRARY $(_lt) : $(_src) ;

	SEARCH on $(>) = $(INGLIB) ;
	SEARCH on $(_lt:D=) = $(INGLIB) ;
	LOCATE on $(<) = $(INGLIB) ;
	LOCATE on $(<).manifest = $(INGLIB) ;
	DEPENDS $(<) : $(_lv) ;
	DEPENDS $(<) : $(>) ;

	IICPEXE $(_lv) : $(_lt) ;

	Clean clean : $(SHAPACHELIB) $(<).manifest ;
	

}

rule IISHICEMS
{
	local _lt = $(INGLIB)/$(SHICEMSLIB) ;
	local _lv = $(INGMSICE)/$(SHGENICE) ;
	local _lw = $(INGICEBIN)/$(SHGENICE) ;
	local _src = $(>) ;

	IISHLIBRARY $(_lt) : $(_src) ;

	SEARCH on $(>) = $(INGLIB) ;
	SEARCH on $(_lt:D=) = $(INGLIB) ;
	LOCATE on $(<) = $(INGLIB) ;
	LOCATE on $(<).manifest = $(INGLIB) ;
	DEPENDS $(<) : $(_lv) ;
	DEPENDS $(<) : $(_lw) ;
	DEPENDS $(<) : $(>) ;

	IICPEXE $(_lv) : $(_lt) ;
	IICPEXE $(_lw) : $(_lv) ;

	Clean clean : $(SHICEMSLIB) $(<).manifest ;

}

rule IIICEEXE
{
	local _cp = $(<) ;
	local _t = $(<:D=:S=.$(EXESFX)) ;

	DEPENDS $(_cp) : $(_t) ;

	IIBINEXE $(_t) : $(>) ;
	IICPEXE $(_cp) : $(_t) ;
	SEARCH on $(_t) = $(INGBIN) ;

	Clean clean : $(<) ;
	
}

rule IIHLP
{
	local _t = $(<:D=) ;
	DEPENDS $(<) : $(_t) ;
	DEPENDS $(_t) : $(>) ;

	_IIHLP $(_t) : $(>) ;
	FILE $(<) : $(_t) ;
	
	LOCATE on $(>) = $(SEARCH_SOURCE) ;
	LOCATE on $(_t) = $(SEARCH_SOURCE) ;

	Clean clean : $(<) ;

	

}


rule DUMMY
{
}
rule IIHLPODBC
{
	local _t = $(>:D=:S=.HLP) ;
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(_t) ;
	DEPENDS $(_t) : $(>) ;

	_IIHLP $(_t) : $(>) ;
	FILE $(<) : $(_t) ;
	
	LOCATE on $(>) = $(SEARCH_SOURCE) ;
	LOCATE on $(_t) = $(SEARCH_SOURCE) ;
	
	Clean clean : $(<) ;
}

rule IIGcfXlt
{
            _s = [ FGristFiles $(>) ] ;
            _t = $(>:D=) ;

	_USETOOL $(>) : yapp$(SUFEXE) ;
        _YAPPGCFFILE $(_t) : $(_s) ;

            YAPPFLAGS on $(_t) = -H## -D$(VERS) ;
            DEPENDS files : $(_t) ;
            DEPENDS $(_t) : $(_s) ;

            LOCATE on $(_t) = [ FDirName $(INGFILES) $(<) ] ;
            SEARCH on $(_s) = $(SEARCH_SOURCE) ;

            Clean clean : $(_t) ;
}

rule IIReadMeHtml
{
	local _i = [ FGristFiles $(>) ] ;
	local _t = $(<) ;
	_ReadMeHtml $(_t) : $(_i) ;
	DEPENDS $(_t) : $(_i) ;
	DEPENDS files : $(_t) ;

	SEARCH on $(_i) = $(SEARCH_SOURCE) ;
	LOCATE on $(_t) = $(ING_README) ;

	Clean clean : $(_t) ;
}

rule IIPatchHtml
{
    for i in $(<)
    {
	local _s = [ FGristFiles $(i) ] ;
	local _t = $(i) ;
	_PatchHtml $(_t) : $(_s) ;
	DEPENDS $(_t) : $(_s) ;
	DEPENDS files : $(_t) ;

	SEARCH on $(_s) = $(SEARCH_SOURCE) ;
	MakeLocate $(_t) : $(PNOTETMPLTS) ;

        if $(NT)
        {
		_USETOOL $(_t) : genrelid.bat ;
	}
	else
	{
		_USETOOL $(_t) : genrelid$(SUFXSH) ;
	}

	Clean clean : $(_t) ;
    }
}

#
# Wrapper rules for building without the Hybrid bits
#
rule IINoHbBinExe
{
    local VERSHB = "" ;
    IIBINEXE $(<) : $(>) ;
}

rule IINoHbUtilExe
{
    local VERSHB = "" ;
    IIUTILEXE $(<) : $(>) ;
}

rule IINoHbLibrary
{
    local VERSHB = "" ;
    IILIBRARY $(<) : $(>) ;
}

rule IINoHbNeedLibs
{
    local VERSHB = "" ;
    IINEEDLIBS $(<) : $(>) ;
}

#
# Post-build rules
#
if $(NT)
{
rule IIMkPreInstall
{
	for i in $(PREINSTALL_LIBS)
	{
		DEPENDS postbuild : $(i) ;
		PBCopy $(INGPREINSTALL) : $(i) ;
		SEARCH on $(i) = $(INGBIN) ;
	}
	IIPFiles $(INGPREINSTALL)/inst1252.chx : $(INGCHARSETS)$(DFS)inst1252$(DFS)desc.chx ;
}


rule IIPFiles   
{     
    PBCopyFile $(<) : $(>) ; 

    DEPENDS postbuild : $(<) ;
    SEARCH on $(>:D=) = $(INGCHARSETS)/inst1252 ;
}

rule IIMkThinClient
{
	DEPENDS postbuild : $(THIN_CLIENT_EXE) $(THIN_CLIENT_LIBS) $(THIN_CLIENT_CRS) $(THIN_CLIENT_CHARS) 
			$(THIN_CLIENT_MNX_E) $(THIN_CLIENT_MNX_N) ;

	_MkThinClient $(INGTHINCLIENT) $(THINCLIENT) ;

	DEPENDS $(INGTHINCLIENT) : $(THINCLIENT) ;
	DEPENDS $(INGTHINCLIENT)/bin : $(INGTHINCLIENT) ;

	PBCopy $(INGTHINCLIENT)/bin : $(THIN_CLIENT_EXE) $(THIN_CLIENT_LIBS) ;
	SEARCH on $(THIN_CLIENT_EXE) = $(INGBIN) $(INGUTIL) ;
	SEARCH on $(THIN_CLIENT_LIBS) = $(INGBIN) ;

	PBCopy $(INGTHINCLIENT)$(SLASH)files : $(THIN_CLIENT_CRS) ;
	
	PBCopy $(INGTHINCLIENT)$(SLASH)files$(SLASH)charsets : $(THIN_CLIENT_CHARS) ;
	SEARCH on $(THIN_CLIENT_CHARS) = $(INGCHARSETS) ;

	for i in $(THIN_CLIENT_CHARS_DIRS_CH)
	{		
		PBCopy $(INGTHINCLIENT)$(SLASH)files$(SLASH)charsets$(SLASH)$(i) : $(INGFILES)/charsets/$(i)/desc.chx ;
	}

	PBCopy $(INGTHINCLIENT)$(SLASH)files$(SLASH)english : $(THIN_CLIENT_MNX_E) ;
	SEARCH on $(THIN_CLIENT_MNX_E) = $(INGFILES)$(SLASH)english ;

	PBCopy $(INGTHINCLIENT)$(SLASH)files$(SLASH)name : $(THIN_CLIENT_MNX_N) ;
	SEARCH on $(THIN_CLIENT_MNX_N) = $(INGFILES)$(SLASH)name ;	

	#timezones
	T = $(INGTHINCLIENT)/files/zoneinfo/.stamp ; S = iiworld.tz ;

	_TIMEZONETHINCL $(T) : $(S) ;
	_USETOOL $(T) : iizic$(SUFXSH) ; 

	DEPENDS postbuild : $(T) ;
	DEPENDS $(T) : $(S) ;

	SEARCH on $(S) = $(INGTIMEZONEZIP) ;
}

rule PBCopy
{
	for i in $(>)
	{
		DEPENDS postbuild : $(<)/$(i:D=) ;
		DEPENDS $(<:D)/$(i:D=) : $(>) ;
		_PBCopy $(<)/$(i:D=) : $(i) ;
	}
}



rule PBCopyFile
{
	DEPENDS postbuild : $(<) ;
	DEPENDS $(<) : $(>) ;
	_PBCopyFile $(<) : $(>) ;
}

}


rule IIKitInstalData
{
	Depends files : $(<) ;
	Depends $(<) : $(VERSFILE) ;

	_USETOOL $(<) : genrelid$(SUFXSH) mkkitinstal$(SUFXSH) ;
	LOCATE on $(<) = $(INSTLVMS) ;
	Clean clean : $(<) ;
}

#
# IIDBMAXNAME
#
# Description:
#    This rule copies the source files to the destination directory after
#    substituting ##DB_MAXNAME## with the value of DB_MAXNAME found in the
#    header gl.h
#    
# Usage:
#    IIDBMAXNAME <directory> : <source files> ;
#
#    <directory> is intended to be specified as a blank delimited list
#        of directory paths.
#    <source files> is a blank delimited list of one or more text files.
#
rule IIDBMAXNAME
{
    local _i ;

    for _i in $(>)
    {
        local _srcfile = [ FGristFiles $(_i) ] ;
        local _destdir = [ FDirName $(<) ] ;
        IIDBMAXNAME1 $(_i:D=$(_destdir)) : $(_srcfile) ;
    }
}

#
# IIDBMAXNAME1
#
# Description:
#    This rule is not intended to be called directly, use IIDBMAXNAME instead.
#    This rule copies one source file to the destination directory after
#    substituting ##DB_MAXNAME## with the value of DB_MAXNAME found in the
#    header gl.h
#
# Usage:
#    IIDBMAXNAME1 <target file> : <source file> ;
#
#    <directory> is intended to be specified as a full absolute path.
#    <source file> is a single gristed filename.
#
rule IIDBMAXNAME1
{
    SEARCH on $(>) = $(SEARCH_SOURCE) ;
    Depends files : $(<) ;
    Depends $(<) : $(>) ;
    _USETOOL $(<) : iidbmaxname$(SUFEXE) ;
    MakeLocate $(<) : $(<:D) ;
    MODE on $(<) = $(FILEMODE) ; 
    Chmod $(<) ;
    Clean clean : $(<) ;
}

#
# Actions - no rules below this point
# 
if $(UNIX)
{
     if $(CUSTOMFLAG) != "" && $(SUFFIX) != ""
     {
	actions Cc
	{
	$(CC) -c $(CUSTOMFLAG) $(CCFLAGS) $(OPTIM) -I$(HDRS) -o $(<:S=$(SUFFIX)) $(>)
        }
     }
     else
     {
	# JAM_AUXINFO is set to anything non-blank via shell variable
	# to turn on gathering of gcc aux-info data.
	if $(JAM_AUXINFO)
	{
	    actions Cc
	    {
	    $(CC) -c $(CCFLAGS) $(OPTIM) -I$(HDRS) -o $(<) $(>) -aux-info $(>:S=.aux)
	    }
	}
	else
	{
	    # The usual Cc action
	    actions Cc
	    {
	    $(CC) -c $(CCFLAGS) $(OPTIM) -I$(HDRS) -o $(<) $(>)
	    }
	}

        actions C++
        {
        $(C++) -c $(C++FLAGS) $(OPTIM) -I$(HDRS) -o $(<) $(>)
        }
     }
}

if $(VMS)
{
    actions Cc
    {
        $(CC)/obj=$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
    }
    actions Link bind NEEDLIBS
    {
	inglink $(<) $(>)
    }
    actions LexMv
    {
        $(MV) lexyy.c $(<)
    }
}

actions _MkThinClient 
{

	if not exist $(THINCLIENT) mkdir $(THINCLIENT) 
	if not exist $(INGTHINCLIENT) mkdir $(INGTHINCLIENT) 
	
}


actions _PBCopy
{
	if not exist $(<:D) mkdir $(<:D)
	$(CP) $(>) $(<) 
}


actions _PBCopyFile
{
	if not exist $(<:D) mkdir $(<:D)
	$(CP) $(>) $(<) 
}
if $(BUILD_ICE)
{
actions _CAZIP
{
	$(CD) $(>)
	cazipxp -r -w *.* $(<) 
}
}
actions _INSTALLICE
{
	if not exist $(<) mkdir $(<)

	if not exist $(<)$(SLASH)ice mkdir $(<)$(SLASH)ice
	if not exist $(<)$(SLASH)ice$(SLASH)tmp mkdir $(<)$(SLASH)ice$(SLASH)tmp
	if not exist $(<)$(SLASH)ice$(SLASH)styles mkdir $(<)$(SLASH)ice$(SLASH)styles
	if not exist $(<)$(SLASH)ice$(SLASH)images mkdir $(<)$(SLASH)ice$(SLASH)images
	if not exist $(<)$(SLASH)ice$(SLASH)samples mkdir $(<)$(SLASH)ice$(SLASH)samples
	if not exist $(<)$(SLASH)ice$(SLASH)samples$(SLASH)app    mkdir 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)app
	if not exist $(<)$(SLASH)ice$(SLASH)samples$(SLASH)dbproc mkdir 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)dbproc
	if not exist $(<)$(SLASH)ice$(SLASH)samples$(SLASH)query  mkdir 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)query
	if not exist $(<)$(SLASH)ice$(SLASH)samples$(SLASH)report mkdir 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)report
	if not exist $(<)$(SLASH)ice$(SLASH)tutorialGuide  mkdir 		$(<)$(SLASH)ice$(SLASH)tutorialGuide

	$(CP) $(INGICE)$(SLASH)icetool$(SLASH)login.html $(<)$(SLASH)ice$(SLASH)ialogin.html 
	$(CP) $(INGICE)$(SLASH)icetutor$(SLASH)login.html $(<)$(SLASH)ice$(SLASH)itlogin.html 
	$(CP) $(INGICE)$(SLASH)plays/play_welcome.html $(<)$(SLASH)ice 
	$(CP) $(INGICE)$(SLASH)plays/play_public.css $(<)$(SLASH)ice$(SLASH)styles 
	$(CP) $(INGICE)$(SLASH)plays/bgpaper.gif $(<)$(SLASH)ice$(SLASH)images 
	$(CP) $(INGICE)$(SLASH)plays/OldGlobe.gif $(<)$(SLASH)ice$(SLASH)images 
	$(CP) $(INGICE)$(SLASH)public/ice_index.html $(<)
	$(CP) $(INGICE)$(SLASH)public/exception.html $(<)$(SLASH)ice 
	$(CP) $(INGICE)$(SLASH)public/ice.css $(<)$(SLASH)ice$(SLASH)styles 
	$(CP) $(INGICE)$(SLASH)samples$(SLASH)app/*.* 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)app 
	$(CP) $(INGICE)$(SLASH)samples$(SLASH)dbproc/*.* 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)dbproc 
	$(CP) $(INGICE)$(SLASH)samples$(SLASH)query/*.* 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)query 
	$(CP) $(INGICE)$(SLASH)samples$(SLASH)report/*.* 		$(<)$(SLASH)ice$(SLASH)samples$(SLASH)report 
	$(CP) $(INGICE)$(SLASH)plays$(SLASH)tutorialGuide/*.* 		$(<)$(SLASH)ice$(SLASH)tutorialGuide 
}





actions _CF
{
        if not exist $(<) mkdir $(<)
}

actions _IIHLP
{
	hcw /C /E /M $(>)
}

actions _IIMCTOH bind MCFLAG
{
	$(CD) $(>:D)
	echo $(MCFLAG) 
	$(RM) $(<:S=.rc)
	MC -v $(MCFLAG) $(<:D) $(>) 
	ECHO #include $(VERSINFORC)>>$(>:S=.rc) 
}


if $(VMS)
{
    actions quietly IISedShell
    {
	pipe $(SED) -e "/^$!!/d" -e "s:(PROG0PRFX)::g" -e "s:(PROG1PRFX):ii:g" $(>) > $(<)
    }
}
else
{
    actions quietly IISedShell
    {
    . readvers
    ing_version=`ccpp -s ING_VER | cut -d' ' -f2`
    $(SED)  '-e s:(PROG0PRFX)::g' \
            '-e s:(PROG1PRFX):ii:g' '-e s:(PROG2PRFX):ing:g' \
            '-e s:(PROG3PRFX):II:g' '-e s:(PROG4PRFX):ii:g' \
            '-e s:(PROG5PRFX):ING:g' '-e s:(PROG6PRFX):II:g' \
            '-e s:(PRODLOC):II_SYSTEM:g' \
            '-e s:(PROD1NAME):Ingres:g' '-e s:(PROD2NAME):ingres:g' \
            '-e s:(PROD_PKGNAME):ingres:g' \
	    '-e s:(DBMS_STACKSIZE):$(DBMS_STACKSIZE):g' \
	    "-e s:(DBMS_UDT):$(DBMS_UDT):g" \
	    "-e s:(LSBENV):$(LSBENV):g" \
	    "-e s:BUILD_NO:$build:g" "-e s:ING_VERSION:$ing_version:" \
            $(>) |
    $(AWK) '
        NR == 1 { print "$(SHELLHEADER)" }
        NR == 1 && /^[#:]/ { next }
        /^##/ { next }
        { print }
    ' > $(<)
    }
}

actions quietly IISedShellVMS   
{
    pipe $(SED) -e "s+^:+$(SHELLHEADER)+" $(>) >$(<)
}

actions IIRemRCComments
{
    $(PIPE) $(SED) -e "/^##$/d" -e "/^##[\t ]/d" < $(>) > $(<)
}

actions quietly SEDSHW
{
    echo 1d> sed.input
    echo /^^##/d>> sed.input
    echo s:(PROG0PRFX)::g>> sed.input
    echo s:(PROG1PRFX):ii:g>> sed.input
    echo s:(PROG2PRFX):ing:g>> sed.input
    echo s:(PROG3PRFX):II:g>> sed.input
    echo s:(PROG4PRFX):ii:g>> sed.input
    echo s:(PROG5PRFX):ING:g>> sed.input
    echo s:(PROG6PRFX):II:g>> sed.input
    echo s:(PRODLOC):II_SYSTEM:g>> sed.input
    echo s:(PROD1NAME):Ingres:g>> sed.input
    echo s:(PROD2NAME):ingres:g>> sed.input
   
    $(SED) $(SEDARGS) -f sed.input < $(>) > $(<) 
	
    $(RM) sed.input
}

if $(VMS)
{
    actions quietly SEDCCPP
    {
	$(PIPE) $(SED) -f $(INGTOOLSLIB)sedccpp.sed $(>) > $(<)
    }
}
else if $(NT)
{
    actions quietly SEDCCPP
    {
	$(SED) $(SEDARGS) "-e s/\$SLSFX/$SLSFX/" '-e s:^XX::' '-e s:(PROG0PRFX)::g' '-e s:(PROG1PRFX):ii:g' '-e s:(PROG2PRFX):ing:g' '-e s:(PROG3PRFX):II:g' '-e s:(PROG4PRFX):ii:g' '-e s:(PROG5PRFX):ING:g' '-e s:(PROG6PRFX):II:g' '-e s:(PRODLOC):II_SYSTEM:g' '-e /^--#/d' '-e s:(PROD1NAME):Ingres:g' '-e s:(PROD2NAME):ingres:g' "-e s:BUILD_NO:$build:g" $(>) > $(<)
    }
}
else
{
    actions quietly SEDCCPP
    {
	. shlibinfo
	$(SED) "-e s/\$SLSFX/$SLSFX/" "-e s/\${slvers}/${slvers}/g" \
	    "-e s/\$XERCVERS/$XERCVERS/" "-e s/\$XERCLIB/$XERCLIB/g" \
	    "-e s/\$GEOS_VERS/$GEOS_VERS/" "-e s/\$PROJ_VERS/$PROJ_VERS/" \
	    "-e s/\$GEOSC_VERS/$GEOSC_VERS/" \
	    '-e s:^XX::' '-e s:(PROG0PRFX)::g' \
            '-e s:(PROG1PRFX):ii:g' '-e s:(PROG2PRFX):ing:g' \
            '-e s:(PROG3PRFX):II:g' '-e s:(PROG4PRFX):ii:g' \
            '-e s:(PROG5PRFX):ING:g' '-e s:(PROG6PRFX):II:g' \
            '-e s:(PRODLOC):II_SYSTEM:g' '-e /^--#/d' \
            '-e s:(PROD1NAME):Ingres:g' '-e s:(PROD2NAME):ingres:g' \
	    "-e s:BUILD_NO:$build:g" \
            $(>) > $(<)
    }
}

if $(NOREBUILD)
{
     actions updated IICPEXE
     {
	rm -f $(<)
	$(CP) $(>) $(<)
     }
}
else
{
     actions IICPEXE
     {
	rm -f $(<)
	$(CP) $(>) $(<)
     }
}

if $(NT)
{
     actions updated Chmod1
     {
	$(CHMOD) $(MODE) $(<)
     }
}


actions _IICPDLL
{
	rm -f $(<)
	$(CP) $(>) $(<)
}

actions _IICPDLLBIN
{
	rm -f $(<:D=$(INGBIN)) 
	$(CP) $(>) $(<:D=$(INGBIN))
}

actions _IICPDLLBINHB
{
	rm -f $(<:D=$(INGBIN)$(DFS)$(SUFHB)) 
	$(CP) $(>) $(<:D=$(INGBIN)$(DFS)$(SUFHB)) 
}

actions COPY
{
	rm -f $(<:D)/$(<:BS)
	$(CP) $(>) $(<)
}

# Generate a same-directory symlink, e.g. ln -s ./foo bar.
# _LINK can't do this because it's not necessarily in the right dir.
actions IISYMLINK
{
	rm -f $(<)
	sh -c "cd $(<:D); ln -s $(>:D=.) $(<)"
}

actions _LINK
{
	rm -f $(<)
	ln -s $(>) $(<)
}

actions _IILINK
{
    $(RM) $(<)
    iilink $(DBMS_UDT) $(PARMLPHB)
}

actions quietly IIEXOBJS bind EXCLUDEOBJS
{
    pushd $(<:D)
    $(AR_X) $(>)
    popd
    touch $(<)
} 

if $(VMS)
{
    actions _MKSHLIBS bind SHLIB
    {
	if f$search("$(<)") .nes. "" then $(RM) $(<)$(ALLREVS)
	mkshlibs $(SHLIB)
    }
}
else
{
    actions _MKSHLIBS bind SHLIB
    {
	$(RM) $(<)
	mkshlibs $(PARMLPHB) $(SHLIB:D=)
    }
}

actions _MKSVRSHLIBS bind SHLIB
{
	$(RM) $(<)
	mksvrshlibs $(PARMLPHB) $(SHLIB)
}

actions _MkSvrArLib
{
        mksvrarlib
        chmod $(FILEMODE) $(<)
}

actions _MkSvrArLib64
{
        mksvrarlib -$(SUFHB)
        chmod $(FILEMODE) $(<)
}

if $(VMS)
{
    actions AIFHDR
    {
	pipe ccpp $(>) | $(SED) "/^XX/s/XX//" > $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions AIFHDR
    {
	ccpp $(>) | $(SED) '/^XX/s/XX//' > $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
actions DEFHDRW
{
        grep -v "^##" $(>) > $(>:S=.grep)
        $(CP) $(>:S=.grep) $(<)
        $(CP) $(>:S=.grep) $(<:D=$(INGFILES))
        $(CP) $(>:S=.grep) $(<:D=$(HDRCOMMON))
        $(RM) $(>:S=.grep)
}

actions _ABFCFG
{
	iisuabf -batch && $(TOUCH) $(<)
}

actions _ABFOBJS
{
	ar x $(>) $(<:D=:S=$(SUFOBJ))
	mv -f $(<:D=:S=$(SUFOBJ)) $(<)
	chmod $(FILEMODE) $(<)
}

if $(VMS)
{
    actions _MKHDR
    {
	if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D) 

        set default $(<:D)
	if f$search("$(<)") .nes. "" then $(RM) $(<)$(ALLREVS)
	if "$(<:B)" .eqs. "clsecret"
	then	mksecret
	else	mk$(<:B)
	endif
    }
}
else if ! $(NT)
{
    actions _MKHDR
    {
	[ "$(<:D)" ] && cd $(<:D)
	rm -f $(<)
	if [ "$(<:B)" = "clsecret" ] ; then
	  mksecret
	else
	  mk$(<:B)
	fi
    }
}

if $(VMS)
{
    actions _YYPP
    {
	pipe yypp $(YAPPFLAGS) $(>) > $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions _YYPP
    {
	. readvers
	# for eqdefcc.pp, which includes eqdefc.pp
	[ "$(>:D)" ] && cd $(>:D)

	yypp $(YAPPFLAGS) $(>) | \
	    sed -e "s:BUILD_NO:$build:g" > $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}

if $(VMS)
{
    actions _CHARSET
    {
	if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)
	chset_install $(>:B) $(>)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions _CHARSET
    {
	# should be done by mkidir
	[ -d "$(<:D)" ] || mkdir $(<:D)
	chset_install $(>:B) $(>)
	$(CHMOD) $(FILEMODE) $(<)
    }
}

actions _CHARSETW
{
	if not exist "$(<:D)" mkdir $(<:D)
	chset_install $(>:B) $(>)
}

if $(VMS)
{
    actions _COLDATA
    {
	define II_CONFIG ING_BUILD:[files]
	aducompile $(>) $(<:D=) $(ADUCOMPFLAGS:D=)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else if $(NT)
{
    actions _COLDATA
    {
	set II_CONFIG=$(ING_BUILD)$(SLASH)files 
	aducompile $(>) $(<:D=) $(ADUCOMPFLAGS:D=)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions _COLDATA
    {
	II_CONFIG=$ING_BUILD/files ; export II_CONFIG
	aducompile $(>) $(<:D=) $(ADUCOMPFLAGS:D=)
	$(CHMOD) $(FILEMODE) $(<)
    }
}

actions _COLDATAHB
{
	II_CONFIG=$ING_BUILD/files ; export II_CONFIG
	$(HB_ENABLE_VAR)=TRUE; export $(HB_ENABLE_VAR)
	aducompile $(>) $(<:D=) $(ADUCOMPFLAGS:D=)
	sleep 1
	chmod $(FILEMODE) $(<)
}

actions _COLDATAHBW
{
	set II_CONFIG=$(ING_BUILD)$(DFS)files 
	set $(HB_ENABLE_VAR)=TRUE
	aducompile $(>) $(<:D=) $(ADUCOMPFLAGS:D=)
	sleep 1
	chmod $(FILEMODE) $(<)
}

actions _FORM bind RTIFORM
{
	$(PIPE) formindex $(RTIFORM) $(>) && $(TOUCH) $(<) &&
	$(CHMOD) $(FILEMODE) $(RTIFORM)
}

actions _FORMW bind RTIFORM
{
	formindex $(RTIFORM) $(>)
	$(TOUCH) $(<)
	chmod $(FILEMODE) $(RTIFORM)
}

actions _FORMHB bind RTIFORMHB
{
	$(INGBIN)$(DFS)$(SUFHB)$(DFS)formindex $(RTIFORMHB) $(>) && $(TOUCH) $(<) &&
	chmod $(FILEMODE) $(RTIFORMHB)
}

actions _FORMHBW bind RTIFORMHB
{
	$(INGBIN)$(DFS)$(SUFHB)$(DFS)formindex.$(EXESFX) $(RTIFORMHB) $(>) 
	$(TOUCH) $(<) 
	chmod $(FILEMODE) $(RTIFORMHB)
}

if $(VMS)
{
    actions _IntCatStart
    {
	copy $(>) $(<)
    }

    actions _IntCat
    {
	append $(>) $(<)
    }
}
else
{
    actions _IntCatStart
    {
	$(CAT) $(>) > $(<)
    }

    actions _IntCat
    {
	$(CAT) $(>) >> $(<)
    }
}

actions _IISYSDEP
{
	mksysdep
}

if $(VMS)
{
    actions _INGDIRS
    {
	mkidir
	if $severity .eq. 1 then $(TOUCH) $(<)
    }
}
else
{
    actions _INGDIRS
    {
	mkidir && $(TOUCH) $(<)
    }
}

actions _INGDIRSNT
{
    call mkidir.bat && $(TOUCH) $(<)
}

actions _CALLBZARCHBAT
{
    $(CD) $(INGBAT)
    call mkbzarch.bat
    touch $(<)
}


actions _CALLGVBAT
{
    rm $(<)
    call mkgv.bat
}



actions _LIBPRT
{
	. shlibinfo
	sed "s/\$SLSFX/$SLSFX/" $(>) | yypp > $(<)
}

if $(VMS)
{
    actions _MSGHDR
    {
	ercompile -h $(ERCOMPFLAGS) $(>)
	$(MV) $(<:D=) $(<)
    }
}
else
{
# Do the ercompile in /tmp so it doesn't stress it's tiny
# brain about input/output paths.

    actions _MSGHDR
    {
	rm -f $(>:D=/tmp)
	cp $(>) $(>:D=/tmp) &&
	( cd /tmp && ercompile -h $(ERCOMPFLAGS) $(>:D=) ) && 
	mv $(<:D=/tmp) $(<) && rm -f $(>:D=/tmp)
    }
}


actions _MSGHDRW
{
	rm -f $(>:D=$(TEMP))
	cp $(>) $(>:D=$(TEMP)) 
	$(CD) $(TEMP) 
	ercompile -h $(ERCOMPFLAGS) $(>:D=) 
	if not errorlevel 1 mv $(<:D=$(TEMP)) $(<)& rm -f $(>:D=$(TEMP))
}

# wild hocus pocus to allow concurrent ercompiles:
# move to a private directory for the tmp.srt file.

if $(VMS)
{
    actions _MNX
    {
	set default $(>[1]:D)
	mnxflag="-"+f$extr(0, 1, "$(<:D=)")
	$(ERCOMPILE) 'mnxflag' $(>:D=)
	$(MV) $(<:D=) $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
    actions _MNXO
    {
	set default $(>[1]:D)
	mnxflag="-"+f$extr(0, 1, "$(<:D=)")+"$(<:D=)"
	$(ERCOMPILE) $(ERCOMPFLAGS) 'mnxflag' $(>:D=)
	$(MV) $(<:D=) $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions _MNX
    {
	[ "$(<:D)" ] && mkdir /tmp/$$ && cd /tmp/$$
	mnxflag="`expr $(<:D=) : '\(.\)'`"
	$(ERCOMPILE) $(ERCOMPFLAGS) -${mnxflag}$(<) $(>)
	chmod $(FILEMODE) $(<)
	[ "$(<:D)" ] && cd /tmp && rm -rf /tmp/$$
    }
}

# This is a Windows only action 
actions _MNXW
{
	cd $(>[1]:D)
	echo $(<:D=) | $(EGREP) "^s|slow" > NUL 2>&1
	IF errorlevel 1 (SET mnxflag=-f) ELSE SET mnxflag=-s
	$(ERCOMPILE) $(ERCOMPFLAGS) %mnxflag%$(<:D=) $(>)
	if not errorlevel 1 $(CP) $(<:D=) $(<)
	SET mnxflag=
}

actions _MKFECAT
{
	mkfecat 
	$(CHMOD) $(FILEMODE) $(<) 
}


if $(VMS)
{
    actions _MSGTXT
    {
	set default $(>[1]:D)
	MSGFILES = " $(>[1-20]:BS), "
	MSGFILES = MSGFILES + " $(>[20-]:BS), "
	MSGFILES = f$edit(MSGFILES, "collapse")
	i=0
	define sys$output $(<)
	loop:
	    file=f$elem(i, ",", MSGFILES)
	    if file .eqs. "," .or. file .eqs. "" then goto endloop
	    $(PIPE) $(AWK) "/^[EWI]_|^S_DU/ { print """" ; print ; print """" ; } /^\/\*%/,/^\*\// { print ; }" 'file' | sed -e "s/User Action:/Recommendation:/" -e "s/Description:/Explanation:/" -e "s:^/\*%::" -e "s:^\*\*::" -e "s:^\*/::"
	    i=i+1
	    goto loop
	endloop:
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions _MSGTXT
    {
	cat $(>) | \
	$(AWK) '/^[EWI]_|^S_DU/ { print "" ; print ; print "" ; } \
	     /^\/\*%/,/^\*\// { print ; }' | \
	sed -e "s/User Action:/Recommendation:/" \
	    -e "s/Description:/Explanation:/" \
	    -e "s:^/\*%::" \
	    -e "s:^\*\*::" \
	    -e "s:^\*/::" > $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}

# This is a Windows only action 
actions _MSGTXTW
{
    echo /^^[EWI]_^|^^S_DU/ { print "" ; print ; print "" ; } > awk.input
    echo /^^\/\*%%/,/^^\*\// { print ; } >> awk.input

    echo s/User Action:/Recommendation:/> sed.input
    echo s/Description:/Explanation:/>> sed.input
    echo s:^^/\*%::>> sed.input
    echo s:^^\*\*::>> sed.input
    echo s:^^\*/::>> sed.input

    cat $(>) | $(AWK) $(AWKARGS) -f awk.input | $(SED) $(SEDARGS) -f sed.input > $(<)
    $(CHMOD) $(FILEMODE) $(<)
    $(RM) sed.input awk.input
}

actions _OSLHDR
{
  align=`$(AWK) '/ALIGN_RESTRICT/ { print $4 ; }' $(HDRCL_U)/bzarch.h | head -1`
  yypp $(>) | sed -e s/ALIGN_RESTRICT/"$align"/ \
                  -e 's/\/%/\/\*/g' -e 's/%\//\*\//g' \
                  -e s/DUMMY_ALIGN/ALIGN_RESTRICT/ -e 's/^%//' > $(<)
  $(CHMOD) $(FILEMODE) $(<)
}

actions _BPWD
{
	rm -f $(<)
	bvalidpw
}

actions _MKPWD
{
	rm -f $(<)
        rm -f $(INGFILES)/iipwd/$(<).dis
	mkvalidpw -b
        cp -p $(<) $(INGFILES)/iipwd/$(<:B).dis
}

actions _TIMEZONE
{
	$(PIPE) iizic -d $(INGZONE) $(>) && $(TOUCH) $(<)
	$(CHMOD) $(FILEMODE) $(<)
}

actions _TIMEZONEHB
{
	$(INGUTIL)$(DFS)$(SUFHB)$(DFS)iizic -d $(INGZONE)$(DFS)$(SUFHB) $(>) && $(TOUCH) $(<)
	chmod $(FILEMODE) $(<)
}

actions _TIMEZONETHINCL
{
	if not exist $(INGTHINCLIENT)\\files\\zoneinfo mkdir $(INGTHINCLIENT)\\files\\zoneinfo
	iizic -d $(INGTHINCLIENT)/files/zoneinfo $(>) && $(TOUCH) $(<)
	chmod $(FILEMODE) $(<)
}

if $(VMS)
{
    actions _UDTIIADD
    {
	pipe ( type $(>) ; sed -n "s/BYTE_ALIGN/ALIGNMENT_REQUIRED/p" $(HDRCL_ALL)bzarch.h ) | type sys$pipe > $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions _UDTIIADD
    {
	( 
	    cat $(>)
	    sed -n 's/BYTE_ALIGN/ALIGNMENT_REQUIRED/p' $(HDRCL_U)$(DFS)bzarch.h
	    grep "BIG_ENDIAN_INT" $(HDRCL_U)$(DFS)bzarch.h
            grep "#define[ 	]*DB_PS_ENCODE_MACRO" $(HDRCOMMON)/iicommon.h
            grep "#define[ 	]*DB_P_DECODE_MACRO" $(HDRCOMMON)/iicommon.h
            grep "#define[ 	]*DB_S_DECODE_MACRO" $(HDRCOMMON)/iicommon.h
            grep "#define[ 	]*DB_PREC_TO_LEN_MACRO" $(HDRCOMMON)/iicommon.h
	) > $(<)

	$(CHMOD) $(FILEMODE) $(<)
    }
}

actions _UDTIIADDW
{
	$(CP) $(>) $(<)
	chmod $(FILEMODE) $(<)
	echo #define ALIGNMENT_REQUIRED >> $(<)
}

actions _UTLD
{
	( echo "#define LDLIB $(LINKLIBS) "; cat $(>) ) | yypp > $(<)
	chmod $(FILEMODE) $(<)
}

actions _UUENCODELIB
{
	uudecode $(>)
	[ $(<) != $(<:D=) ] && mv -f $(<:D=) $(<)
	ranlib $(<)
}

actions _YAPPFILE
{
	$(PIPE) yapp $(YAPPFLAGS) $(>) > $(<)
	$(CHMOD) $(FILEMODE) $(<)
}

actions _YAPPGCFFILE
{
	cd $(>:D)
	$(PIPE) yapp $(YAPPFLAGS) $(>:D=) > $(<)
	$(CHMOD) $(FILEMODE) $(<)
}

actions CCROFIX
{
	$(CP) $(>) $(<)
}

actions quietly CCSHW
{
	$(CD) $(>:D)
	echo EXEC SQL BEGIN DECLARE SECTION; > $(>:D=)_
	cat $(>:D=) >> $(>:D=)_
	echo EXEC SQL END DECLARE SECTION; >> $(>:D=)_
	esqlc $(ESQLCFLAGS) -f$(<:D=) $(>:D=)_
	del $(>:D=)_

}

actions quietly CCSC
{
	esqlc $(ESQLCFLAGS) -h$(EQHDRS) -f$(<) $(>)
}

if $(UNIX)
{
    actions quietly Esqh
    {
	[ -f $(INGFILES)$(DFS)symbol.tbl ] && mv $(INGFILES)$(DFS)symbol.tbl \
		$(INGFILES)$(DFS)symbol.jam
	esqlc $(ESQLCFLAGS) -h$(EQHDRS) -f$(<) $(>)
	[ -f $(INGFILES)$(DFS)symbol.jam ] && mv $(INGFILES)$(DFS)symbol.jam \
		$(INGFILES)$(DFS)symbol.tbl
    }
}
else if $(NT)
{
    actions quietly Esqh
    {
	if exist $(INGFILES)$(DFS)symbol.tbl mv $(INGFILES)$(DFS)symbol.tbl $(INGFILES)$(DFS)symbol.jam
	esqlc $(ESQLCFLAGS) -h$(EQHDRS) -f$(<) $(>)
	if exist $(INGFILES)$(DFS)symbol.jam  mv $(INGFILES)$(DFS)symbol.jam $(INGFILES)$(DFS)symbol.tbl
    }
}
else if $(VMS)
{
    actions quietly Esqh
    {
	esqlc $(ESQLCFLAGS) -h$(EQHDRS) -f$(<) $(>)
    }
}

actions quietly CcScToInc
{
	esqlc $(ESQLCFLAGS) -h$(EQHDRS) -f$(<) $(>)
}
actions quietly CCSCO
{
	esqlc $(ESQLCFLAGS) $(ESQLCFLAGO) -h$(EQHDRS) -f$(<) $(>)
}

# special action for esqlc hdrs in dbutil!duf!hdr
if $(VMS)
{
   actions quietly CCDUFSH
   {
	pipe write sys$output "EXEC SQL BEGIN DECLARE SECTION;" > $(>:S=.sh1)
        pipe write sys$output "EXEC SQL END DECLARE SECTION;" > $(>:S=.sh2)
        pipe type /nohead $(>:S=.sh1), $(>), $(>:S=.sh2) > $(>:S=.sh_)
        esqlc $(ESQLCFLAGS) -h$(EQHDRS) -f$(<) $(>:S=.sh_)
        $(RM) $(>:S=.sh1)$(ALLREVS), $(>:S=.sh_)$(ALLREVS), $(>:S=.sh2)$(ALLREVS)
   }
}
else
{
   actions quietly CCDUFSH
   {
	$(ECHO) " EXEC SQL BEGIN DECLARE SECTION; " > $(>:S=.sh_) ;
	$(CAT) $(>) >> $(>:S=.sh_) ;
	$(ECHO) " EXEC SQL END DECLARE SECTION; " >> $(>:S=.sh_) ;
	[ -f $(INGFILES)$(DFS)symbol.tbl ] && mv $(INGFILES)$(DFS)symbol.tbl \
		$(INGFILES)$(DFS)symbol.jam
	esqlc $(ESQLCFLAGS) -h$(EQHDRS) -f$(<) $(>:S=.sh_) ;
	[ -f $(INGFILES)$(DFS)symbol.jam ] && mv $(INGFILES)$(DFS)symbol.jam \
		$(INGFILES)$(DFS)symbol.tbl
	$(RM) $(>:S=.sh_) ; 
   }
}
actions quietly CCDUFSHW
{
	$(CD) $(>:D)
	echo EXEC SQL BEGIN DECLARE SECTION; > $(>:D=)_
	cat $(>:D=) >> $(>:D=)_
	echo EXEC SQL END DECLARE SECTION; >> $(>:D=)_
	if exist $(INGFILES)$(DFS)symbol.tbl mv $(INGFILES)$(DFS)symbol.tbl $(INGFILES)$(DFS)symbol.jam
	esqlc $(ESQLCFLAGS) -f$(<:D=) $(>:D=)_
	if exist $(INGFILES)$(DFS)symbol.jam mv $(INGFILES)$(DFS)symbol.jam $(INGFILES)$(DFS)symbol.tbl
	del $(>:D=)_

}


actions quietly CCQC
{
	eqc $(EQCFLAGS) -h$(EQHDRS) -f$(<) $(>)
}

if $(UNIX)
{
    actions quietly Eqh
    {
	[ -f $(INGFILES)$(DFS)symbol.tbl ] && mv $(INGFILES)$(DFS)symbol.tbl \
		$(INGFILES)$(DFS)symbol.jam
	eqc $(EQCFLAGS) -h$(EQHDRS) -f$(<) $(>)
	[ -f $(INGFILES)$(DFS)symbol.jam ] && mv $(INGFILES)$(DFS)symbol.jam \
		$(INGFILES)$(DFS)symbol.tbl
    }
}
else if $(NT)
{
    actions quietly Eqh
    {
	if exist $(INGFILES)$(DFS)symbol.tbl mv $(INGFILES)$(DFS)symbol.tbl $(INGFILES)$(DFS)symbol.jam
	eqc $(EQCFLAGS) -h$(EQHDRS) -f$(<) $(>)
	if exist $(INGFILES)$(DFS)symbol.jam  mv $(INGFILES)$(DFS)symbol.jam $(INGFILES)$(DFS)symbol.tbl
    }
}
else if $(VMS)
{
    actions quietly Eqh
    {
	eqc $(EQCFLAGS) -h$(EQHDRS) -f$(<) $(>)
    }
}

if $(VMS)
{
    actions CCBYACC1
    {
	p=f$extr(0, f$loc("gram", "$(<[1]:B)"), "$(<[1]:B)" )
	byacc $(BYACCFLAGS) -l -c$(<[1]) -d$(<[2]) -y $(<[3]) -p'p' $(>)
    }
}
else
{
    actions CCBYACC1
    {
	p=`echo $(<[1]:B) | sed s/gram//`
	byacc $(BYACCFLAGS) -l -c$(<[1]) -d$(<[2]) -y $(<[3]) -p$p $(>)
    }
}

actions CCBYACC1W
{
	byacc $(BYACCFLAGS) -l -c$(<[1]) -d$(<[2]) -y $(<[3]) -ppsl $(>)
}
actions CCBYACC1WS
{
	byacc $(BYACCFLAGS) -l -c$(<[1]) -d$(<[2]) -y $(<[3]) -ppsls $(>)
}

if $(VMS)
{
    actions CCIYACC1
    {
	iyacc $(IYACCFLAGS) -d $(>)
	yycase pgtab.c $(<[1])
	if $severity .eq. 1
	then	$(MV) pgtab.h $(<[2])
		$(RM) pgtab.c$(ALLREVS)
	endif
    }
}
else
{
    actions CCIYACC1
    {
	# temp files - do it locally
	[ "$(<[1]:D)" ] && cd $(<[1]:D)
	if iyacc $(IYACCFLAGS) -d $(>) && 
	   yycase y.tab.c $(<[1]) 
	then
	    mv -f y.tab.h $(<[2])
	    rm -f y.tab.c
	fi
    }
}

actions CCIYACC1W bind HDREMBEDM
{

	$(CD) $(<[1]:D)
	iyacc $(IYACCFLAGS) -d $(>:D=)
	yycase y.tab.c $(<[1]:D=)	
	mv y.tab.h $(<[2]:D=)
	rm -f y.tab.c
}

actions CCIYACC1WHB bind HDREMBEDM
{
	$(CD) $(<[1]:D)
	iyacc $(IYACCFLAGS) -d $(>)
	yycase y.tab.c $(<[1])	
	mv y.tab.h $(<[2])
	rm -f y.tab.c
}

actions CCSY2YFW
{
	$(CD) $(<:D)
	eqmerge $(EQMRGTYPE) -I$(HDRM) -o $(<) $(>)
}



actions CCLEXW
{
	$(CD) $(>:D)
	$(FLEX) $(>)
	if NOT "%USE_CYGWIN%"=="" u2d $(>) 
	copy lex.yy.c $(>:S=.c)
	if NOT "%USE_CYGWIN%"=="" u2d $(>:S=.c)
}

actions CCLEXWHB
{

	$(CD) $(>:D)
	$(FLEX) $(>) 
	copy lex.yy.c $(>:S=.c)
	$(CP) $(>:S=.c) $(SUFHB)
}

if $(VMS)
{
#  Installations of Ingres have a symbol compform defined with the -m flag which
#  if picked up in the build generates machine code instead of the required 'C' code.
   actions CCLFM
   {       
	mc ING_BUILD:[bin]compform$(SUFEXE) $(COMPFORMFLAGS) $(DUMMYDB) $(>) $(<)
   }
}
else
{
   actions CCLFM
   {       
	compform $(COMPFORMFLAGS) $(DUMMYDB) $(>) $(<)
   }
}

if $(VMS)
{
    actions CCEQMRG
    {
	eqmerge $(EQMRGTYPE) -I$(HDRM) -o$(<) $(>)
    }
}
else
{
    actions CCEQMRG
    {
	# eqmerge has a temp file - do it locally
	[ "$(<:D)" ] && cd $(<:D)
	eqmerge $(EQMRGTYPE) -I$(HDRM) -o$(<) $(>)
    }
}

actions CCEQMRGW
{
	$(CD) $(>:D)
	eqmerge $(EQMRGTYPE) -I$(HDRM) -o$(<) $(>) 
}

if $(VMS)
{
    actions As
    {
	$(AS) $(ASFLAGS) /obj=$(<) $(>)
    }
    actions AsMigr
    {
	$(AS) /MIGRATE /obj=$(<) $(>)
    }

}
else if $(VERS64) = r64_us5
{
    actions As
    {
        $(CPP) -P $(ASCPPFLAGS) $(>) | $(M4) $(ASM4FLAGS) -  > $(>:D=/tmp) ;
        $(AS) $(ASFLAGS) -o $(<) $(>:D=/tmp)
#       rm -f $(>:D=/tmp)
    }
}
else
{
    actions As
    {
	$(CPP) -P $(ASCPPFLAGS) $(>) > $(>:D=/tmp)
	$(AS) $(ASFLAGS) -o $(<) $(>:D=/tmp)
#	rm -f $(>:D=/tmp)
    }
}

actions VMSMsg
{
	message /obj=$(<) $(>)
}

actions xIILIBEXE
{
	ld r -o $(<) $(>:S=$(SUFOBJ)) $(LINKFLAGS) $(NEEDLIBS)
	chmod $(FILEMODE) $(<)
}

actions _LIBINGRES
{
	mergelibs
	chmod $(FILEMODE) $(<)
}
actions _LIBINGRESW
{
	$(AR) /nologo /out:$(<) $(>) 	
}

actions _LIBINGRES64
{
	mergelibs -$(SUFHB)
	chmod $(FILEMODE) $(<)
}

actions _IIMERGELIB
{
	temp=/tmp/$$ 
	trap 'rm -rf $temp' 0 
	mkdir $temp 
	cd $temp 
	rm -f $(<)
	for i in $(>)
	{
	  ar x $i 
	  ar ru $(<) *$(SUFOBJ) 
	  rm -f *$(SUFOBJ)
	}
}

if $(VMS)
{
    actions IICCPP
    {
        dvc=F$PARSE("$(>)",,,"DEVICE")
        pth=F$PARSE("$(>)",,,"DIRECTORY")
        tmp=F$FAO("!AS!ASiiccpp.tmp_!AS", dvc, pth, F$GETJPI(0, "PID"))
	pipe search $(HDRTOOLS)$(DFS)default.h "#" | type/nohead sys$pipe, $(>) /out='tmp'
	pipe ccpp 'tmp' > $(<)
	$(RM) 'tmp'$(ALLREVS)
	$(CHMOD) $(FILEMODE) $(<)
    }
}
else
{
    actions IICCPP
    {
	grep "^#" $(HDRTOOLS)/default.h | \
	cat - $(>) | \
	ccpp -I$(>:D) -Usun > $(<)
	$(CHMOD) $(FILEMODE) $(<)
    }
}

actions IICCPPW
{
	$(RM) $(<)
	ccpp $(>) > $(<) 
	chmod $(FILEMODE) $(<) 
}

actions IIMAKEFILE
{
	$(MAKE) $(MAKEFLAGS) $(<) ;
}

actions IIUCHARMAP
{
	unimapcompile -o=$(<:D=) $(>)
	chmod $(FILEMODE) $(<) 
}

if $(VERS64) = r64_us5
{
actions _IIUCHARMAPHB
{
	II_CONFIG=$(ING_BUILD)$(DFS)files; export II_CONFIG
	II_LP64_ENABLED=TRUE; export II_LP64_ENABLED
        LIBPATH=$(ING_BUILD)$(DFS)lib$(DFS)$(SUFHB):$LIBPATH; export LIBPATH
	$(INGUTIL)$(DFS)$(SUFHB)$(DFS)unimapcompile -o=$(<:D=) $(>)
	chmod $(FILEMODE) $(<) 
}
}
else if $(NT)
{
actions _IIUCHARMAPHB
{
	set II_CONFIG=$(ING_BUILD)$(DFS)files
	set $(HB_ENABLE_VAR)=TRUE && echo '%$(HB_ENABLE_VAR)%'
	$(INGUTIL)$(DFS)$(SUFHB)$(DFS)unimapcompile$(SUFEXE) -o=$(<:D=) $(>)
	chmod $(FILEMODE) $(<) 
}
}
else
{
actions _IIUCHARMAPHB
{
	II_CONFIG=$(ING_BUILD)$(DFS)files; export II_CONFIG
	$(HB_ENABLE_VAR)=TRUE; export $(HB_ENABLE_VAR)
	$(INGUTIL)$(DFS)$(SUFHB)$(DFS)unimapcompile -o=$(<:D=) $(>)
	chmod $(FILEMODE) $(<) 
}
}

actions IIUCHARALIAS
{
	unialscompile $(>)
	chmod $(FILEMODE) $(<) 
}

if $(VERS64) = r64_us5
{
actions _IIUCHARALIASHB
{
	II_CONFIG=$(ING_BUILD)$(DFS)files; export II_CONFIG
	II_LP64_ENABLED=TRUE; export II_LP64_ENABLED
        LIBPATH=$(ING_BUILD)$(DFS)lib$(DFS)$(SUFHB):$LIBPATH; export LIBPATH
	$(INGUTIL)$(DFS)$(SUFHB)$(DFS)unialscompile -o=$(<:D=) $(>)
	chmod $(FILEMODE) $(<) 
}
}
else if $(NT)
{
actions _IIUCHARALIASHB
{
	set II_CONFIG=$(ING_BUILD)$(DFS)files
	set $(HB_ENABLE_VAR)=TRUE
	$(INGUTIL)$(DFS)$(SUFHB)$(DFS)unialscompile$(EXESFX) -o=$(<:D=) $(>)
	chmod $(FILEMODE) $(<) 
}
}
else
{
actions _IIUCHARALIASHB
{
	II_CONFIG=$(ING_BUILD)$(DFS)files; export II_CONFIG
	$(HB_ENABLE_VAR)=TRUE; export $(HB_ENABLE_VAR)
	$(INGUTIL)$(DFS)$(SUFHB)$(DFS)unialscompile -o=$(<:D=) $(>)
	chmod $(FILEMODE) $(<) 
}
}

actions IITXVIEWFILE
{
	Must export ROOTDIR because viewc needs it.
	ROOTDIR=$(TUXEDODIR) ; export ROOTDIR ;
	$(TUXEDODIR)/bin/viewc -n -d $(INGLIB) $(>) ;
	chmod $(FILEMODE) $(<) ;
}

actions IISHLIBFROMARCHIVE
{
    rm -rf $(<) $(<:D)/*$(SUFOBJ)    
    pushd $(<:D)      
    ar -x $(>)
    popd
    touch $(<)
}

actions _IIFASTI
{
    call fasti.bat $(II_INSTALLATION) clean
}

actions _NOIIINST
{
    echo "ERROR: II_INSTALLATION must be set!" ;
    echo "Otherwise run 'jam -s II_INSTALLATION=<II_INSTALLATION> install'" ;
}

if $(NT)
{
      if $(JAM_TOOLSET) = VISUALC || $(JAM_TOOLSET) = INTELC
      {
	actions updated together piecemeal Archive
	{
		if exist $(<) $(CP) $(<) $(<).$(>[0]:B) & $(AR) /nologo /VERBOSE /OUT:$(<) $(<).$(>[0]:B) $(>) &  $(RM) $(<).$(>[0]:B)
		if not exist $(<) $(AR) /nologo /VERBOSE /OUT:$(<) $(>)
	}

	if $(CUSTOMFLAG) != ""
	{
		actions Cc
		{
			cd $(>:D)
    			$(CC) -c $(CUSTOMFLAG) $(CCFLAGS) $(OPTIM) /I$(HDRS) /I$(STDHDRS) $(>)
		}
	}

	if $(DEBUG) = "ON"
	{
		actions together SharedLibLink bind NEEDLIBS NEEDOBJ NEEDRES LIBP
		{
		$(LINK) /DLL $(LINKFLAGS) /DEF:$(INGDEFS)/$(<:B).$(DEFSFX) /IMPLIB:$(<:S=.$(LIBSFX)) /LIBPATH:"$(LIBP)" /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		Chmod $(DLLMODE) $(<)
		}
	
		actions SharedLibLinkLcl bind NEEDLIBS NEEDOBJ NEEDRES NODEFAULTLIB LIBP
		{
		$(LINK) /DLL $(LINKFLAGS) /DEF:$(<:S=.$(DEFSFX)) $(NODEFAULTLIB) $(<:S=$(SUFOBJ)) /LIBPATH:"$(LIBP)" /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		}
	 	actions SharedLibLinkNoDef bind NEEDLIBS NEEDOBJ NEEDRES LIBP
 		{
	 	$(LINK) /DLL $(LINKFLAGS) /IMPLIB:$(<:S=.$(LIBSFX)) /LIBPATH:"$(LIBP)" /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		Chmod $(DLLMODE) $(<)
		}
	 	actions SharedLibLinkNoImp bind NEEDLIBS NEEDOBJ NEEDRES LIBP
	 	{
		$(LINK) /DLL $(LINKFLAGS) /DEF:$(INGDEFS)/$(<:B).$(DEFSFX) /LIBPATH:"$(LIBP)" /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		Chmod $(DLLMODE) $(<)
		}
	    	actions Link bind NEEDLIBS NEEDOBJ NEEDRES 
    		{
    		$(LINK) $(LINKFLAGS) /LIBPATH:"$(LIBP)" /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#1
    		}

	}
	else
	{
		actions together SharedLibLink bind NEEDLIBS NEEDOBJ NEEDRES LIBP
		{
		$(LINK) /DLL $(LINKFLAGS) /DEF:$(INGDEFS)/$(<:B).$(DEFSFX) /IMPLIB:$(<:S=.$(LIBSFX)) /LIBPATH:"$(LIBP)" /out:$(<) /PDB:$(<:S=.$(PDBSFX)) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		Chmod $(DLLMODE) $(<)
		}
		actions SharedLibLinkLcl bind NEEDLIBS NEEDOBJ NEEDRES NODEFAULTLIB LIBP
		{
		$(LINK) /DLL $(LINKFLAGS) /DEF:$(<:S=.$(DEFSFX)) $(NODEFAULTLIB) $(<:S=$(SUFOBJ)) /LIBPATH:"$(LIBP)" /out:$(<) /PDB:$(<:S=.$(PDBSFX)) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		}
	 	actions SharedLibLinkNoDef bind NEEDLIBS NEEDOBJ NEEDRES LIBP
 		{
 		$(LINK) /DLL $(LINKFLAGS) /IMPLIB:$(<:S=.$(LIBSFX)) /LIBPATH:"$(LIBP)" /out:$(<) /PDB:$(<:S=.$(PDBSFX)) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		Chmod $(DLLMODE) $(<)
		}
 		actions SharedLibLinkNoImp bind NEEDLIBS NEEDOBJ NEEDRES LIBP
	 	{
		$(LINK) /DLL $(LINKFLAGS) /DEF:$(INGDEFS)/$(<:B).$(DEFSFX) /LIBPATH:"$(LIBP)" /out:$(<) /PDB:$(<:S=.$(PDBSFX)) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#2
		Chmod $(DLLMODE) $(<)
		}
	    	actions Link bind NEEDLIBS NEEDOBJ NEEDRES 
    		{
    		$(LINK) $(LINKFLAGS) /LIBPATH:"$(LIBP)" /out:$(<) /PDB:$(<:S=.$(PDBSFX)) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(NEEDOBJ) $(NEEDRES)
		if errorlevel 1 EXIT
		if exist $(MT) if exist $(<:D=$(<[1]:D)).manifest $(MT) -nologo -manifest $(<:D=$(<[1]:D)).manifest -outputresource:$(<);#1
    		}

	}
	actions Rebase
	{
	$(REBASE) -b 0x70000000 -e 10000 $(INGBIN)\*.$(SLSFX)
	if %errorlevel%==0 $(RM) $(INGTOOLSBIN)\binaddr.txt & $(REBASE) -b 0x70000000 -e 10000 -C $(INGTOOLSBIN)\binaddr.txt $(INGBIN)\*.$(SLSFX) 
	if %errorlevel% GEQ 1 if exist $(INGTOOLSBIN)\binaddr.txt if exist $(INGBIN)\$(<:D=) $(REBASE) -s -b 0x70000000 $(INGBIN)\$(<:D=)|$(AWK) '{print $7}'|sed s:)::>$(INGBIN)\$(<:S=.sz:D=) & if exist $(INGBIN)\updcoffbf.exe updcoffbf.exe $(INGTOOLSBIN)\binaddr.txt $(<:D=) $(INGBIN)\$(<:S=.sz:D=) & $(REBASE) -v -i $(INGTOOLSBIN)\binaddr.txt $(INGBIN)\$(<:D=) 
	}
	actions RebaseHB
	{
	$(REBASE) -b 0x70000000 -e 10000 $(INGBIN)$(DFS)$(SUFHB)$(DFS)*.$(SLSFX)
	if %errorlevel%==0 $(RM) $(INGTOOLSBIN)$(DFS)$(SUFHB)$(DFS)binaddr.txt & $(REBASE) -b 0x70000000 -e 10000 -C $(INGTOOLSBIN)$(DFS)$(SUFHB)$(DFS)binaddr.txt $(INGBIN)$(DFS)$(SUFHB)$(DFS)*.$(SLSFX) 
	if %errorlevel% GEQ 1 if exist $(INGTOOLSBIN)$(DFS)$(SUFHB)$(DFS)binaddr.txt if exist $(INGBIN)$(DFS)$(SUFHB)$(DFS)$(<:D=) $(REBASE) -s -b 0x70000000 $(INGBIN)$(DFS)$(SUFHB)$(DFS)$(<:D=)|$(AWK) '{print $7}'|sed s:)::>$(INGBIN)$(DFS)$(SUFHB)$(DFS)$(<:S=.sz:D=) & if exist $(INGBIN)$(DFS)$(SUFHB)$(DFS)updcoffbf.exe updcoffbf.exe $(INGTOOLSBIN)$(DFS)$(SUFHB)$(DFS)binaddr.txt $(<:D=) $(INGBIN)$(DFS)$(SUFHB)$(DFS)$(<:S=.sz:D=) & $(REBASE) -v -i $(INGTOOLSBIN)$(DFS)$(SUFHB)$(DFS)binaddr.txt $(INGBIN)$(DFS)$(SUFHB)$(DFS)$(<:D=) 
	}

	actions updated together ImpArchiveOnly
	{
		$(AR) /nologo /DEF:$(INGDEFS)$(DFS)$(<:B).$(DEFSFX) /out:$(<:D)$(DFS)$(<:B).$(LIBSFX)
	}

	actions together ImpArchive
	{
		   $(AR) /nologo /DEF:$(INGDEFS)$(DFS)$(<:B).$(DEFSFX) /out:$(<:D)$(DFS)$(<:B).$(LIBSFX) $(>) 
			
	}

	actions _IICOPY
	{
		$(COPY) $(>) $(<)
	}

      }
}

# This is a Windows only action 
actions piecemeal quietly ShellNT
{

    echo NR == 1 { print "$(SHELLHEADER)" } > awk.input
    echo NR == 1 ^&^& /^^[#:]/ { next } >> awk.input
    echo /^^##/ { next } >> awk.input
    echo { print } >> awk.input

    $(AWK) -f awk.input < $(>) > $(<)
    if not "%USE_CYGWIN%"=="" d2u $(<)
    $(RM) awk.input
}

actions _IIRCTORES bind RCHDR 
{
    $(CD) $(<:D)
    $(RM) $(>:S=.res) 
    rc $(RCFLAGS) $(RCHDR) $(>)
    $(TOUCH) $(>) 
}

actions _IIRCTORESW
{
	RC /i $(>:D) $(>)
}

# This is a Windows only action 
actions piecemeal quietly _IICOPYBAT
{
  echo { if ($1 == "REM" ^&^& $2 ~ "[Hh][Ii][Ss][Tt][Oo][Rr][Yy].*") > awk.input
  echo { line = int(NR) ; next } >> awk.input
  echo else if ($1 == "REM" ^&^& NR != 1 ^&^& NR == int(line + 1)) >> awk.input
  echo { line = int(NR) ; next } >> awk.input
  echo else { print }} >> awk.input

  $(AWK) $(AWKARGS) -f awk.input < $(>) > $(<)
  
  $(RM) awk.input
}  

actions piecemeal quietly _IICOPYSQL
{
	sed $(SEDARGS) -e /^##/d  $(>) > $(<)

}

actions quietly _IICOPYFILE
{
    $(CP) $(>) $(<)
}

actions quietly _IITOOLSDIR
{
    if not exist $(<) $(MKDIR) $(<)
}

actions _CCPP
{
    call ccpp.bat $(>) > $(<) 
}

actions _CRSW
{
	sed -e /^^--#/d $(<) > $(<:S=.sed) 
}

actions _SLN
{
	cd $(>:D)
	devenv $(DEVENVFLAGS) $(BUILD) $(MSDEV_CONFIG) /project $(>:D=:S=) $(>) 
}

actions _IIVERSREL
{
    $(RM) $(RMFLAGS) $(<)$(ALLREVS) 
    $(PIPE) genrelid > $(<) 
}
if $(config_string) = "a64_win"
{
actions _IIVERSRELW
{
    rm -rf $(<)
    call genrelid.bat INGRES > verstmp.rel 
    $(SHELL) -c "sed $(SEDARGS) 's/\"//g' verstmp.rel > $(<)"
    rm verstmp.rel

}
}
else
{
actions _IIVERSRELW
{
    rm -rf $(<)
    call genrelid.bat INGRES > verstmp.rel 
    sh -c "sed $(SEDARGS) 's/\"//g' verstmp.rel > $(<)"
    rm verstmp.rel

}
}

actions _SLNDOTNET
{
	cd $(>:D)
	devenv  $(DEVENVFLAGS) $(BUILD) $(MSDEV_CONFIG) $(>)
}


actions _ICEHTML
{
    $(PIPE) sed $(SEDARGS) -e "/^##/d" -e "s/#cgi#/$(CGI_EXT)/" -e "s/#ext#/$(ICE_EXT)/" $(>) > $(<)
}

actions _ReadMeHtml
{
    $(PIPE) sed $(SEDARGS) -e "s/PLATFORM_STRING/$(platform_string)/" -e "s/#extension_string/readme_$(extension_string).html/" $(>) > $(<)
}
if $(VMS)
{
   actions _PatchHtml
   {
        dtmp :== DEF/JOB/NOLOG TMP_LOG &tmp
        rtmp :== READ SYS$PIPE tmp
        tmplogval  :== F$TRNLNM( """TMP_LOG""" ) ; IF F$TRNLNM( """TMP_LOG""" ) .NES. """""" THEN DEASSIGN/JOB TMP_LOG
        PIPE genrelid | ( rtmp ; dtmp  )
        PIPE relstring='tmplogval
        delete/symbol/global dtmp
        delete/symbol/global rtmp
        delete/symbol/global tmplogval
        sed_rep1 = "s,FULLRELEASESTRING,''relstring',g"
        sed_rep2 = "s,RELSTRING,$(PRELEASE),g"
        sed_rep3 = "s,OSNAME,$(platform_string),g"
        sed_rep4 = "s,GENLEVEL,$(GENLEVEL),g"
        sed_rep5 = "s,SPLEVEL,$(SPLEVEL),g"
        PIPE sed -e "''sed_rep1'" -e "''sed_rep2'" -e "''sed_rep3'" -e "''sed_rep4'" -e "''sed_rep5'" $(>) > $(<)
   }

   actions piecemeal quietly existing Clean
   {
      files:=$(>)
      clean_cnt=f$trnlnm("JAM_CLEAN_CNT")
 
      if clean_cnt .eqs. "" then clean_cnt = 0
      if 'clean_cnt .gt. 200
      then
         clean_cnt = 0
 
         write sys$output "Clean clean"
      endif
 
      cnt=0
      loop:
         a_file=F$element('cnt', " ", files)
 
         if a_file .nes. " "
         then
            cnt=cnt+1
 
            b_file=F$ELEMENT(1, "=", a_file)
 
            if b_file .nes. "=" then a_file = b_file
 
            IF F$SEARCH("''a_file'") .nes. "" then $(RM) 'a_file';*
 
            goto loop
         endif
 
      clean_cnt = 'clean_cnt + 'cnt
      DEFINE/NOLOG/JOB JAM_CLEAN_CNT 'clean_cnt
   }    
}
else
if $(NT)
{
   actions _PatchHtml
   {
        genrelid relstring
        PIPE sed -e "s,FULLRELEASESTRING,$relstring,g"  -e "s,RELSTRING,$(PRELEASE),g"  -e "s,OSNAME,$(platform_string),g" -e "s,GENLEVEL,$(GENLEVEL)",g" -e "s,SPLEVEL,$(SPLEVEL)" $(>) > $(<)
$
   }
}
else
{
   actions _PatchHtml
   {
       	relstring=`genrelid`
       	sed -e "s,FULLRELEASESTRING,$relstring,g" \
       		-e "s,RELSTRING,$(PRELEASE),g" \
		-e "s,OSNAME,$(platform_string),g" \
		-e "s,GENLEVEL,"$(GENLEVEL)",g" \
		-e "s,SPLEVEL,"$(SPLEVEL)",g" \
	 $(>) > $(<)
   }
}

actions EsqlHdr
{
	$(CP) $(>) $(<)
}

if $(NT)
{
	actions _IIAWK
	{
		cd $(>[2]:D)
                $(AWK) -v OUT=$(<:BS) -f $(>:BS)
	}
	actions FiRoc
	{
	        cd $(>[2]:D)
		$(AWK) -v roc_file=$(<:BS) -f $(>:BS)
	}
	actions FiRocLu
	{
	        cd $(>[2]:D)
		$(AWK) -v roclu_file=$(<:BS) -f $(>:BS)
	}
	actions FiH
	{
	        cd $(>[2]:D)
		$(AWK) -v h_file=$(<:BS) -f $(>:BS)
	}
	actions AduPatHdr
	{
		cd $(>[2]:D)
		$(AWK) -v header=$(<:BS) -f $(>:BS)
	}
	actions AduPatBdy
	{
		cd $(>[2]:D)
		$(AWK) -v verbose=0 -v body=$(<:BS) -f $(>:BS)
	}
}
else if $(VMS)
{
	actions _IIAWK
	{
	        if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)

                set default $(<:D)
		$(AWK) -v "OUT=$(<:BS)" -f $(>:BS)
	}
	actions FiRoc
	{
	        if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)

                set default $(<:D)
		$(AWK) -v roc_file=$(<:BS) -f $(>:BS)
	}
	actions FiRocLu
	{
	        if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)

                set default $(<:D)
		$(AWK) -v roclu_file=$(<:BS) -f $(>:BS)
	}
	actions FiH
	{
	        if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)

                set default $(<:D)
		$(AWK) -v h_file=$(<:BS) -f $(>:BS)
	}
	actions AduPatHdr
	{
		if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)
		set default $(<:D)
		$(AWK) -v header=$(<:BS) -f $(>:BS)
	}
	actions AduPatBdy
	{
		if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)
		set default $(<:D)
		$(AWK) -v verbose=0 -v body=$(<:BS) -f $(>:BS)
	}
}
else
{
	actions _IIAWK
	{
		$(AWK) -v OUT=$(<) -f $(>)
	}
	actions FiRoc
	{
		$(AWK) -v roc_file=$(<) -f $(>)
	}
	actions FiRocLu
	{
		$(AWK) -v roclu_file=$(<) -f $(>)
	}
	actions FiH
	{
		$(AWK) -v h_file=$(<) -f $(>)
	}
	actions AduPatHdr
	{
		$(AWK) -v header=$(<) -f $(>)
	}
	actions AduPatBdy
	{
		$(AWK) -v verbose=0 -v body=$(<) -f $(>)
	}
}

actions DUMMY
{


}

# Override default MkDir1 on UNIX so it doesn't fail
# when the directory exists.
if $(UNIX) 
{
    actions MkDir1
    {
	mkdir -p $(<)
    }
}
else if $(NT)
{
    actions MkDir1
    {
	if not exist $(<) mkdir $(<)
    }
}
else if $(VMS)
{
    actions MkDir1
    {
	if f$parse("$(<:D)") .eqs. "" then create /dir $(<:D)
    }
}

actions IIKitInstalData
{
    mkkitinstal $(<)
}

if $(UNIX)
{
actions _SEDREL
{
	. readvers
	# for eqdefcc.pp, which includes eqdefc.pp
	[ "$(>:D)" ] && cd $(>:D)

	$(SED) '-e s:(PROD1NAME):Ingres:g' '-e s:(PROD_PKGNAME):ingres:g' \
	$(>) > $(>)_
	yypp $(YAPPFLAGS) $(>)_ | sed -e "s:BUILD_NO:$build:g" > $(<)
	$(CHMOD) $(FILEMODE) $(<)
	$(RM) $(>)_
}
}

if $(VMS)
{
    actions IIDBMAXNAME1
    {
        iidbmaxname
	$(PIPE) $(SED) "s/##DB_MAXNAME##/''IIDB_MAXNAME'/" $(>) > $(<)
    }
}
else if $(NT)
{
    actions IIDBMAXNAME1
    {
	for /F "usebackq" %%i in (`iidbmaxname.exe`) do set MAX=%%i
	sed "s/##DB_MAXNAME##/%MAX%/" $(>) > $(<)
    }
}
else
{
    actions IIDBMAXNAME1
    {
	max=`iidbmaxname` 
	$(SED) "s/##DB_MAXNAME##/$max/" $(>) > $(<)
    }
}

actions ExePy
{
    $(CP) $(>) $(<)
}
